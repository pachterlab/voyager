[{"path":"https://pachterlab.github.io/voyager/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Artistic License 2.0","title":"Artistic License 2.0","text":"Copyright (c) 2000-2006, Perl Foundation. Everyone permitted copy distribute verbatim copies license document, changing allowed. Preamble ******** license establishes terms given free software Package may copied, modified, distributed, /redistributed. intent Copyright Holder maintains artistic control development Package still keeping Package available open source free software. always permitted make arrangements wholly outside license directly Copyright Holder given Package. terms license permit full use propose make Package, contact Copyright Holder seek different licensing arrangement. Definitions *********** â€œCopyright Holderâ€ means individual(s) organization(s) named copyright notice entire Package. â€œContributorâ€ means party contributed code material Package, accordance Copyright Holderâ€™s procedures. â€œâ€ â€œâ€ means person like copy, distribute, modify Package. â€œPackageâ€ means collection files distributed Copyright Holder, derivatives collection /files. given Package may consist either Standard Version, Modified Version. â€œDistributeâ€ means providing copy Package making accessible anyone else, case company organization, others outside company organization. â€œDistributor Feeâ€ means fee charge Distributing Package providing support Package another party. mean licensing fees. â€œStandard Versionâ€ refers Package modified, modified ways explicitly requested Copyright Holder. â€œModified Versionâ€ means Package, changed, changes explicitly requested Copyright Holder. â€œOriginal Licenseâ€ means Artistic License Distributed Standard Version Package, current version may modified Perl Foundation future. â€œSourceâ€ form means source code, documentation source, configuration files Package. â€œCompiledâ€ form means compiled bytecode, object code, binary, form resulting mechanical transformation translation Source form. Permission Use Modification Without Distribution ******************************************************** permitted use Standard Version create use Modified Versions purpose without restriction, provided Distribute Modified Version. Permissions Redistribution Standard Version ****************************************************** may Distribute verbatim copies Source form Standard Version Package medium without restriction, either gratis Distributor Fee, provided duplicate original copyright notices associated disclaimers. discretion, verbatim copies may may include Compiled form Package. may apply bug fixes, portability changes, modifications made available Copyright Holder. resulting Package still considered Standard Version, subject Original License. Distribution Modified Versions Package Source ********************************************************** may Distribute Modified Version Source (either gratis Distributor Fee, without Compiled form Modified Version) provided clearly document differs Standard Version, including, limited , documenting non-standard features, executables, modules, provided least ONE following: make Modified Version available Copyright Holder Standard Version, Original License, Copyright Holder may include modifications Standard Version. ensure installation Modified Version prevent user installing running Standard Version. addition, Modified Version must bear name different name Standard Version. allow anyone receives copy Modified Version make Source form Modified Version available others Original License license permits licensee freely copy, modify redistribute Modified Version using licensing terms apply copy licensee received, requires Source form Modified Version, works derived , made freely available license fees prohibited Distributor Fees allowed. Distribution Compiled Forms Standard Version Modified ****************************************************************** Versions without Source *************************** may Distribute Compiled forms Standard Version without Source, provided include complete instructions get Source Standard Version. instructions must valid time distribution. instructions, time carrying distribution, become invalid, must provide new instructions demand cease distribution. provide valid instructions cease distribution within thirty days become aware instructions invalid, forfeit rights license. may Distribute Modified Version Compiled form without Source, provided comply Section 4 respect Source Modified Version. Aggregating Linking Package ********************************** may aggregate Package (either Standard Version Modified Version) packages Distribute resulting aggregation provided charge licensing fee Package. Distributor Fees permitted, licensing fees components aggregation permitted. terms license apply use Distribution Standard Modified Versions included aggregation. permitted link Modified Standard Versions works, embed Package larger work , build stand-alone binary bytecode versions applications include Package, Distribute result without restriction, provided result expose direct interface Package. Items Considered Part Modified Version ******************************************************** Works (including, limited , modules scripts) merely extend make use Package, , , cause Package Modified Version. addition, works considered parts Package , subject terms license. General Provisions ****************** use, modification, distribution Standard Modified Versions governed Artistic License. using, modifying distributing Package, accept license. use, modify, distribute Package, accept license. Modified Version derived Modified Version made someone , nevertheless required ensure Modified Version complies requirements license. license grant right use trademark, service mark, tradename, logo Copyright Holder. license includes non-exclusive, worldwide, free--charge patent license make, made, use, offer sell, sell, import otherwise transfer Package respect patent claims licensable Copyright Holder necessarily infringed Package. institute patent litigation (including cross-claim counterclaim) party alleging Package constitutes direct contributory patent infringement, Artistic License shall terminate date litigation filed. Disclaimer Warranty: PACKAGE PROVIDED COPYRIGHT HOLDER CONTRIBUTORS â€œâ€™ WITHOUT EXPRESS IMPLIED WARRANTIES. IMPLIED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE, NON-INFRINGEMENT DISCLAIMED EXTENT PERMITTED LOCAL LAW. UNLESS REQUIRED LAW, COPYRIGHT HOLDER CONTRIBUTOR LIABLE DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL DAMAGES ARISING WAY USE PACKAGE, EVEN ADVISED POSSIBILITY DAMAGE.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xatac_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"10X Chromium Single Cell ATAC Processing Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xatac_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"10X Chromium Single Cell ATAC Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Google Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xcrispr_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"10X Chromium Single Cell CRISPR Screening Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xcrispr_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"10X Chromium Single Cell CRISPR Screening Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xmultiome_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"10X Chromium Single Cell Multiome Processing Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xmultiome_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"10X Chromium Single Cell Multiome Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Google Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xnuclei_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"10X Chromium Nuclei Isolation Processing Workflows with Voyager","text":"Pros: Applicable frozen samples Capture nascent transcripts Sensible tissues multiple nuclei one cell Cons: Lose spatial information expensive less flexible open source technologies","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xnuclei_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"10X Chromium Nuclei Isolation Processing Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/10xnuclei_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"10X Chromium Nuclei Isolation Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/bivariate.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Bivariate spatial statistics","text":"Consider two variables correlated, say Pearson correlation 0.8. observations spatially referenced. locations observations can permuted without affecting Pearson correlation. purpose bivariate spatial statistics indicate correlation value (Pearson correlation), spatial autocorrelation co-patterning. One bivariate methods implemented Voyager cross variogram, shown variogram vignette. vignette demonstrates bivariate spatial statistics, use spatial neighborhood graph, mouse skeletal muscle Visium dataset. load packages used: list bivariate global methods can seen : calling calculate*variate() run*variate(), type (2nd) argument takes either SFEMethod object string matches entry name column data frame returned listSFEMethods(). QC performed another vignette, vignette plot QC metrics. image can added SFE object plotted behind geometries, needs flipped align spots origin top left image bottom left geometries.","code":"library(Voyager) library(SFEData) library(SpatialFeatureExperiment) library(scater) library(scran) library(ggplot2) library(pheatmap) library(scico) theme_set(theme_bw()) listSFEMethods(variate = \"bi\", scope = \"global\") #>                  name                                     description #> 1                 lee                       Lee's bivariate statistic #> 2              lee.mc Lee's bivariate static with permutation testing #> 3            lee.test                                    Lee's L test #> 4     cross_variogram                                 Cross variogram #> 5 cross_variogram_map                             Cross variogram map (sfe <- McKellarMuscleData(\"full\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 4992  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG #>   TTGTTTGTGTAAATTC #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A: if (!file.exists(\"tissue_lowres_5a.jpeg\")) {     download.file(\"https://raw.githubusercontent.com/pachterlab/voyager/main/vignettes/tissue_lowres_5a.jpeg\",                   destfile = \"tissue_lowres_5a.jpeg\") } sfe <- addImg(sfe, imageSource = \"tissue_lowres_5a.jpeg\", sample_id = \"Vis5A\",                image_id = \"lowres\", scale_fct = 1024/22208) sfe_tissue <- sfe[,colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,] sfe_tissue <- logNormCounts(sfe_tissue) colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue)"},{"path":"https://pachterlab.github.io/voyager/articles/bivariate.html","id":"lees-l","dir":"Articles","previous_headings":"","what":"Leeâ€™s L","title":"Bivariate spatial statistics","text":"Leeâ€™s L (Lee2001-tm?) developed relating Moranâ€™s Pearson correlation, defined LX,Y=nâˆ‘=1nâˆ‘j=1nwijâˆ‘=1n[âˆ‘j=1nwij(xjâˆ’xâ€¾)][âˆ‘j=1nwij(yjâˆ’yâ€¾)]âˆ‘=1n(xiâˆ’xâ€¾)2âˆ‘=1n(yiâˆ’yâ€¾)2, L_{X,Y} = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\left[ \\sum_{j=1}^n w_{ij}  (x_j - \\bar{x}) \\right] \\left[ \\sum_{j=1}^n w_{ij} (y_j - \\bar{y}) \\right]}{\\sqrt{\\sum_{=1}^n (x_i - \\bar{x})^2}\\sqrt{\\sum_{=1}^n (y_i - \\bar{y})^2} }, nn number spots locations, ii jj different locations, spots Visium context, xx yy variables values location, wijw_{ij} spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood. compute Leeâ€™s L top highly variagle genes (HVGs) dataset: bivariate global results can different formats (matrix Leeâ€™s L lists many methods), results stored SFE object. gives spatially informed correlation matrix among genes, can plotted heatmap:  coexpression blocks can seen. Note unlike Pearson correlation, diagonal 1, LX,X=âˆ‘(xÌƒâˆ’xâ€¾)2âˆ‘(xiâˆ’xâ€¾)2=SSSX, L_{X,X} = \\frac{\\sum_i (\\tilde x_i - \\bar x)^2}{\\sum_i (x_i - \\bar x)^2} = \\mathrm{SSS}_X, approximated ratio variance spatially lagged xx variance xx. spatial lag introduces smoothing, spatial lag reduced variance, making diagonal less 1. spatial smoothing scalar (SSS), Moranâ€™s approximately Pearson correlation XX spatially lagged XX (XÌƒ\\tilde X) multiplied SSS: â‰ˆSSSXâ‹…ÏX,XÌƒ \\approx \\mathrm{SSS}_X \\cdot \\rho_{X, \\tilde X} Similarly Leeâ€™s L, shown (Lee2001-tm?), LX,Y=SSSXSSSYâ‹…ÏXÌƒ,YÌƒ L_{X, Y} = \\sqrt{\\mathrm{SSS}_X}\\sqrt{\\mathrm{SSS}_Y} \\cdot \\rho_{\\tilde X, \\tilde Y} spatial clustering, variance less reduced spatial lag, leading larger SSS. Hence XX YY spatially distributed like salt pepper strongly correlated, Leeâ€™s L low lack spatial autocorrelation leads small SSS. Weighted correlation network analysis (WGCNA) (Langfelder2008-fs?) time honored method find gene co-expression modules, can take correlation matrix. interesting apply WGCNA Leeâ€™s L matrix identify spatially informed gene co-expression modules.","code":"hvgs <- getTopHVGs(sfe_tissue, fdr.threshold = 0.01) res <- calculateBivariate(sfe_tissue, type = \"lee\", feature1 = hvgs) #> Warning: `listw2sparse()` was deprecated in SpatialFeatureExperiment 1.9.0. #> â„¹ Please use `spatialreg::as_dgRMatrix_listw()` instead. #> â„¹ The deprecated feature was likely used in the Voyager package. #>   Please report the issue at <https://github.com/pachterlab/voyager/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. pal_rng <- getDivergeRange(res) pal <- scico(256, begin = pal_rng[1], end = pal_rng[2], palette = \"vik\") pheatmap(res, color = pal, show_rownames = FALSE,           show_colnames = FALSE, cellwidth = 1, cellheight = 1)"},{"path":"https://pachterlab.github.io/voyager/articles/bivariate.html","id":"local-lee","dir":"Articles","previous_headings":"","what":"Local Lee","title":"Bivariate spatial statistics","text":"Local Leeâ€™s L (Lee2001-tm?) defined Li=n[âˆ‘j=1nwij(xjâˆ’xâ€¾)][âˆ‘j=1nwij(yjâˆ’yâ€¾)]âˆ‘=1n(xiâˆ’xâ€¾)2âˆ‘=1n(yiâˆ’yâ€¾)2 L_i = \\frac{n\\left[ \\sum_{j=1}^n w_{ij}  (x_j - \\bar{x}) \\right] \\left[ \\sum_{j=1}^n w_{ij} (y_j - \\bar{y}) \\right]}{\\sqrt{\\sum_{=1}^n (x_i - \\bar{x})^2}\\sqrt{\\sum_{=1}^n (y_i - \\bar{y})^2} } Compare global L previous section. Local L sum locations ii. contribution location global L can show spatial heterogeneity relationship two variables. bivariate local methods Voyager listed : compute local L two myofiber marker genes one gene highly expressed injury site: Bivariate local results stored localResults field feature names pairwise combinations features supplied. feature1 specified, bivariate method applied pairwise combinations feature1. Leeâ€™s L, LX,YL_{X,Y} LY,XL_{Y,X} computed although . However, bivariate methods symmetric (see next section). next release (Bioconductor 3.18), may introduce another argument indicate whether method symmetric compute LX,YL_{X,Y} LY,XL_{Y,X}. First plot three genes individually:  plot local Lâ€™s:  see regions Myh1 Myh2 co-expressed, myosins Ftl1 negatively correlated. LX,XL_{X,X} also computed, can plot local SSS three genes:  See local SSS compares local Moranâ€™s :  patterns qualitatively , local Moranâ€™s negative heterogeneous regions, SSS canâ€™t negative.","code":"listSFEMethods(\"bi\", \"local\") #>            name                     description #> 1      locallee Local Lee's bivariate statistic #> 2 localmoran_bv       Local bivariate Moran's I sfe_tissue <- runBivariate(sfe_tissue, \"locallee\", swap_rownames = \"symbol\",                            feature1 = c(\"Myh2\", \"Myh1\", \"Ftl1\")) localResultFeatures(sfe_tissue, \"locallee\") #> [1] \"Myh2__Myh2\" \"Myh1__Myh2\" \"Ftl1__Myh2\" \"Myh2__Myh1\" \"Myh1__Myh1\" #> [6] \"Ftl1__Myh1\" \"Myh2__Ftl1\" \"Myh1__Ftl1\" \"Ftl1__Ftl1\" plotSpatialFeature(sfe_tissue, c(\"Myh2\", \"Myh1\", \"Ftl1\"),                     swap_rownames = \"symbol\", image_id = \"lowres\", maxcell = 5e4) plotLocalResult(sfe_tissue, \"locallee\", c(\"Myh1__Myh2\", \"Myh2__Ftl1\", \"Myh1__Ftl1\"),                 colGeometryName = \"spotPoly\",                 image_id = \"lowres\", maxcell = 5e4,                 divergent = TRUE, diverge_center = 0) plotLocalResult(sfe_tissue, \"locallee\", c(\"Myh1__Myh1\", \"Myh2__Myh2\", \"Ftl1__Ftl1\"),                 colGeometryName = \"spotPoly\",                 image_id = \"lowres\", maxcell = 5e4) sfe_tissue <- runUnivariate(sfe_tissue, \"localmoran\", c(\"Myh2\", \"Myh1\", \"Ftl1\"),                             swap_rownames = \"symbol\") plotLocalResult(sfe_tissue, \"localmoran\", c(\"Myh1\", \"Myh2\", \"Ftl1\"),                 colGeometryName = \"spotPoly\", swap_rownames = \"symbol\",                 image_id = \"lowres\", maxcell = 5e4,                 divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/bivariate.html","id":"bivariate-local-moran","dir":"Articles","previous_headings":"","what":"Bivariate local Moran","title":"Bivariate spatial statistics","text":"spdep package implements bivariate version local Moran, basically IXi,Yi=(nâˆ’1)(xiâˆ’xâ€¾)âˆ‘j=1nwij(yjâˆ’yâ€¾)âˆ‘=1n(xiâˆ’xâ€¾)2âˆ‘=1n(yiâˆ’yâ€¾)2. I_{X_i,Y_i} = (n-1)\\frac{(x_i - \\bar{x})\\sum_{j=1}^n w_{ij} (y_j - \\bar{y})}{\\sqrt{\\sum_{=1}^n (x_i - \\bar{x})^2} \\sqrt{\\sum_{=1}^n (y_i - \\bar{y})^2}}. Note symmetric, .e.Â IXi,Yiâ‰ IYi,XiI_{X_i,Y_i} \\neq I_{Y_i,X_i}. Permutation testing performed get pseudo p-value First plot bivariate local Moranâ€™s values  first row plots XY second row plots YX; note similar, . bivariate local Moran mean? â€™s kind like contribution location correlation xx spatially lagged yy, xx smoothed. contrast, Leeâ€™s L scaled Pearson correlation spatially lagged xx spatially lagged yy. permutation testing performed, can plot pseudo-p-value, correcting multiple testing based spatial neighborhood graph:  Note p-values asymetric, according source code localmoran_bv(), yy permuted, xx. â€™s also related Wartenbergâ€™s spatial PCA (Wartenberg1985-fk?), Moranâ€™s expressed matrix form: ðˆ=ð™Tð–ð™ðŸTð–ðŸ, \\mathbf{} = \\frac{\\mathbf{Z}^T\\mathbf{WZ}}{\\mathbf 1^T \\mathbf{W1}}, ð™\\mathbf Z data matrix scaled centered variables columns, ð–\\mathbf W spatial weights matrix, ðŸ\\mathbf 1 vector 1â€™s, denominator effect âˆ‘=1nâˆ‘j=1nwij\\sum_{=1}^n \\sum_{j=1}^n w_{ij}. diagonal entries Moranâ€™s â€™s variables, diagonal entries global versions computed sum bivariate local Moranâ€™s â€™s divide sum spatial weights. ð–\\mathbf W doesnâ€™t symmetric, matrix may symmetric. Wartenberg diagonalized matrix place covariance matrix spatial PCA. using scaled centered data row normalized spatial weights matrix, MULTISPATI PCA equivalent Wartenbergâ€™s approach (Dray2008-en?). Lee considered asymmetry inadequacy Wartenbergâ€™s approach bivariate association measure (Lee2001-tm?). â€™m sure bivariate local Moranâ€™s helps data analysis, interesting piece history.","code":"sfe_tissue <- runBivariate(sfe_tissue, \"localmoran_bv\", c(\"Myh1\", \"Myh2\", \"Ftl1\"),                            swap_rownames = \"symbol\", nsim = 1000) localResultFeatures(sfe_tissue, \"localmoran_bv\") #> [1] \"Myh1__Myh1\" \"Myh2__Myh1\" \"Ftl1__Myh1\" \"Myh1__Myh2\" \"Myh2__Myh2\" #> [6] \"Ftl1__Myh2\" \"Myh1__Ftl1\" \"Myh2__Ftl1\" \"Ftl1__Ftl1\" localResultAttrs(sfe_tissue, \"localmoran_bv\", \"Myh1__Myh2\") #> [1] \"Ibvi\"                 \"E.Ibvi\"               \"Var.Ibvi\"             #> [4] \"Z.Ibvi\"               \"Pr(z != E(Ibvi))\"     \"Pr(z != E(Ibvi)) Sim\" #> [7] \"Pr(folded) Sim\"       \"-log10p Sim\"          \"-log10p_adj Sim\" plotLocalResult(sfe_tissue, \"localmoran_bv\", c(\"Myh1__Myh2\", \"Myh2__Ftl1\", \"Myh1__Ftl1\",                                                \"Myh2__Myh1\", \"Ftl1__Myh2\", \"Ftl1__Myh1\"),                 colGeometryName = \"spotPoly\", attribute = \"Ibvi\",                 image_id = \"lowres\", maxcell = 5e4,                 divergent = TRUE, diverge_center = 0) plotLocalResult(sfe_tissue, \"localmoran_bv\", c(\"Myh1__Myh2\", \"Myh2__Ftl1\", \"Myh1__Ftl1\",                                                \"Myh2__Myh1\", \"Ftl1__Myh2\", \"Ftl1__Myh1\"),                 colGeometryName = \"spotPoly\", attribute = \"-log10p_adj Sim\",                 image_id = \"lowres\", maxcell = 5e4,                 divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/bivariate.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Bivariate spatial statistics","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] scico_1.5.0                    pheatmap_1.0.12                #>  [3] scran_1.34.0                   scater_1.34.0                  #>  [5] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [7] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #>  [9] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [11] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [13] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [15] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [17] SFEData_1.8.0                  Voyager_1.8.1                  #> [19] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] sf_1.0-19                 edgeR_4.4.0               #>   [9] lattice_0.22-6            MASS_7.3-61               #>  [11] magrittr_2.0.3            limma_3.62.1              #>  [13] sass_0.4.9                rmarkdown_2.29            #>  [15] jquerylib_0.1.4           yaml_2.3.10               #>  [17] metapod_1.14.0            sp_2.1-4                  #>  [19] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] purrr_1.0.2               R.utils_2.12.3            #>  [27] RCurl_1.98-1.16           TH.data_1.1-2             #>  [29] rappdirs_0.3.3            sandwich_3.1-1            #>  [31] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [33] irlba_2.3.5.1             terra_1.7-83              #>  [35] units_0.8-5               RSpectra_0.16-2           #>  [37] dqrng_0.4.1               pkgdown_2.1.1             #>  [39] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [41] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [43] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [45] memuse_4.2-3              farver_2.1.2              #>  [47] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [49] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [51] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [53] survival_3.7-0            systemfonts_1.1.0         #>  [55] dbscan_1.2-0              tools_4.4.2               #>  [57] ggnewscale_0.5.0          ragg_1.3.3                #>  [59] Rcpp_1.0.13-1             glue_1.8.0                #>  [61] gridExtra_2.3             SparseArray_1.6.0         #>  [63] xfun_0.49                 EBImage_4.48.0            #>  [65] dplyr_1.1.4               HDF5Array_1.34.0          #>  [67] withr_3.0.2               BiocManager_1.30.25       #>  [69] fastmap_1.2.0             boot_1.3-31               #>  [71] rhdf5filters_1.18.0       bluster_1.16.0            #>  [73] fansi_1.0.6               spData_2.3.3              #>  [75] digest_0.6.37             rsvd_1.0.5                #>  [77] mime_0.12                 R6_2.5.1                  #>  [79] textshaping_0.4.0         colorspace_2.1-1          #>  [81] wk_0.9.4                  LearnBayes_2.15.1         #>  [83] jpeg_0.1-10               RSQLite_2.3.8             #>  [85] R.methodsS3_1.8.2         utf8_1.2.4                #>  [87] generics_0.1.3            data.table_1.16.2         #>  [89] class_7.3-22              httr_1.4.7                #>  [91] htmlwidgets_1.6.4         S4Arrays_1.6.0            #>  [93] spdep_1.3-6               pkgconfig_2.0.3           #>  [95] gtable_0.3.6              blob_1.2.4                #>  [97] XVector_0.46.0            htmltools_0.5.8.1         #>  [99] fftwtools_0.9-11          scales_1.3.0              #> [101] png_0.1-8                 SpatialExperiment_1.16.0  #> [103] knitr_1.49                rjson_0.2.23              #> [105] coda_0.19-4.1             nlme_3.1-166              #> [107] curl_6.0.1                proxy_0.4-27              #> [109] cachem_1.1.0              zoo_1.8-12                #> [111] rhdf5_2.50.0              BiocVersion_3.20.0        #> [113] KernSmooth_2.23-24        vipor_0.4.7               #> [115] parallel_4.4.2            AnnotationDbi_1.68.0      #> [117] desc_1.4.3                s2_1.1.7                  #> [119] pillar_1.9.0              grid_4.4.2                #> [121] vctrs_0.6.5               BiocSingular_1.22.0       #> [123] dbplyr_2.5.0              beachmat_2.22.0           #> [125] sfheaders_0.4.4           cluster_2.1.6             #> [127] beeswarm_0.4.0            evaluate_1.0.1            #> [129] zeallot_0.1.0             magick_2.8.5              #> [131] mvtnorm_1.3-2             cli_3.6.3                 #> [133] locfit_1.5-9.10           compiler_4.4.2            #> [135] rlang_1.1.4               crayon_1.5.3              #> [137] labeling_0.4.3            classInt_0.4-10           #> [139] ggbeeswarm_0.7.2          fs_1.6.5                  #> [141] viridisLite_0.4.2         deldir_2.0-4              #> [143] BiocParallel_1.40.0       munsell_0.5.1             #> [145] Biostrings_2.74.0         tiff_0.1-12               #> [147] Matrix_1.7-1              ExperimentHub_2.14.0      #> [149] patchwork_1.3.0           sparseMatrixStats_1.18.0  #> [151] bit64_4.5.2               Rhdf5lib_1.28.0           #> [153] KEGGREST_1.46.0           statmod_1.5.0             #> [155] AnnotationHub_3.14.0      igraph_2.1.1              #> [157] memoise_2.0.1             bslib_0.8.0               #> [159] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/chromium_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"10X Chromium Single Cell 3â€™ v3 Processing Workflows with Voyager","text":"Pros: Widely used, tested many cell types tissues Many existing datasets, including many 10X website High throughput, applied atlases millions cells Cons: Lose spatial information expensive open source technologies Less flexible tissues skeletal muscles challenging dissociate","code":""},{"path":"https://pachterlab.github.io/voyager/articles/chromium_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"10X Chromium Single Cell 3â€™ v3 Processing Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/chromium_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"10X Chromium Single Cell 3â€™ v3 Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/codex_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"PhenoCycler Processing Workflows with Voyager","text":"Pros: Commercial kit Single cell resolution Formalin fixed, paraffin embedded (FFPE) tissue compatible Cons: Requires panels proteins usually dozens antibodies, standard highly multiplexed immunofluorescence. Akoya sells curated panels.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/codex_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"PhenoCycler Processing Workflows with Voyager","text":"Several CODEX datasets generated HuBMAP Consortium available download data portal. Raw processed data typically avaiable several fields view can readily combined single SpatialFeatureExperiment(SFE) object. tutorial processing output various spatial transcriptomics technologies SFE object use Voyager available vignette linked .","code":""},{"path":"https://pachterlab.github.io/voyager/articles/codex_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"PhenoCycler Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using data generated CODEX technology.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/cosmx_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"CosMX Processing Workflows with Voyager","text":"Pros: Commercial kit Single cell resolution High detection efficiency Formalin fixed, paraffin embedded (FFPE) tissue compatible Provides subcellular transcript localization information Compatible histological staining including DAPI 100 proteins can quantified CosMX along side RNAs Cons: curated panel usually hundred genes required. However, Nanostring provides curated gene panels common applications oncology, neuroscience, immunology, well panel design services. Data size harder manage larger tissue areas number samples. spatial analysis methods can scale hundreds thousands millions cells.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/cosmx_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"CosMX Processing Workflows with Voyager","text":"Nanostring released CosMX FFPE dataset website. tutorial processing output various spatial transcriptomics technologies, including CosMX, SpatialFeatureExperiment(SFE) object use Voyager available . vignette provides technology specific notes data downloaded Nanostring. Nanostring provides cell segmentation data images, cell centroid coordinates provided metadata.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/cosmx_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"CosMX Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using data generated CosMX SMI. publicly available CosMX dataset profiles 960 genes across 8 non-small-cell lung cancer (NSCLC) samples.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"visium-space-ranger-output","dir":"Articles","previous_headings":"","what":"Visium Space Ranger output","title":"Create a SpatialFeatureExperiment object","text":"10x Genomics Space Ranger output Visium experiment can read similar manner SpatialExperiment; SpatialFeatureExperiment SFE object spotPoly column geometry spot polygons. filtered matrix (.e.Â spots tissue) read , column graph called visium also present spatial neighborhood graph Visium spots tissue. graph computed spots read regardless whether tissue. results tissue capture outs directory. Inside outs directory two directories: raw_reature_bc_matrix unfiltered gene count matrix, spatial spatial information. DropletUtils package function read10xCounts() reads gene count matrix. SPE reads spatial information, SFE uses spatial information construct Visium spot polygons spatial neighborhood graphs. Inside spatial directory: tissue_lowres_image.png low resolution image tissue. Inside scalefactors_json.json file: spot_diameter_fullres diameter Visium spot full resolution H&E image pixels. tissue_hires_scalef tissue_lowres_scalef ratio size high resolution (full resolution) low resolution H&E image full resolution image. fiducial_diameter_fullres diameter fiducial spot used align spots H&E image pixels full resolution image. tissue_positions_list.csv file contains information spatial coordinates spots whether spot tissue automatically detected Space Ranger manually annotated Loupe browser. polygon tissue boundary available, whether image processing manual annotation, geometric operations supported SFE package, based sf package, can used find spots intersect tissue spots contained tissue. Geometric operations can also find polygons intersections spots tissue, results can get messy since intersections can polygons also points lines. Now read toy data Space Ranger output format. Since Bioconductor version release (Voyager version 1.2.0), image read SpatRaster object terra package, loaded memory unless necessary. plotting large image, downsampled thus fully loaded memory. unit can set unit argument, can either pixels full resolution image microns. latter calculated former based spacing spots, known 100 microns. Space Ranger output includes gene count matrix, spot coordinates, spot diameter. Space Ranger output include nuclei segmentation pathologist annotation histological regions. Extra image processing, ImageJ QuPath, required geometries.","code":"dir <- system.file(\"extdata\", package = \"SpatialFeatureExperiment\") sample_ids <- c(\"sample01\", \"sample02\") (samples <- file.path(dir, sample_ids, \"outs\")) #> [1] \"/home/runner/work/_temp/Library/SpatialFeatureExperiment/extdata/sample01/outs\" #> [2] \"/home/runner/work/_temp/Library/SpatialFeatureExperiment/extdata/sample02/outs\" list.files(samples[1]) #> [1] \"filtered_feature_bc_matrix\" \"spatial\" list.files(file.path(samples[1], \"spatial\")) #> [1] \"aligned_fiducials.jpg\"              \"barcode_fluorescence_intensity.csv\" #> [3] \"detected_tissue_image.jpg\"          \"scalefactors_json.json\"             #> [5] \"spatial_enrichment.csv\"             \"tissue_hires_image.png\"             #> [7] \"tissue_lowres_image.png\"            \"tissue_positions.csv\" fromJSON(file = file.path(samples[1], \"spatial\", \"scalefactors_json.json\")) #> $tissue_hires_scalef #> [1] 0.0751202 #>  #> $tissue_lowres_scalef #> [1] 0.02253606 #>  #> $fiducial_diameter_fullres #> [1] 304.6116 #>  #> $spot_diameter_fullres #> [1] 188.5691 (sfe3 <- read10xVisiumSFE(samples, dirs = samples, sample_id = sample_ids,                            type = \"sparse\", data = \"filtered\", images = \"lowres\",                            unit = \"full_res_image_pixel\")) #> >>> 10X Visium data will be loaded: outs #> >>> Adding spatial neighborhood graph to sample01 #> >>> 10X Visium data will be loaded: outs #> >>> Adding spatial neighborhood graph to sample02 #> class: SpatialFeatureExperiment  #> dim: 5 25  #> metadata(0): #> assays(1): counts #> rownames(5): ENSG00000014257 ENSG00000142515 ENSG00000263639 #>   ENSG00000163810 ENSG00000149591 #> rowData names(14): symbol Feature.Type ... #>   Median.Normalized.Average.Counts_sample02 #>   Barcodes.Detected.per.Feature_sample02 #> colnames(25): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   TGCAATTTGGGCACGG-1 ATGCCAATCGCTCTGC-1 #> colData names(10): in_tissue array_row ... channel3_mean channel3_stdev #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01: col: visium #> sample02: col: visium"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"vizgen-merfish-output","dir":"Articles","previous_headings":"","what":"Vizgen MERFISH output","title":"Create a SpatialFeatureExperiment object","text":"commercialized MERFISH Vizgen standard output format, can read SFE readVizgen(). cell segmentation field view (FOV) separate HDF5 file MERFISH dataset can hundreds FOVs, strongly recommend reading MERFISH output server large number CPU cores. Alternatively, MERFISH datasets store cell segmentation parquet file, can easily read R. requires installation arrow. read toy dataset first FOV real dataset: optional add_molecules argument can set TRUE read transcript spots unit always microns. make easier faster read data next time, processed cell segmentation geometries transcript spots written directory data resides:","code":"fp <- tempdir() dir_use <- VizgenOutput(file_path = file.path(fp, \"vizgen\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> The downloaded files are in /tmp/Rtmp9WtqLm/vizgen/vizgen_cellbound list.files(dir_use) #> [1] \"cell_boundaries\"          \"cell_boundaries.parquet\"  #> [3] \"cell_by_gene.csv\"         \"cell_metadata.csv\"        #> [5] \"detected_transcripts.csv\" \"images\" (sfe_mer <- readVizgen(dir_use, z = 3L, image = \"PolyT\", add_molecules = TRUE)) #> >>> 1 `.parquet` files exist: #> /tmp/Rtmp9WtqLm/vizgen/vizgen_cellbound/cell_boundaries.parquet #> >>> using -> /tmp/Rtmp9WtqLm/vizgen/vizgen_cellbound/cell_boundaries.parquet #> >>> Cell segmentations are found in `.parquet` file #> >>> Checking polygon validity #> >>> Reading transcript coordinates #> >>> Converting transcript spots to geometry #> >>> Writing reformatted transcript spots to disk #> class: SpatialFeatureExperiment  #> dim: 88 1058  #> metadata(0): #> assays(1): counts #> rownames(88): CD4 TLL1 ... Blank-38 Blank-39 #> rowData names(0): #> colnames(1058): 112824700230101249 112824700230101252 ... #>   112824700330100920 112824700330100974 #> colData names(11): fov volume ... solidity sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #> rowGeometries: txSpots (MULTIPOINT)  #>  #> Graphs: #> sample01: list.files(dir_use) #> [1] \"cell_boundaries\"              \"cell_boundaries.parquet\"      #> [3] \"cell_by_gene.csv\"             \"cell_metadata.csv\"            #> [5] \"detected_transcripts.csv\"     \"detected_transcripts.parquet\" #> [7] \"images\""},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"x-xenium-output","dir":"Articles","previous_headings":"","what":"10X Xenium output","title":"Create a SpatialFeatureExperiment object","text":"SFE supports reading output Xenium Onboarding Analysis (XOA) v1 v2 function readXenium(). Especially XOA v2, arrow strongly recommended. cell nuclei polygon vertices transcript spot coordinates parquet files Similar readVizgen(), readXenium() makes sf data frames vertices transcript spots saves GeoParquet files.","code":"dir_use <- XeniumOutput(\"v2\", file_path = file.path(fp, \"xenium\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> The downloaded files are in /tmp/Rtmp9WtqLm/xenium/xenium2 list.files(dir_use) #>  [1] \"cell_boundaries.csv.gz\"     \"cell_boundaries.parquet\"    #>  [3] \"cell_feature_matrix.h5\"     \"cells.csv.gz\"               #>  [5] \"cells.parquet\"              \"experiment.xenium\"          #>  [7] \"morphology_focus\"           \"nucleus_boundaries.csv.gz\"  #>  [9] \"nucleus_boundaries.parquet\" \"transcripts.csv.gz\"         #> [11] \"transcripts.parquet\" # RBioFormats issue: https://github.com/aoles/RBioFormats/issues/42 try(sfe_xen <- readXenium(dir_use, add_molecules = TRUE)) #> >>> Must use gene symbols as row names when adding transcript spots. #> >>> Cell segmentations are found in `.parquet` file(s) #> >>> Reading cell and nucleus segmentations #> >>> Making MULTIPOLYGON nuclei geometries #> >>> Making POLYGON cell geometries #> Sanity checks on cell segmentation polygons: #> >>> ..found 132 cells with (nested) polygon lists #> >>> ..applying filtering #> >>> Checking polygon validity #> >>> Saving geometries to parquet files #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 #> >>> Reading transcript coordinates #> >>> Converting transcript spots to geometry #> >>> Writing reformatted transcript spots to disk #> >>> Total of 116 features/genes with no transcript detected or `min_phred` < 20 are removed from SFE object #> >>> To keep all features -> set `min_phred = NULL` (sfe_xen <- readXenium(dir_use, add_molecules = TRUE)) #> >>> Must use gene symbols as row names when adding transcript spots. #> >>> Preprocessed sf segmentations found #> >>> Reading cell and nucleus segmentations #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 #> >>> Reading transcript coordinates #> >>> Total of 116 features/genes with no transcript detected or `min_phred` < 20 are removed from SFE object #> >>> To keep all features -> set `min_phred = NULL` #> class: SpatialFeatureExperiment  #> dim: 398 6272  #> metadata(1): Samples #> assays(1): counts #> rownames(398): ABCC11 ACE2 ... UnassignedCodeword_0488 #>   UnassignedCodeword_0497 #> rowData names(3): ID Symbol Type #> colnames(6272): abclkehb-1 abcnopgp-1 ... odmgoega-1 odmgojlc-1 #> colData names(9): transcript_counts control_probe_counts ... #>   nucleus_area sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_centroid y_centroid #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON), nucSeg (MULTIPOLYGON)  #> rowGeometries: txSpots (MULTIPOINT)  #>  #> Graphs: #> sample01: list.files(dir_use) #>  [1] \"cell_boundaries_sf.parquet\"    \"cell_boundaries.csv.gz\"        #>  [3] \"cell_boundaries.parquet\"       \"cell_feature_matrix.h5\"        #>  [5] \"cells.csv.gz\"                  \"cells.parquet\"                 #>  [7] \"experiment.xenium\"             \"morphology_focus\"              #>  [9] \"nucleus_boundaries_sf.parquet\" \"nucleus_boundaries.csv.gz\"     #> [11] \"nucleus_boundaries.parquet\"    \"transcripts.csv.gz\"            #> [13] \"transcripts.parquet\"           \"tx_spots.parquet\""},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"nanostring-cosmx-output","dir":"Articles","previous_headings":"","what":"Nanostring CosMX output","title":"Create a SpatialFeatureExperiment object","text":"similar readVizgen() readXenium(), except output doesnâ€™t come images.","code":"dir_use <- CosMXOutput(file_path = file.path(fp, \"cosmx\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> The downloaded files are in /tmp/Rtmp9WtqLm/cosmx/cosmx list.files(dir_use) #> [1] \"Run5642_S3_Quarter_exprMat_file.csv\"  #> [2] \"Run5642_S3_Quarter_metadata_file.csv\" #> [3] \"Run5642_S3_Quarter_tx_file.csv\"       #> [4] \"Run5642_S3_Quarter-polygons.csv\" (sfe_cosmx <- readCosMX(dir_use, add_molecules = TRUE)) #> >>> Constructing cell polygons #> >>> Checking polygon validity #> >>> Reading transcript coordinates #> >>> Converting transcript spots to geometry #> >>> Writing reformatted transcript spots to disk #> class: SpatialFeatureExperiment  #> dim: 960 27  #> metadata(0): #> assays(1): counts #> rownames(960): Chrna4 Slc6a1 ... NegPrb9 NegPrb10 #> rowData names(0): #> colnames(27): 367_1 368_1 ... 581_1 583_1 #> colData names(19): fov cell_ID ... Max.DAPI sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : CenterX_global_px CenterY_global_px #> imgData names(0): #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #> rowGeometries: txSpots (MULTIPOINT)  #>  #> Graphs: #> sample01: list.files(dir_use) #> [1] \"cell_boundaries_sf.parquet\"           #> [2] \"Run5642_S3_Quarter_exprMat_file.csv\"  #> [3] \"Run5642_S3_Quarter_metadata_file.csv\" #> [4] \"Run5642_S3_Quarter_tx_file.csv\"       #> [5] \"Run5642_S3_Quarter-polygons.csv\"      #> [6] \"tx_spots.parquet\""},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"other-technologies","dir":"Articles","previous_headings":"","what":"Other technologies","title":"Create a SpatialFeatureExperiment object","text":"read function Visium HD progress. Contribution Akoya, Molecular Cartography, Curio Seeker welcome. See issues.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"create-sfe-object-from-scratch","dir":"Articles","previous_headings":"","what":"Create SFE object from scratch","title":"Create a SpatialFeatureExperiment object","text":"SFE object can constructed scratch assay matrices metadata. toy example, dgCMatrix used, since SFE inherits SingleCellExperiment (SCE), types arrays supported SCE delayed arrays also work. sufficient create SPE object, SFE object, even though sf data frame constructed geometries. constructor behaves similarly SPE constructor. centroid coordinates Visium spots example can converted spot polygons spotDiameter argument, can also relevant technologies round spots beads, Slide-seq. Spot diameter pixels full resolution images can found scalefactors_json.json file Space Ranger output. geometries spatial graphs can added calling constructor. Geometries can also supplied constructor.","code":"# Visium barcode location from Space Ranger data(\"visium_row_col\") coords1 <- visium_row_col[visium_row_col$col < 6 & visium_row_col$row < 6,] coords1$row <- coords1$row * sqrt(3)  # Random toy sparse matrix set.seed(29) col_inds <- sample(1:13, 13) row_inds <- sample(1:5, 13, replace = TRUE) values <- sample(1:5, 13, replace = TRUE) mat <- sparseMatrix(i = row_inds, j = col_inds, x = values) colnames(mat) <- coords1$barcode rownames(mat) <- sample(LETTERS, 5) sfe3 <- SpatialFeatureExperiment(list(counts = mat), colData = coords1,                                 spatialCoordsNames = c(\"col\", \"row\"),                                 spotDiameter = 0.7) # Convert regular data frame with coordinates to sf data frame cg <- df2sf(coords1[,c(\"col\", \"row\")], c(\"col\", \"row\"), spotDiameter = 0.7) rownames(cg) <- colnames(mat) sfe3 <- SpatialFeatureExperiment(list(counts = mat), colGeometries = list(foo = cg))"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"coercion-from-spatialexperiment","dir":"Articles","previous_headings":"","what":"Coercion from SpatialExperiment","title":"Create a SpatialFeatureExperiment object","text":"SPE objects can coerced SFE objects. column geometries spot diameter specified, column geometry called â€œcentroidsâ€ created. coercion, column names must duplicate. images present SPE object, converted SpatRaster SPE object converted SFE. Plotting functions Voyager package relies SpatRaster plot image behind geometries.","code":"spe <- SpatialExperiment::read10xVisium(samples, sample_ids, type = \"sparse\",                                          data = \"filtered\",                                          images = \"hires\", load = FALSE) colnames(spe) <- make.unique(colnames(spe), sep = \"-\") rownames(spatialCoords(spe)) <- colnames(spe) (sfe3 <- toSpatialFeatureExperiment(spe)) #> class: SpatialFeatureExperiment  #> dim: 5 25  #> metadata(0): #> assays(1): counts #> rownames(5): ENSG00000014257 ENSG00000142515 ENSG00000263639 #>   ENSG00000163810 ENSG00000149591 #> rowData names(1): symbol #> colnames(25): GTGGCGTGCACCAGAG-1 GGTCCCATAACATAGA-1 ... #>   TGCAATTTGGGCACGG-1 ATGCCAATCGCTCTGC-1 #> colData names(4): in_tissue array_row array_col sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01:  #> sample02:"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"coercion-from-seurat","dir":"Articles","previous_headings":"","what":"Coercion from Seurat","title":"Create a SpatialFeatureExperiment object","text":"Seurat objects can coerced SFE objects though coercion SFE Seurat yet implemented.","code":"dir_extdata <- system.file(\"extdata\", package = \"SpatialFeatureExperiment\") obj_vis <- readRDS(file.path(dir_extdata, \"seu_vis_toy.rds\")) sfe_conv_vis <-   toSpatialFeatureExperiment(x = obj_vis,                               image_scalefactors = \"lowres\",                              unit = \"micron\",                              BPPARAM = BPPARAM) sfe_conv_vis"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Create a SpatialFeatureExperiment object","text":"","code":"# Clean up unlink(file.path(fp, \"vizgen\"), recursive = TRUE) unlink(file.path(fp, \"xenium\"), recursive = TRUE) unlink(file.path(fp, \"cosmx\"), recursive = TRUE) sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8          LC_NUMERIC=C              #>  [3] LC_TIME=C.UTF-8           LC_COLLATE=C.UTF-8        #>  [5] LC_MONETARY=C.UTF-8       LC_MESSAGES=C.UTF-8       #>  [7] LC_PAPER=C.UTF-8          LC_NAME=C.UTF-8           #>  [9] LC_ADDRESS=C.UTF-8        LC_TELEPHONE=C.UTF-8      #> [11] LC_MEASUREMENT=C.UTF-8    LC_IDENTIFICATION=C.UTF-8 #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] RBioFormats_1.6.0              SFEData_1.8.0                  #> [3] Matrix_1.7-1                   rjson_0.2.23                   #> [5] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2               bitops_1.0-9                #>   [3] filelock_1.0.3              tibble_3.2.1                #>   [5] R.oo_1.27.0                 lifecycle_1.0.4             #>   [7] sf_1.0-19                   edgeR_4.4.0                 #>   [9] lattice_0.22-6              MASS_7.3-61                 #>  [11] magrittr_2.0.3              limma_3.62.1                #>  [13] sass_0.4.9                  rmarkdown_2.29              #>  [15] jquerylib_0.1.4             yaml_2.3.10                 #>  [17] sp_2.1-4                    DBI_1.2.3                   #>  [19] multcomp_1.4-26             abind_1.4-8                 #>  [21] spatialreg_1.3-5            zlibbioc_1.52.0             #>  [23] GenomicRanges_1.58.0        purrr_1.0.2                 #>  [25] R.utils_2.12.3              BiocGenerics_0.52.0         #>  [27] RCurl_1.98-1.16             TH.data_1.1-2               #>  [29] rappdirs_0.3.3              sandwich_3.1-1              #>  [31] GenomeInfoDbData_1.2.13     IRanges_2.40.0              #>  [33] S4Vectors_0.44.0            terra_1.7-83                #>  [35] units_0.8-5                 RSpectra_0.16-2             #>  [37] dqrng_0.4.1                 pkgdown_2.1.1               #>  [39] DelayedMatrixStats_1.28.0   codetools_0.2-20            #>  [41] DropletUtils_1.26.0         DelayedArray_0.32.0         #>  [43] xml2_1.3.6                  scuttle_1.16.0              #>  [45] tidyselect_1.2.1            UCSC.utils_1.2.0            #>  [47] memuse_4.2-3                farver_2.1.2                #>  [49] matrixStats_1.4.1           stats4_4.4.2                #>  [51] BiocFileCache_2.14.0        jsonlite_1.8.9              #>  [53] BiocNeighbors_2.0.0         e1071_1.7-16                #>  [55] survival_3.7-0              systemfonts_1.1.0           #>  [57] dbscan_1.2-0                tools_4.4.2                 #>  [59] ggnewscale_0.5.0            ragg_1.3.3                  #>  [61] sfarrow_0.4.1               Rcpp_1.0.13-1               #>  [63] glue_1.8.0                  SparseArray_1.6.0           #>  [65] xfun_0.49                   MatrixGenerics_1.18.0       #>  [67] GenomeInfoDb_1.42.0         EBImage_4.48.0              #>  [69] dplyr_1.1.4                 HDF5Array_1.34.0            #>  [71] withr_3.0.2                 BiocManager_1.30.25         #>  [73] fastmap_1.2.0               boot_1.3-31                 #>  [75] rhdf5filters_1.18.0         bluster_1.16.0              #>  [77] fansi_1.0.6                 spData_2.3.3                #>  [79] digest_0.6.37               R6_2.5.1                    #>  [81] mime_0.12                   textshaping_0.4.0           #>  [83] colorspace_2.1-1            wk_0.9.4                    #>  [85] LearnBayes_2.15.1           jpeg_0.1-10                 #>  [87] RSQLite_2.3.8               R.methodsS3_1.8.2           #>  [89] utf8_1.2.4                  generics_0.1.3              #>  [91] data.table_1.16.2           class_7.3-22                #>  [93] httr_1.4.7                  htmlwidgets_1.6.4           #>  [95] S4Arrays_1.6.0              spdep_1.3-6                 #>  [97] pkgconfig_2.0.3             scico_1.5.0                 #>  [99] rJava_1.0-11                gtable_0.3.6                #> [101] blob_1.2.4                  SingleCellExperiment_1.28.1 #> [103] XVector_0.46.0              htmltools_0.5.8.1           #> [105] fftwtools_0.9-11            scales_1.3.0                #> [107] Biobase_2.66.0              png_0.1-8                   #> [109] SpatialExperiment_1.16.0    knitr_1.49                  #> [111] coda_0.19-4.1               nlme_3.1-166                #> [113] curl_6.0.1                  proxy_0.4-27                #> [115] cachem_1.1.0                zoo_1.8-12                  #> [117] rhdf5_2.50.0                BiocVersion_3.20.0          #> [119] KernSmooth_2.23-24          parallel_4.4.2              #> [121] arrow_17.0.0.1              AnnotationDbi_1.68.0        #> [123] desc_1.4.3                  s2_1.1.7                    #> [125] pillar_1.9.0                grid_4.4.2                  #> [127] vctrs_0.6.5                 dbplyr_2.5.0                #> [129] beachmat_2.22.0             sfheaders_0.4.4             #> [131] cluster_2.1.6               evaluate_1.0.1              #> [133] zeallot_0.1.0               magick_2.8.5                #> [135] mvtnorm_1.3-2               cli_3.6.3                   #> [137] locfit_1.5-9.10             compiler_4.4.2              #> [139] rlang_1.1.4                 crayon_1.5.3                #> [141] classInt_0.4-10             fs_1.6.5                    #> [143] deldir_2.0-4                BiocParallel_1.40.0         #> [145] assertthat_0.2.1            munsell_0.5.1               #> [147] Biostrings_2.74.0           tiff_0.1-12                 #> [149] ExperimentHub_2.14.0        patchwork_1.3.0             #> [151] sparseMatrixStats_1.18.0    bit64_4.5.2                 #> [153] ggplot2_3.5.1               Rhdf5lib_1.28.0             #> [155] KEGGREST_1.46.0             statmod_1.5.0               #> [157] SummarizedExperiment_1.36.0 AnnotationHub_3.14.0        #> [159] igraph_2.1.1                memoise_2.0.1               #> [161] bslib_0.8.0                 bit_4.5.0"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe_v2.html","id":"downloading-the-data","dir":"Articles","previous_headings":"","what":"Downloading the data","title":"How to create a SpatialFeatureExperiment object","text":"data used recent publication, High Resolution Slide-seqV2 Spatial Transcriptomics Enables Discovery Disease-Specific Cell Neighborhoods Pathways available download GEO (Accession Number: GSE190094. demonstrate use ffq access FTP links downloading relevant data. download data single WT sample. commented line shows install ffq R terminal. output command metadata GSM5713341. can use curl wget download files FTP links one--one. Files beginning ftp:// can read directly R package vroom. Files uncompressed reading. files automatically downloaded uncompressed. use method , commented lines show download files using curl.","code":"# system(\"pip install ffq\") system(\"ffq -l1 GSM5713341\") # system(\"curl -O ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5713nnn/GSM5713341/suppl/GSM5713341_Puck_191112_04_MappedDGEForR.csv.gz\")  # system(\"curl -O ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5713nnn/GSM5713341/suppl/GSM5713341_Puck_191112_04_BeadLocationsForR.csv.gz\")  # list.files(pattern = \"*.gz\")"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe_v2.html","id":"reading-in-the-data","dir":"Articles","previous_headings":"","what":"Reading in the data","title":"How to create a SpatialFeatureExperiment object","text":"","code":"mtx <- vroom(\"ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5713nnn/GSM5713341/suppl/GSM5713341_Puck_191112_04_MappedDGEForR.csv.gz\")  centroids <- vroom(\"ftp://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5713nnn/GSM5713341/suppl/GSM5713341_Puck_191112_04_BeadLocationsForR.csv.gz\")"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe_v2.html","id":"construct-a-sfe-object","dir":"Articles","previous_headings":"","what":"Construct a SFE object","title":"How to create a SpatialFeatureExperiment object","text":"count matrix bead locations provided authors. pass constructor SpatialFeatureExperiment object. files read data frames. convert gene count matrix matrix sparse dgCMatrix. , spot locations provided CSV file. two columns particular interest, namely xcoord ycoord. barcode column corresponds barcodes count matrix. calling SpatialFeatureExperiment constructor, spatial coordinates must converted sf data frame using df2sf(). coordinates centroid positions, indicate geometryType=\"POINT\". Now ingredients create SFE object. values assays colGeometries arguments must passed list shown .","code":"# Note: if using Google Colab, this step might run out of RAM # If this happens, please upgrade to Colab Pro  rn <- mtx$Row mtx <- as.matrix(mtx[,-1])  rownames(mtx) <- rn mtx <- as(mtx, \"dgCMatrix\") colnames(centroids)[1] <- \"ID\"  centroids <- df2sf(   centroids, geometryType = \"POINT\",   spatialCoordsNames=c(\"xcoord\",\"ycoord\")) sfe <- SpatialFeatureExperiment(   assays = list(counts = mtx),   colGeometries = list(centroids = centroids) )  sfe"},{"path":"https://pachterlab.github.io/voyager/articles/create_sfe_v2.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"How to create a SpatialFeatureExperiment object","text":"","code":"sessionInfo()"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/localc.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Multivariate local Geary's C","text":"Local Gearyâ€™s C (Anselin1995-cs?) defined : ci=âˆ‘jwij(xiâˆ’xj)2, c_i = \\sum_jw_{ij}(x_i - x_j)^2, wijw_{ij}s spatial weights location ii location jj xx variable spatial location. generalized multiple variables (Anselin2019-uv?): ck,=âˆ‘v=1kcv,, c_{k,} = \\sum_{v=1}^k c_{v,}, kk variables. essentially spatially weighted sum squared distances locations feature space. vignette demonstrates usage multivariate local Gearyâ€™s C. load packages used: QC performed another vignette, vignette plot QC metrics. image can added SFE object plotted behind geometries, needs flipped align spots origin top left image bottom left geometries.","code":"library(Voyager) library(SFEData) library(SpatialFeatureExperiment) library(scater) library(scran) library(ggplot2) library(spdep) theme_set(theme_bw()) (sfe <- McKellarMuscleData(\"full\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 4992  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG #>   TTGTTTGTGTAAATTC #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A: if (!file.exists(\"tissue_lowres_5a.jpeg\")) {     download.file(\"https://raw.githubusercontent.com/pachterlab/voyager/main/vignettes/tissue_lowres_5a.jpeg\",                   destfile = \"tissue_lowres_5a.jpeg\") } sfe <- addImg(sfe, imageSource = \"tissue_lowres_5a.jpeg\", sample_id = \"Vis5A\",                image_id = \"lowres\",                scale_fct = 1024/22208) sfe_tissue <- sfe[,colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,] sfe_tissue <- logNormCounts(sfe_tissue) colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue)"},{"path":"https://pachterlab.github.io/voyager/articles/localc.html","id":"gene-expression","dir":"Articles","previous_headings":"","what":"Gene expression","title":"Multivariate local Geary's C","text":"compute multivariate local C top highly variagle genes (HVGs) dataset: results stored reducedDim although â€™s really dimension reduction. can also go colData dest = \"colData\". test two sided, alternative argument can set â€œgreaterâ€ test positive spatial autocorrelation â€œlessâ€ negative spatial autocorrelation.  Gearyâ€™s C, value 1 indicates positive spatial autocorrelation value 1 indicates negative spatial autocorrelation. Local Gearyâ€™s C scaled, square difference expression, low value means homogeneous neighborhood high value means heterogeneous neighborhood. considering 341 top HVGs, muscle tendon junction unjury site heterogeneous, detected negative cluster. Permutation testing performed, although Anselin noted pseudo-p-values taken indicative interesting regions interpreted strict sense.  Warm colors indicate adjusted p < 0.05. interpreted along clusters. dataset, interestingly homogeneous regions myofibers, interestingly heterogeneous region injury site. significant regions positive cluster, center injury site significant negative cluster.","code":"hvgs <- getTopHVGs(sfe_tissue, fdr.threshold = 0.01) sfe_tissue <- runMultivariate(sfe_tissue, \"localC_perm_multi\", subset_row = hvgs) names(reducedDim(sfe_tissue, \"localC_perm_multi\")) #>  [1] \"localC_perm_multi\"  \"E.Ci\"               \"Var.Ci\"             #>  [4] \"Z.Ci\"               \"Pr(z != E(Ci))\"     \"Pr(z != E(Ci)) Sim\" #>  [7] \"Pr(folded) Sim\"     \"Skewness\"           \"Kurtosis\"           #> [10] \"-log10p Sim\"        \"-log10p_adj Sim\"    \"cluster\" spatialReducedDim(sfe_tissue, \"localC_perm_multi\", c(1, 12),                   image_id = \"lowres\", maxcell = 5e4) spatialReducedDim(sfe_tissue, \"localC_perm_multi\", c(11, 12),                   image_id = \"lowres\", maxcell = 5e4,                    divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/localc.html","id":"top-principal-components","dir":"Articles","previous_headings":"","what":"Top principal components","title":"Multivariate local Geary's C","text":"multivariate local Gearyâ€™s C spatially weighted sum squared distances locations feature space, â€™s affected curse dimensionality used large number features, uniformly distributed data points higher dimensions become equidistant increasing number dimensions. However, real data uniformly distributed can much smaller effective dimension number features, many genes co-regulated. Anselin suggested using main principal components, issue curse dimensionality remains investigated. Furthermore, cosine Manhattan distances suggested mitigate curse dimensionality, wonder use instead Euclidean distance feature space multivariate local Gearyâ€™s C. perform multivariate local Gearyâ€™s C top PCs:  percentage variance explained top 20 PCs?   area seem significant permutation test larger HVGs, area considered negative clusters smaller. significant regions pretty much positive cluster. differences results anything curse dimensionality? Twenty dimensions can still exhibit curse dimensionality, 300 HVGs worse. lose lot information, including negative spatial autocorrelation, using 20 PCs?","code":"sfe_tissue <- runPCA(sfe_tissue, ncomponents = 20, scale = TRUE) ElbowPlot(sfe_tissue) sum(attr(reducedDim(sfe_tissue, \"PCA\"), \"percentVar\")) #> [1] 38.8627 out <- localC_perm(reducedDim(sfe_tissue, \"PCA\"),                     listw = colGraph(sfe_tissue, \"visium\")) out <- Voyager:::.localCpermmulti2df(out,                                       nb = colGraph(sfe_tissue, \"visium\")$neighbours,                                      p.adjust.method = \"BH\") reducedDim(sfe_tissue, \"localC_PCs\", withDimnames = FALSE) <- out spatialReducedDim(sfe_tissue, \"localC_PCs\", c(1, 12),                   image_id = \"lowres\", maxcell = 5e4) spatialReducedDim(sfe_tissue, \"localC_PCs\", c(11, 12),                   image_id = \"lowres\", maxcell = 5e4,                    divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/localc.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multivariate local Geary's C","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] spdep_1.3-6                    sf_1.0-19                      #>  [3] spData_2.3.3                   scran_1.34.0                   #>  [5] scater_1.34.0                  ggplot2_3.5.1                  #>  [7] scuttle_1.16.0                 SingleCellExperiment_1.28.1    #>  [9] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [11] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [13] IRanges_2.40.0                 S4Vectors_0.44.0               #> [15] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [17] matrixStats_1.4.1              SFEData_1.8.0                  #> [19] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] edgeR_4.4.0               lattice_0.22-6            #>   [9] MASS_7.3-61               magrittr_2.0.3            #>  [11] limma_3.62.1              sass_0.4.9                #>  [13] rmarkdown_2.29            jquerylib_0.1.4           #>  [15] yaml_2.3.10               metapod_1.14.0            #>  [17] sp_2.1-4                  RColorBrewer_1.1-3        #>  [19] DBI_1.2.3                 multcomp_1.4-26           #>  [21] abind_1.4-8               spatialreg_1.3-5          #>  [23] zlibbioc_1.52.0           purrr_1.0.2               #>  [25] R.utils_2.12.3            RCurl_1.98-1.16           #>  [27] TH.data_1.1-2             rappdirs_0.3.3            #>  [29] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [31] ggrepel_0.9.6             irlba_2.3.5.1             #>  [33] terra_1.7-83              units_0.8-5               #>  [35] RSpectra_0.16-2           dqrng_0.4.1               #>  [37] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [39] codetools_0.2-20          DropletUtils_1.26.0       #>  [41] DelayedArray_0.32.0       tidyselect_1.2.1          #>  [43] UCSC.utils_1.2.0          memuse_4.2-3              #>  [45] farver_2.1.2              viridis_0.6.5             #>  [47] ScaledMatrix_1.14.0       BiocFileCache_2.14.0      #>  [49] jsonlite_1.8.9            BiocNeighbors_2.0.0       #>  [51] e1071_1.7-16              survival_3.7-0            #>  [53] systemfonts_1.1.0         dbscan_1.2-0              #>  [55] tools_4.4.2               ggnewscale_0.5.0          #>  [57] ragg_1.3.3                Rcpp_1.0.13-1             #>  [59] glue_1.8.0                gridExtra_2.3             #>  [61] SparseArray_1.6.0         xfun_0.49                 #>  [63] EBImage_4.48.0            dplyr_1.1.4               #>  [65] HDF5Array_1.34.0          withr_3.0.2               #>  [67] BiocManager_1.30.25       fastmap_1.2.0             #>  [69] boot_1.3-31               rhdf5filters_1.18.0       #>  [71] bluster_1.16.0            fansi_1.0.6               #>  [73] digest_0.6.37             rsvd_1.0.5                #>  [75] mime_0.12                 R6_2.5.1                  #>  [77] textshaping_0.4.0         colorspace_2.1-1          #>  [79] wk_0.9.4                  LearnBayes_2.15.1         #>  [81] jpeg_0.1-10               RSQLite_2.3.8             #>  [83] R.methodsS3_1.8.2         utf8_1.2.4                #>  [85] generics_0.1.3            data.table_1.16.2         #>  [87] class_7.3-22              httr_1.4.7                #>  [89] htmlwidgets_1.6.4         S4Arrays_1.6.0            #>  [91] pkgconfig_2.0.3           scico_1.5.0               #>  [93] gtable_0.3.6              blob_1.2.4                #>  [95] XVector_0.46.0            htmltools_0.5.8.1         #>  [97] fftwtools_0.9-11          scales_1.3.0              #>  [99] png_0.1-8                 SpatialExperiment_1.16.0  #> [101] knitr_1.49                rjson_0.2.23              #> [103] coda_0.19-4.1             nlme_3.1-166              #> [105] curl_6.0.1                proxy_0.4-27              #> [107] cachem_1.1.0              zoo_1.8-12                #> [109] rhdf5_2.50.0              BiocVersion_3.20.0        #> [111] KernSmooth_2.23-24        vipor_0.4.7               #> [113] parallel_4.4.2            AnnotationDbi_1.68.0      #> [115] desc_1.4.3                s2_1.1.7                  #> [117] pillar_1.9.0              grid_4.4.2                #> [119] vctrs_0.6.5               BiocSingular_1.22.0       #> [121] dbplyr_2.5.0              beachmat_2.22.0           #> [123] sfheaders_0.4.4           cluster_2.1.6             #> [125] beeswarm_0.4.0            evaluate_1.0.1            #> [127] zeallot_0.1.0             magick_2.8.5              #> [129] mvtnorm_1.3-2             cli_3.6.3                 #> [131] locfit_1.5-9.10           compiler_4.4.2            #> [133] rlang_1.1.4               crayon_1.5.3              #> [135] labeling_0.4.3            classInt_0.4-10           #> [137] ggbeeswarm_0.7.2          fs_1.6.5                  #> [139] viridisLite_0.4.2         deldir_2.0-4              #> [141] BiocParallel_1.40.0       munsell_0.5.1             #> [143] Biostrings_2.74.0         tiff_0.1-12               #> [145] Matrix_1.7-1              ExperimentHub_2.14.0      #> [147] patchwork_1.3.0           sparseMatrixStats_1.18.0  #> [149] bit64_4.5.2               Rhdf5lib_1.28.0           #> [151] KEGGREST_1.46.0           statmod_1.5.0             #> [153] AnnotationHub_3.14.0      igraph_2.1.1              #> [155] memoise_2.0.1             bslib_0.8.0               #> [157] bit_4.5.0"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/merfish_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"MERFISH Processing Workflows with Voyager","text":"Pros: Commercial kit Single cell resolution High detection efficiency Formalin fixed, paraffin embedded (FFPE) tissue compatible Provides subcellular transcript localization information Compatible histological staining including DAPI Protein co-detection supported Cons: curated panel usually hundred genes required. However, Vizgen provides curated gene panels neuroscience oncology, well panel design services. Data size harder manage larger tissue areas number samples. spatial analysis methods can scale hundreds thousands millions cells.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/merfish_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"MERFISH Processing Workflows with Voyager","text":"Several MERFISH datasets generated MERSCOPE Platform publicly available Vizgen website. provide examples available processing output various spatial transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager vignette . vignette provides technology specific notes data downloaded Vizgen. Briefly, Vizgen provides cell metadata gene count matrix CSV files can read quickly vroom package. Cell segmentation data provided HDF5 files delineated field view.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/merfish_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"MERFISH Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using data generated MERFISH technology. publicly available MERFISH datasets profile hundreds genes hundreds thousands millions cells. Thus, vignettes linked can provide context capabilities Voyager moderate large datasets.","code":""},{"path":[]},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"Due large number genes quantified single cell spatial transcriptomics, dimension reduction part standard workflow analyze data, visualize, help interpreting data, distill relevant information reduce noise, facilitate downstream analyses clustering pseudotime, project different samples shared latent space data integration, . first dimension reduction methods learn , good old principal component analysis (PCA), tSNE, UMAP, donâ€™t use spatial information. rise spatial transcriptomics, dimension reduction methods take spatial dependence account written. , SpatialPCA (Shang2022-qy?), NSF (Townes2023-bi?), MEFISTO (Velten2022-gv?) use factor analysis probabilistic PCA related factor analysis, model factors Gaussian processes, spatial kernel covariance matrix, factors positive spatial autocorrelation can used downstream clustering clusters can spatially coherent. use graph convolution networks spatial neighborhood graph find spatially informed embeddings cells, conST (Zong2022-tb?) SpaceFlow (Ren2022-qx?). SpaSRL (Zhang2023-kf?) finds low dimension projection spatial neighborhood augmented data. Spatially informed dimension reduction actually new, dates back least 1985, Wartenbergâ€™s crossover Moranâ€™s PCA (Wartenberg1985-fk?), generalized developed MULTISPATI PCA (Dray2008-en?), implemented adespatial package CRAN. short, PCA tries maximize variance explained PC, MULTISPATI maximizes product Moranâ€™s variance explained. Also, eigenvalues PCA non-negative, covariance matrix positive semidefinite, MULTISPATI can give negative eigenvalues, represent negative spatial autocorrelation, can present interesting common positive spatial autocorrelation often masked latter (Griffith2019-bo?). single cell -omics conventions, let XX denote gene count matrix whose columns cells Visium spots whose rows genes, nn columns. Let WW denote row normalized nÃ—nn\\times n adjacency matrix spatial neighborhood graph cells Visium spots, symmetric. MULTISPATI diagonalizes symmetric matrix H=12nX(Wt+W)Xt H = \\frac 1 {2n} X(W^t+W)X^t However, implementation adespatial general can used multivariate analyses duality diagram paradigm, correspondence analysis; equation simplified just PCA, without introduce duality diagram . Voyager 1.2.0 (Bioconductor release) much faster implementation MULTISPATI PCA based RSpectra. See benchmark . vignette, perform MULTISPATI PCA MERFISH mouse liver dataset. See first vignette using dataset . load packages used: MULTISPATI PCA one multivariate methods introduced Voyager 1.2.0. multivariate methods Voyager listed : calling calculate*variate() run*variate(), type (2nd) argument takes either SFEMethod object string matches entry name column data frame returned listSFEMethods().","code":"library(Voyager) library(SFEData) library(SpatialFeatureExperiment) library(scater) library(scran) library(scuttle) library(ggplot2) library(stringr) library(tidyr) library(tibble) library(bluster) library(BiocSingular) library(BiocParallel) library(sf) library(patchwork) library(spdep) set.ZeroPolicyOption(TRUE) theme_set(theme_bw()) (sfe <- VizgenLiverData()) #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 385 395215  #> metadata(0): #> assays(1): counts #> rownames(385): Comt Ldha ... Blank-36 Blank-37 #> rowData names(3): means vars cv2 #> colnames(395215): 10482024599960584593741782560798328923 #>   111551578131181081835796893618918348842 ... #>   92389687374928708938472537234969690424 #>   96399783859933548456002372694492036651 #> colData names(9): fov volume ... nCounts nGenes #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01: listSFEMethods(variate = \"multi\") #>                name                                      description #> 1        multispati                                   MULTISPATI PCA #> 2      localC_multi                     Multivariate local Geary's C #> 3 localC_perm_multi Multivariate local Geary's C permutation testing"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"quality-control","dir":"Articles","previous_headings":"","what":"Quality control","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"QC already performed first vignette. QC , see first vignette details. Remove outliers empty cells: still 390,000 cells left removing outliers. Next compute Moranâ€™s QC metrics, requires spatial neighborhood graph:  Moranâ€™s little negative, permutation testing, significant, though can also large number cells. lower bound Moranâ€™s given spatial neighborhood graph usually closer -0.5 -1, upper bound usually around 1. bounds given specific spatial neighborhood graph can found moranBounds(), double centers adjacency matrix, hence making dense, isnâ€™t enough memory use entire dataset. can look Moran bounds small subset data, might generalizable whole dataset given tissue appears quite homogeneous space. Note since SpatialFeatureExperiment v1.8, sptial graphs subsetted rather reconstructed SFE object subsetted reconstruction tends time consuming BPPARAM BNPARAM arguments canâ€™t stored saved alabaster.sfe. Subsetting removes neighbors cells near boundary bounding box vast majority cells still 5 nearest neighbors. lower bound quite different reconstruct knn graph subset cool systematically investigate effects perturbations spatial neighborhood graph Moranâ€™s spatial statistics. considering bounds, Moranâ€™s values QC metrics like whose magnitudes seem substantial nCounts nGenes â€™s positive spatial autocorrelation. may mild moderate negative spatial autocorrelation.","code":"is_blank <- str_detect(rownames(sfe), \"^Blank-\") sfe <- addPerCellQCMetrics(sfe, subset = list(blank = is_blank)) get_neg_ctrl_outliers <- function(col, sfe, nmads = 3, log = FALSE) {     inds <- colData(sfe)$nCounts > 0 & colData(sfe)[[col]] > 0     df <- colData(sfe)[inds,]     outlier_inds <- isOutlier(df[[col]], type = \"higher\", nmads = nmads, log = log)     outliers <- rownames(df)[outlier_inds]     col2 <- str_remove(col, \"^subsets_\")     col2 <- str_remove(col2, \"_percent$\")     new_colname <- paste(\"is\", col2, \"outlier\", sep = \"_\")     colData(sfe)[[new_colname]] <- colnames(sfe) %in% outliers     sfe } sfe <- get_neg_ctrl_outliers(\"subsets_blank_percent\", sfe, log = TRUE) inds <- !sfe$is_blank_outlier & sfe$nCounts > 0 (sfe <- sfe[, inds]) #> class: SpatialFeatureExperiment  #> dim: 385 390348  #> metadata(0): #> assays(1): counts #> rownames(385): Comt Ldha ... Blank-36 Blank-37 #> rowData names(4): means vars cv2 subsets_blank #> colnames(390348): 10482024599960584593741782560798328923 #>   111551578131181081835796893618918348842 ... #>   92389687374928708938472537234969690424 #>   96399783859933548456002372694492036651 #> colData names(16): fov volume ... total is_blank_outlier #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01: system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                    dist_type = \"idw\", k = 5,                                                    style = \"W\", zero.policy = TRUE) ) #>    user  system elapsed  #>  28.583   0.123  28.762 features_use <- c(\"nCounts\", \"nGenes\", \"volume\") sfe <- colDataUnivariate(sfe, \"moran.mc\", features_use,                           colGraphName = \"knn5\", nsim = 49,                           BPPARAM = MulticoreParam(2)) plotMoranMC(sfe, features_use) bbox_use <- c(xmin = 6000, xmax = 7000, ymin = 4000, ymax = 5000) inds2 <- st_intersects(cellSeg(sfe), st_as_sfc(st_bbox(bbox_use)),                         sparse = FALSE)[,1] sfe_sub <- sfe[, inds2] #> Warning in sn2listw(df, style = style, zero.policy = zero.policy, from_mat2listw = TRUE): no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error table(card(colGraph(sfe_sub, \"knn5\")$neighbours)) #>  #>    0    1    2    3    4    5  #>    1    7   54   99  120 5405 (mb <- moranBounds(colGraph(sfe_sub, \"knn5\"))) #>       Imin       Imax  #> -0.9623209  1.0779488 colGraph(sfe_sub, \"knn5_reconst\") <- findSpatialNeighbors(sfe_sub, method = \"knearneigh\",                                                            k = 5L, dist_type = \"idw\",                                                           style = \"W\") (mb2 <- moranBounds(colGraph(sfe_sub, \"knn5_reconst\"))) #>       Imin       Imax  #> -0.6079436  1.0608389 setNames(colFeatureData(sfe)[c(\"nCounts\", \"nGenes\", \"volume\"),                               \"moran.mc_statistic_sample01\"] / mb2[\"Imin\"],          features_use) #>    nCounts     nGenes     volume  #> 0.17839356 0.15168017 0.03211427 # Normalize data sfe <- logNormCounts(sfe)"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"hepatic-zonation","dir":"Articles","previous_headings":"","what":"Hepatic zonation","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"dataset comes relatively large piece tissue need zoom smaller region better see local structures. specify bounding box. portal triad shown near top right bounding box. two large vessels left bottom right central veins. portal triad consists hepatic artery, portal vein brings blood intestine, bile duct, â€™s oxygenated. regions around central vein deoxygenated. different oxygen nutrient contents mean hepatocytes play different metabolic roles zones portal triad central vein. plot zonation marker genes (Halpern2017-lq?). 3 marker genes present dataset. first two pericentral (near central vein), last one periportal (near portal triad).  Besides hepatocytes, liver also many endothelial cells Kupffer cells (macrophages). Marker genes cells (Bonnardel2019-le?) plotted visualize cell types space: one Kupffer cell markers available dataset.  Expression gene seem spatially coherent. 3 endothelial cell marker genes available dataset.  Wnt2 seems pericentral, Ltbp4 Efnb2 seem periportal. marker genes show top PC loadings non-spatial spatial PCA.","code":"bbox_use <- c(xmin = 6100, xmax = 7100, ymin = 7500, ymax = 8500) markers <- c(\"Axin2\", \"Cyp1a2\", \"Gstm3\", \"Psmd4\", # Pericentral              \"Cyp2e1\", \"Asl\", \"Alb\", \"Ass1\", # Monotonic but has intermediate              \"Hamp\", \"Igfbp2\", \"Cyp8b1\", \"Mup3\", # Non-monotonic              \"Arg1\", \"Pck1\", \"C2\", \"Sdhd\") # Periportal (inds <- which(markers %in% rownames(sfe))) #> [1]  1  2 14 plotSpatialFeature(sfe, markers[inds], colGeometryName = \"cellSeg\",                    ncol = 3, bbox = bbox_use) # Kuppfer cells kc_genes <- c(\"Timd4\", \"Vsig4\", \"Clec4f\", \"Clec1b\", \"Il18bp\", \"C6\", \"Irf7\",               \"Slc40a1\", \"Cdh5\", \"Nr1h3\", \"Dmpk\", \"Paqr9\", \"Pcolce2\", \"Kcna2\",               \"Gbp8\", \"Iigp1\", \"Helz2\", \"Cd207\", \"Icos\", \"Adcy4\", \"Slc1a2\",               \"Rsad2\", \"Slc16a9\", \"Cd209f\", \"Oasl1\", \"Fam167a\") which(kc_genes %in% rownames(sfe)) #> [1] 9 plotSpatialFeature(sfe, kc_genes[9], colGeometryName = \"cellSeg\",                    bbox = bbox_use) # Endothelial cells lec_genes <- c(\"Rspo3\", \"Wnt2\", \"Wnt9b\", \"Pcdhgc5\", \"Ecm1\", \"Ltbp4\", \"Efnb2\") (inds_lec <- which(lec_genes %in% rownames(sfe))) #> [1] 2 6 7 plotSpatialFeature(sfe, lec_genes[inds_lec], colGeometryName = \"cellSeg\",                    bbox = bbox_use, ncol = 3)"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"non-spatial-pca","dir":"Articles","previous_headings":"","what":"Non-spatial PCA","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"First run non-spatial PCA, compare MULTISPATI. â€™s pretty quick almost 400,000 cells, arenâ€™t many genes . Use elbow plot see variance explained PC:  Plot top gene loadings PC  Many genes seem related endothelium. PC1 PC4 concern Kupffer cells well, Kupffer cell marker gene Cdh5 high loading. Plot first 4 PCs space  PC1 PC4 highlight major blood vessels, PC2 PC3 less spatial structure. CosMX Xenium datasets website, top PCs clear spatial structures despite absence spatial information non-spatial PCA clear spatial compartments cell types, seem case dataset except blood vessels. seen genes strong spatial structures. PC2 PC3 donâ€™t seem large scale spatial structure, may local spatial structure obvious plotting entire section, zoom bounding box shows hepatic zonation.  â€™s spatial structure smaller scale, perhaps negative spatial autocorrelation.","code":"set.seed(29) system.time(     sfe <- runPCA(sfe, ncomponents = 20, subset_row = !is_blank,                   exprs_values = \"logcounts\",                   scale = TRUE, BSPARAM = IrlbaParam()) ) #>    user  system elapsed  #>  13.937   6.219  13.198 gc() #>             used   (Mb) gc trigger   (Mb)  max used   (Mb) #> Ncells  16563117  884.6   26419641 1411.0  26419641 1411.0 #> Vcells 242231178 1848.1  540607302 4124.6 540592370 4124.4 ElbowPlot(sfe) plotDimLoadings(sfe) spatialReducedDim(sfe, \"PCA\", 4, colGeometryName = \"centroids\", scattermore = TRUE,                   divergent = TRUE, diverge_center = 0) spatialReducedDim(sfe, \"PCA\", ncomponents = 4, colGeometryName = \"cellSeg\",                   bbox = bbox_use, divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"multispati-pca","dir":"Articles","previous_headings":"","what":"MULTISPATI PCA","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"plot positive negative eigenvalues. Note eigenvalues variance explained. Instead, product variance explained Moranâ€™s . positive eigenvalues correspond eigenvectors simultaneously explain variance large positive Moranâ€™s . negative eigenvalues correspond eigenvectors simultaneously explain variance negative Moranâ€™s .  positive eigenvalues drop sharply PC1 PC4, one negative eigenvalue might interesting, unsurprising given moderately negative Moranâ€™s nCounts nGenes. However, first MERFISH vignette, none genes negative Moranâ€™s . Perhaps negative eigenvalue comes negative spatial autocorrelation gene program â€œeigengeneâ€ obvious individual genes. beauty multivariate analysis. components mean? component linear combination genes maximize product variance explained Moranâ€™s . second component maximizes product provided â€™s orthogonal first component, . loss variance explained usually huge, components can considered axes along spatially coherent groups spots separated much possible according expression highly variable genes, theory, clustering positive MULTISPATI components give spatially coherent clusters. spatial coherence, MULTISPATI might robust outliers.  gene loadings, PC40 seems separate endothelial cells Kupffer cells hepatocytes. Plot PCs:  first two PCs pick zoning. PC3 seems smaller scale spatial structure. PCâ€40â€ (really 300 something) example negative spatial autocorrelation biology. Kupffer cells endothelial cells scattered among hepatocytes may play functional role. mean non-spatial PCA bad. MULTISPATI tends lose much variance explained per PC positive eigenvalues, identifies co-expressed genes spatially structured expression patterns. MULTISPATI tells different story non-spatial PCA. PCA cell embeddings often used downstream analysis. Whether use MULTISPATI embeddings instead many PCs use depend questions asked downstream analyses.","code":"system.time({     sfe <- runMultivariate(sfe, \"multispati\", colGraphName = \"knn5\", nfposi = 20,                        nfnega = 20) }) #> Warning in asMethod(object): sparse->dense coercion: allocating vector of size #> 1.1 GiB #> Warning: `listw2sparse()` was deprecated in SpatialFeatureExperiment 1.9.0. #> â„¹ Please use `spatialreg::as_dgRMatrix_listw()` instead. #> â„¹ The deprecated feature was likely used in the Voyager package. #>   Please report the issue at <https://github.com/pachterlab/voyager/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #>    user  system elapsed  #>  14.801   5.228  18.961 ElbowPlot(sfe, nfnega = 20, reduction = \"multispati\") plotDimLoadings(sfe, dims = c(1:3, 40), reduction = \"multispati\") spatialReducedDim(sfe, \"multispati\", components = c(1:3, 40),                    colGeometryName = \"cellSeg\", bbox = bbox_use,                   divergent = TRUE, diverge_center = 0)"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"morans-i","dir":"Articles","previous_headings":"Spatial autocorrelation of principal components","what":"Moranâ€™s I","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"compare Moranâ€™s cell embeddings non-spatial MULTISPATI PC:  MULTISPATI, Moranâ€™s high PC1 PC2, sharply drops. Moranâ€™s PC negative eigenvalues negative, means large magnitude eigenvalue comes explaining variance. However, considering lower bound Moranâ€™s around -0.6 instead -1, magnitude Moranâ€™s PC negative eigenvalue trivial. Non-spatial PCs sorted Moranâ€™s ; PC5 surprising large Moranâ€™s .  PC5 must zonation. Also show larger scale:","code":"# non-spatial sfe <- reducedDimMoransI(sfe, dimred = \"PCA\", components = 1:20,                          BPPARAM = MulticoreParam(2)) # spatial sfe <- reducedDimMoransI(sfe, dimred = \"multispati\", components = 1:40,                          BPPARAM = MulticoreParam(2)) df_moran <- tibble(PCA = reducedDimFeatureData(sfe, \"PCA\")$moran_sample01[1:20],                    MULTISPATI_pos =                         reducedDimFeatureData(sfe, \"multispati\")$moran_sample01[1:20],                    MULTISPATI_neg =                         reducedDimFeatureData(sfe,\"multispati\")$moran_sample01[21:40] |>                         rev(),                    index = 1:20) data(\"ditto_colors\") df_moran |>      pivot_longer(cols = -index, values_to = \"value\", names_to = \"name\") |>      ggplot(aes(index, value, color = name)) +     geom_line() +     scale_color_manual(values = ditto_colors) +     geom_hline(yintercept = 0, color = \"gray\") +     geom_hline(yintercept = mb2, linetype = 2, color = \"gray\") +     scale_y_continuous(breaks = scales::breaks_pretty()) +     scale_x_continuous(breaks = scales::breaks_width(5)) +     labs(y = \"Moran's I\", color = \"Type\", x = \"Component\") min(df_moran$MULTISPATI_neg) / mb2[1] #>      Imin  #> 0.1374483 spatialReducedDim(sfe, \"PCA\", component = 5, colGeometryName = \"cellSeg\",                    divergent = TRUE, diverge_center = 0, bbox = bbox_use) spatialReducedDim(sfe, \"PCA\", components = 5, colGeometryName = \"centroids\",                    divergent = TRUE, diverge_center = 0, scattermore = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"moran-scatter-plot","dir":"Articles","previous_headings":"Spatial autocorrelation of principal components","what":"Moran scatter plot","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"Local positive negative spatial autocorrelation can average global Moranâ€™s . zoomed plots gene loadings , PCs endothelial cells. Moran scatter plot can help discovering local heterogeneity.  PCs 1-3 fainter clusters outside main cluster, indicating heterogeneous spatial autocorrelation. Also make Moran scatter plots MULTISPATI  interesting clusters.","code":"sfe <- reducedDimUnivariate(sfe, \"moran.plot\", dimred = \"PCA\", components = 1:6) plts <- lapply(seq_len(6), function(i) {     moranPlot(sfe, paste0(\"PC\", i), binned = TRUE, hex = TRUE, plot_influential = FALSE) }) wrap_plots(plts, widths = 1, heights = 1) +     plot_layout(ncol = 3) +     plot_annotation(tag_levels = \"1\",                      title = \"Moran scatter plot for non-spatial PCs\") &     theme(legend.position = \"none\") sfe <- reducedDimUnivariate(sfe, \"moran.plot\", dimred = \"multispati\",                              components = c(1:5, 40),                              # Not to overwrite non-spatial PCA moran plots                             name = \"moran.plot2\") plts2 <- lapply(c(1:5, 40), function(i) {     moranPlot(sfe, paste0(\"PC\", i), binned = TRUE, hex = TRUE,                plot_influential = FALSE, name = \"moran.plot2\") }) wrap_plots(plts2, widths = 1, heights = 1) +     plot_layout(ncol = 3) +     plot_annotation(tag_levels = \"1\",                     title = \"Moran scatter plot for MULTISPATI PCs\") &     theme(legend.position = \"none\")"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"clustering-with-multispati-pca","dir":"Articles","previous_headings":"","what":"Clustering with MULTISPATI PCA","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"standard scRNA-seq data analysis workflow, k nearest neighbor graph found PCA space, used graph based clustering Louvain Leiden, used perform differential expression. Spatial dimension reductions can similarly used perform clustering, identify spatial regions tissue, done (Shang2022-qy?; Ren2022-qx?; Zhang2023-kf?). type studies often use manual segmentation ground truth compare different methods identify spatial regions. problem spatial region methods meant help us identify novel spatial regions based new -omics data, might reveal â€™s previously unknown manual annotations. output method doesnâ€™t match manual annotations, might simply pointing previously unknown aspect tissue rather wrong. Depending questions asked, can simultaneously multiple spatial partitions. happens geographical space. instance, â€™s land use neighborhood boundaries, equally valid watershed boundaries types rock formation. one relevant depends questions asked. perform Leiden clustering non-spatial MULTISPATI PCA compare results. k nearest neighbor graph, used default k = 10. See clustering positive MULTISPATI PCs give spatially coherent clusters Plot clusters space:  MULTISPATI clusters look somewhat spatially structured clusters non-spatial PCA. Also zoom small area:  clusters mean? Clusters supposed groups different spots similar within group, sharing characteristics. Non-spatial MULTISPATI PCA use different characteristics clustering. Non-spatial PCA finds genes good telling cell types apart, although genes may happen spatially structured. Non-spatial clustering aims find groups gene expression, cells similar gene expression can surrounded cells types histological space. just like mapping Art Deco buildings, often near Spanish revival Beaux Art buildings whose styles quite different perform different functions, thus necessarily forming coherent spatial region. contrast, MULTISPATIâ€™s positive components find genes must characterize spatial regions addition distinguishing different cell types. genes involved MULTISPATI component may interesting clusters. interesting perform gene set enrichment analysis, interpret sort spatial patterns spatially variable genes. like mapping buildings built, Art Deco, Spanish revival, Beaux Art popular 1920s 1930s end cluster form spatially coherent region, can found DTLA Historical Core Jewelry District, Old Pasadena. Hence non-spatial clustering spatial data isnâ€™t necessarily bad. Rather, tells different story reveals different aspects data spatial clustering.","code":"system.time({     set.seed(29)     sfe$clusts_nonspatial <- clusterCells(sfe, use.dimred = \"PCA\",                                            BLUSPARAM = NNGraphParam(                                               cluster.fun = \"leiden\",                                               cluster.args = list(                                                   objective_function = \"modularity\",                                                   resolution_parameter = 1                                               )                                           )) }) #>    user  system elapsed  #> 343.171   0.289 343.483 system.time({     set.seed(29)     sfe$clusts_multispati <- clusterRows(reducedDim(sfe, \"multispati\")[,1:20],                                            BLUSPARAM = NNGraphParam(                                               cluster.fun = \"leiden\",                                               cluster.args = list(                                                   objective_function = \"modularity\",                                                   resolution_parameter = 1                                               )                                           )) }) #>    user  system elapsed  #> 443.714   0.340 444.101 plotSpatialFeature(sfe, c(\"clusts_nonspatial\", \"clusts_multispati\"),                     colGeometryName = \"centroids\",                    scattermore = TRUE) &      guides(colour = guide_legend(override.aes = list(size=2), ncol = 2)) plotSpatialFeature(sfe, c(\"clusts_nonspatial\", \"clusts_multispati\"),                     colGeometryName = \"cellSeg\",                    bbox = bbox_use) &      guides(fill = guide_legend(ncol = 2))"},{"path":"https://pachterlab.github.io/voyager/articles/multispati.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"MULTISPATI PCA and negative spatial autocorrelation","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] spdep_1.3-6                    spData_2.3.3                   #>  [3] patchwork_1.3.0                sf_1.0-19                      #>  [5] BiocParallel_1.40.0            BiocSingular_1.22.0            #>  [7] bluster_1.16.0                 tibble_3.2.1                   #>  [9] tidyr_1.3.1                    stringr_1.5.1                  #> [11] scran_1.34.0                   scater_1.34.0                  #> [13] ggplot2_3.5.1                  scuttle_1.16.0                 #> [15] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [17] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [19] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [21] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [23] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [25] SFEData_1.8.0                  Voyager_1.8.1                  #> [27] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            R.oo_1.27.0               #>   [5] lifecycle_1.0.4           edgeR_4.4.0               #>   [7] lattice_0.22-6            MASS_7.3-61               #>   [9] magrittr_2.0.3            limma_3.62.1              #>  [11] sass_0.4.9                rmarkdown_2.29            #>  [13] jquerylib_0.1.4           yaml_2.3.10               #>  [15] metapod_1.14.0            sp_2.1-4                  #>  [17] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [19] multcomp_1.4-26           abind_1.4-8               #>  [21] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [23] purrr_1.0.2               R.utils_2.12.3            #>  [25] RCurl_1.98-1.16           TH.data_1.1-2             #>  [27] rappdirs_0.3.3            sandwich_3.1-1            #>  [29] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [31] irlba_2.3.5.1             terra_1.7-83              #>  [33] units_0.8-5               RSpectra_0.16-2           #>  [35] dqrng_0.4.1               pkgdown_2.1.1             #>  [37] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [39] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [41] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [43] memuse_4.2-3              farver_2.1.2              #>  [45] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [47] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [49] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [51] survival_3.7-0            systemfonts_1.1.0         #>  [53] tools_4.4.2               ggnewscale_0.5.0          #>  [55] ragg_1.3.3                Rcpp_1.0.13-1             #>  [57] glue_1.8.0                gridExtra_2.3             #>  [59] SparseArray_1.6.0         mgcv_1.9-1                #>  [61] xfun_0.49                 EBImage_4.48.0            #>  [63] dplyr_1.1.4               HDF5Array_1.34.0          #>  [65] withr_3.0.2               BiocManager_1.30.25       #>  [67] fastmap_1.2.0             boot_1.3-31               #>  [69] rhdf5filters_1.18.0       fansi_1.0.6               #>  [71] digest_0.6.37             rsvd_1.0.5                #>  [73] mime_0.12                 R6_2.5.1                  #>  [75] textshaping_0.4.0         colorspace_2.1-1          #>  [77] wk_0.9.4                  scattermore_1.2           #>  [79] LearnBayes_2.15.1         jpeg_0.1-10               #>  [81] RSQLite_2.3.8             R.methodsS3_1.8.2         #>  [83] hexbin_1.28.5             utf8_1.2.4                #>  [85] generics_0.1.3            data.table_1.16.2         #>  [87] class_7.3-22              httr_1.4.7                #>  [89] htmlwidgets_1.6.4         S4Arrays_1.6.0            #>  [91] pkgconfig_2.0.3           scico_1.5.0               #>  [93] gtable_0.3.6              blob_1.2.4                #>  [95] XVector_0.46.0            htmltools_0.5.8.1         #>  [97] fftwtools_0.9-11          scales_1.3.0              #>  [99] png_0.1-8                 SpatialExperiment_1.16.0  #> [101] knitr_1.49                rjson_0.2.23              #> [103] coda_0.19-4.1             nlme_3.1-166              #> [105] curl_6.0.1                proxy_0.4-27              #> [107] cachem_1.1.0              zoo_1.8-12                #> [109] rhdf5_2.50.0              BiocVersion_3.20.0        #> [111] KernSmooth_2.23-24        vipor_0.4.7               #> [113] parallel_4.4.2            AnnotationDbi_1.68.0      #> [115] desc_1.4.3                s2_1.1.7                  #> [117] pillar_1.9.0              grid_4.4.2                #> [119] vctrs_0.6.5               dbplyr_2.5.0              #> [121] beachmat_2.22.0           sfheaders_0.4.4           #> [123] cluster_2.1.6             beeswarm_0.4.0            #> [125] evaluate_1.0.1            zeallot_0.1.0             #> [127] magick_2.8.5              mvtnorm_1.3-2             #> [129] cli_3.6.3                 locfit_1.5-9.10           #> [131] compiler_4.4.2            rlang_1.1.4               #> [133] crayon_1.5.3              labeling_0.4.3            #> [135] classInt_0.4-10           ggbeeswarm_0.7.2          #> [137] fs_1.6.5                  stringi_1.8.4             #> [139] viridisLite_0.4.2         deldir_2.0-4              #> [141] munsell_0.5.1             Biostrings_2.74.0         #> [143] tiff_0.1-12               Matrix_1.7-1              #> [145] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [147] bit64_4.5.2               Rhdf5lib_1.28.0           #> [149] KEGGREST_1.46.0           statmod_1.5.0             #> [151] AnnotationHub_3.14.0      igraph_2.1.1              #> [153] memoise_2.0.1             bslib_0.8.0               #> [155] bit_4.5.0"},{"path":[]},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"areal spatial data, spatial neighborhood graph used indicate proximity, required spatial analysis methods package spdep. One methods find spatial neighborhood graph k nearest neighbors, also commonly used gene expression PCA space graph-based clustering cells non-spatial scRNA-seq data. use k nearest neighbors graph PCA space rather histological space â€œspatialâ€ analyses non-spatial scRNA-seq data? try analysis human peripheral blood mononuclear cells (PBMC) scRNA-seq dataset, doesnâ€™t originally histological spatial organization. packages loaded analysis: <<<<<<< HEAD download filtered Cell Ranger gene count matrix 10X website. empty droplets already removed. loaded R SingleCellExperiment (SCE) object.","code":"library(Voyager) library(SpatialFeatureExperiment) library(SpatialExperiment) library(DropletUtils) library(BiocNeighbors) library(scater) library(scran) library(bluster) library(BiocParallel) library(scuttle) library(stringr) library(BiocSingular) library(spdep) library(patchwork) library(dplyr) library(reticulate) theme_set(theme_bw()) ======= >>>>>>> documentation # Specify Python version to use gget PY_PATH <- Sys.which(\"python\") use_python(PY_PATH) py_config()  # Load gget gget <- import(\"gget\") if (!dir.exists(\"filtered_feature_bc_matrix\")) {     download.file(\"https://cf.10xgenomics.com/samples/cell-exp/3.0.2/5k_pbmc_v3_nextgem/5k_pbmc_v3_nextgem_filtered_feature_bc_matrix.tar.gz\", destfile = \"5kpbmc.tar.gz\", quiet = TRUE)     system(\"tar -xzf 5kpbmc.tar.gz\") } (sce <- read10xCounts(\"filtered_feature_bc_matrix/\")) #> class: SingleCellExperiment  #> dim: 33538 5155  #> metadata(1): Samples #> assays(1): counts #> rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 #>   ENSG00000268674 #> rowData names(3): ID Symbol Type #> colnames: NULL #> colData names(2): Sample Barcode #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): colnames(sce) <- sce$Barcode"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"quality-control-qc","dir":"Articles","previous_headings":"","what":"Quality control (QC)","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"perform basic QC, remove low quality cells high proportion mitochondrially encoded counts. addPerCellQCMetrics() function computes total UMI counts detected per cell (sum), number genes detected per cell (detected), sum detected mitochondrial counts, percentage mitochondrial counts per cell.  2D histogram plotted better show point density plot.   Remove cells >20% mitochondrial counts","code":"is_mito <- str_detect(rowData(sce)$Symbol, \"^MT-\") sum(is_mito) #> [1] 13 sce <- addPerCellQCMetrics(sce, subsets = list(mito = is_mito)) names(colData(sce)) #> [1] \"Sample\"                \"Barcode\"               \"sum\"                   #> [4] \"detected\"              \"subsets_mito_sum\"      \"subsets_mito_detected\" #> [7] \"subsets_mito_percent\"  \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") +     plotColData(sce, \"subsets_mito_percent\") plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) plotColData(sce, x = \"sum\", y = \"subsets_mito_percent\", bins = 100) sce <- sce[, sce$subsets_mito_percent < 20] sce <- sce[rowSums(counts(sce)) > 0,]"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"basic-non-spatial-analyses","dir":"Articles","previous_headings":"","what":"Basic non-spatial analyses","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"normalize data, perform PCA, cluster cells, find marker genes clusters. Use highly variable genes PCA: many PCs shall use analyses?  Variance explained drops sharply PC1 PC4 levels . Plot genes largest loadings top 4 PCs:  keep little information, use 10 PCs, variance explained levels even . plot cells first 4 PCs matrix plot. diagonals density plots number cells projected PC. x axis correspond columns matrix plot, y axis correspond rows, plot row 1 column 2 PC2 x axis PC1 y axis. cells colored clusters found previous code chunk.  many cells cluster? use conventional Wilcoxon rank sum test find marker genes cluster. test compares cluster rest cells, genes highly expressed cluster compared cells considered. result list data frames, data frame corresponds one cluster. Areas receiver operator curve (AUC), distinguishing cluster vs.Â cluster, also included. closer 1 better, 0.5 means better random guessing. false discovery rate (FDR) column contains Benjamini-Hochberg corrected p-values. Genes data frames already sorted p-values. See specific top markers cluster:  can use gget info module gget package get additional information marker genes. example, NCBI description:","code":"#clusts <- quickCluster(sce) #sce <- computeSumFactors(sce, cluster = clusts) #sce <- sce[, sizeFactors(sce) > 0] sce <- logNormCounts(sce) dec <- modelGeneVar(sce, lowess = FALSE) hvgs <- getTopHVGs(dec, n = 2000) set.seed(29) sce <- runPCA(sce, ncomponents = 30, BSPARAM = IrlbaParam(),               subset_row = hvgs, scale = TRUE) ElbowPlot(sce, ndims = 30) plotDimLoadings(sce, swap_rownames = \"Symbol\") sce$cluster <- clusterRows(reducedDim(sce, \"PCA\")[,1:10],                            BLUSPARAM = SNNGraphParam(cluster.fun = \"leiden\",                                                      k = 10,                                                      cluster.args = list(                                                          resolution=0.5,                                                          objective_function = \"modularity\"                                                      ))) plotPCA(sce, ncomponents = 4, color_by = \"cluster\") table(sce$cluster) #>  #>    1    2    3    4    5    6    7    8    9  #> 1058  857 1365  590   86  112  415  119   27 markers <- findMarkers(sce, groups = colData(sce)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[4]] #> DataFrame with 21932 rows and 11 columns #>                     p.value         FDR summary.AUC     AUC.1     AUC.2 #>                   <numeric>   <numeric>   <numeric> <numeric> <numeric> #> ENSG00000105369 7.31820e-19 1.03673e-14    0.999937  0.999965  0.999482 #> ENSG00000104894 9.45403e-19 1.03673e-14    0.998305  0.994233  0.988145 #> ENSG00000007312 3.92534e-18 2.86968e-14    0.989077  0.990669  0.992377 #> ENSG00000156738 4.92451e-17 2.70011e-13    0.972316  0.999640  0.998916 #> ENSG00000133789 1.14476e-15 4.18449e-12    0.950000  0.944701  0.920505 #> ...                     ...         ...         ...       ...       ... #> ENSG00000184274           1           1         0.5  0.500000       0.5 #> ENSG00000273796           1           1         0.5  0.500000       0.5 #> ENSG00000274248           1           1         0.5  0.500000       0.5 #> ENSG00000160282           1           1         0.5  0.499527       0.5 #> ENSG00000228137           1           1         0.5  0.500000       0.5 #>                     AUC.3     AUC.5     AUC.6     AUC.7     AUC.8     AUC.9 #>                 <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> #> ENSG00000105369  0.999978  0.999054  1.000000  0.999534  0.995157  0.999937 #> ENSG00000104894  0.993947  0.991565  0.988696  0.992534  0.992344  0.998305 #> ENSG00000007312  0.991839  0.991250  0.972450  0.987639  0.981776  0.989077 #> ENSG00000156738  0.999934  0.994935  1.000000  0.995512  0.999416  0.972316 #> ENSG00000133789  0.944106  0.915166  0.893069  0.936986  0.939304  0.950000 #> ...                   ...       ...       ...       ...       ...       ... #> ENSG00000184274  0.499634       0.5       0.5       0.5  0.500000       0.5 #> ENSG00000273796  0.499267       0.5       0.5       0.5  0.500000       0.5 #> ENSG00000274248  0.498901       0.5       0.5       0.5  0.500000       0.5 #> ENSG00000160282  0.499634       0.5       0.5       0.5  0.500000       0.5 #> ENSG00000228137  0.500000       0.5       0.5       0.5  0.495798       0.5 top_markers <- unlist(lapply(markers, function(x) head(rownames(x), 1))) top_markers_symbol <- rowData(sce)[top_markers, \"Symbol\"] plotExpression(sce, top_markers_symbol, x = \"cluster\", swap_rownames = \"Symbol\",                point_fun = function(...) list()) gget_info <- gget$info(top_markers)  rownames(gget_info) <- gget_info$ensembl_gene_name select(gget_info, ncbi_description)"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"spatial-analyses-for-qc-metrics","dir":"Articles","previous_headings":"","what":"â€œSpatialâ€ analyses for QC metrics","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"Find k nearest neighbor graph PCA space Moranâ€™s : using spdep since nb2listwdist() function distance based edge weighting requires 2-3 dimensional spatial coordinates coordinates 10 dimensions. , inverse distance weighting used edge weights. histological space, convert SCE object SpatialFeatureExperiment (SFE) use spatial analysis plotting functions Voyager, pretend first 2 PCs histological space. Add k nearest neighbor graph SFE object:","code":"foo <- findKNN(reducedDim(sce, \"PCA\")[,1:10], k=10, BNPARAM=AnnoyParam()) # Split by row foo_nb <- asplit(foo$index, 1) dmat <- 1/foo$distance # Row normalize the weights dmat <- sweep(dmat, 1, rowSums(dmat), FUN = \"/\") glist <- asplit(dmat, 1) # Sort based on index ord <- lapply(foo_nb, order) foo_nb <- lapply(seq_along(foo_nb), function(i) foo_nb[[i]][ord[[i]]]) class(foo_nb) <- \"nb\" glist <- lapply(seq_along(glist), function(i) glist[[i]][ord[[i]]])  listw <- list(style = \"W\",               neighbours = foo_nb,               weights = glist) class(listw) <- \"listw\" attr(listw, \"region.id\") <- colnames(sce) (sfe <- toSpatialFeatureExperiment(sce, spatialCoords = reducedDim(sce, \"PCA\")[,1:2],                                   spatialCoordsNames = NULL)) #> class: SpatialFeatureExperiment  #> dim: 21932 4629  #> metadata(1): Samples #> assays(2): counts logcounts #> rownames(21932): ENSG00000238009 ENSG00000239945 ... ENSG00000275063 #>   ENSG00000271254 #> rowData names(4): ID Symbol Type subsets_mito #> colnames(4629): AAACCCAAGACAGCTG-1 AAACCCAAGTTAACGA-1 ... #>   TTTGTTGTCACGGACC-1 TTTGTTGTCCACACCT-1 #> colData names(11): Sample Barcode ... cluster sample_id #> reducedDimNames(1): PCA #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : PC1 PC2 #> imgData names(0): #>  #> unit: #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01: colGraph(sfe, \"knn10\") <- listw"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"morans-i","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for QC metrics","what":"Moranâ€™s I","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"total UMI counts (sum) genes detected (detected), Moranâ€™s quite strong, â€™s positive weaker percentage mitochondrial counts. second column, K, kurtosis feature interest.","code":"sfe <- colDataMoransI(sfe, c(\"sum\", \"detected\", \"subsets_mito_percent\")) colFeatureData(sfe)[c(\"sum\", \"detected\", \"subsets_mito_percent\"),] #> DataFrame with 3 rows and 2 columns #>                      moran_sample01 K_sample01 #>                           <numeric>  <numeric> #> sum                        0.655173   16.44603 #> detected                   0.750133    6.01002 #> subsets_mito_percent       0.438934    6.13555"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"moran-plot","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for QC metrics","what":"Moran plot","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"local variations k nearest neighbors graph? Moran plot, x axis value cell, y axis average value among neighboring cells graph weighted edge weights. slope fitted line Moranâ€™s . Sometimes clusters plot, showing different kinds neighborhoods. dashed lines averages x y axes.  cells cluster around average, cluster cells lower total counts whose neighbors also lower total counts. also cluster cells higher total counts whose neighbors also higher total counts. clusters seem somewhat related gene expression based clusters.   one main cluster plot number genes detected percentage mitochondrial counts. However, cells somewhat separated gene expression clusters. surprising gene expression clusters also based k nearest neighbor graph. Cluster 4 cells higher percentage mitochondrial counts neighbors.","code":"sfe <- colDataUnivariate(sfe, \"moran.plot\", c(\"sum\", \"detected\", \"subsets_mito_percent\")) moranPlot(sfe, \"sum\", color_by = \"cluster\") moranPlot(sfe, \"detected\", color_by = \"cluster\") moranPlot(sfe, \"subsets_mito_percent\", color_by = \"cluster\")"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"local-morans-i","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for QC metrics","what":"Local Moranâ€™s I","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"Also see local Moranâ€™s 3 QC metrics: , donâ€™t histological space. can visualize local â€œspatialâ€ statistics? UMAP bad, case PCA can somewhat separate clusters. can use first 2 PCs histological space. reference, plot metrics clusters first 2 PCs.  Plot local Moranâ€™s metrics first 2 PCs:  However, good 2D representation data easy plotting? Remember k nearest neighbor graph computed first 10 PCs rather first 2 PCs. graph tied 2D representation. can still plot histograms show distribution scatter plots compare local metric different variables, can colored another variable cluster. may added next release Voyager. now, add results interest colData(sfe) use existing colData plotting functions scater Voyager.  y axis log transformed (hence warning bins cells), color cells long tail can seen cells donâ€™t strong local Moranâ€™s . Cells cluster 7 high local Moranâ€™s total UMI counts genes detected, means tend homogeneous QC metrics. local Moranâ€™s QC metrics relate ?  Cells locally homogeneous total UMI counts also homogeneous number genes detected, surprising given correlation two.  local Moranâ€™s , sum vs percentage mitochondrial counts shows interesting pattern, highlighting clusters 4 7 Moran plots. local Moranâ€™s relate value ?  case, generally cells higher total counts also tend higher local Moranâ€™s total counts. However, another wing cells lower total counts slightly higher local Moranâ€™s total counts â€™s central value total counts near 0 local Moranâ€™s . density contour shows cells concentrated central value.","code":"sfe <- colDataUnivariate(sfe, \"localmoran\", c(\"sum\", \"detected\", \"subsets_mito_percent\")) plotSpatialFeature(sfe, c(\"sum\", \"detected\", \"subsets_mito_percent\", \"cluster\")) plotLocalResult(sfe, \"localmoran\", c(\"sum\", \"detected\", \"subsets_mito_percent\"),                  colGeometryName = \"centroids\",                 divergent = TRUE, diverge_center = 0, ncol = 2) localResultAttrs(sfe, \"localmoran\", \"sum\") #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\" sfe$sum_localmoran <- localResult(sfe, \"localmoran\", \"sum\")[,\"Ii\"] sfe$detected_localmoran <- localResult(sfe, \"localmoran\", \"detected\")[,\"Ii\"] sfe$pct_mito_localmoran <- localResult(sfe, \"localmoran\", \"subsets_mito_percent\")[,\"Ii\"] # Colorblind friendly palette data(\"ditto_colors\") plotColDataFreqpoly(sfe, c(\"sum_localmoran\", \"detected_localmoran\",                             \"pct_mito_localmoran\"), bins = 50,                      color_by = \"cluster\") +     scale_y_log10() +     annotation_logticks(sides = \"l\") #> Warning in scale_y_log10(): log-10 transformation introduced #> infinite values. plotColData(sfe, x = \"sum_localmoran\", y = \"detected_localmoran\",              color_by = \"cluster\") +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. plotColData(sfe, x = \"sum_localmoran\", y = \"pct_mito_localmoran\",              color_by = \"cluster\") +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. plotColData(sfe, x = \"sum\", y = \"sum_localmoran\", color_by = \"cluster\") +     geom_density2d(data = as.data.frame(colData(sfe)),                    mapping = aes(x = sum, y = sum_localmoran), color = \"blue\",                     linewidth = 0.3) +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale."},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"local-spatial-heteroscedasticity-losh","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for QC metrics","what":"Local spatial heteroscedasticity (LOSH)","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"LOSH indicates heterogeneity around cell k nearest neighbor graph.  make non-spatial plots LOSH local Moranâ€™s .  , clusters 2 6 tend locally heterogeneous. total counts genes detected relate LOSH?  generally cells higher LOSH total counts also higher LOSH genes detected, outliers high , heterogeneous neighborhoods. Absolute distance neighbors taken account adjacency matrix row normalized. interesting see outliers tend away 10 nearest neighbors, region PCA space cells apart. total counts relate LOSH?  seem clear relationship case.","code":"sfe <- colDataUnivariate(sfe, \"LOSH\", c(\"sum\", \"detected\", \"subsets_mito_percent\")) plotLocalResult(sfe, \"LOSH\", c(\"sum\", \"detected\", \"subsets_mito_percent\"),                  colGeometryName = \"centroids\", ncol = 2) localResultAttrs(sfe, \"LOSH\", \"sum\") #> [1] \"Hi\"      \"E.Hi\"    \"Var.Hi\"  \"Z.Hi\"    \"x_bar_i\" \"ei\" sfe$sum_losh <- localResult(sfe, \"LOSH\", \"sum\")[,\"Hi\"] sfe$detected_losh <- localResult(sfe, \"LOSH\", \"detected\")[,\"Hi\"] sfe$pct_mito_losh <- localResult(sfe, \"LOSH\", \"subsets_mito_percent\")[,\"Hi\"] plotColDataFreqpoly(sfe, c(\"sum_losh\", \"detected_losh\",                             \"pct_mito_losh\"), bins = 50,                       color_by = \"cluster\") +     scale_y_log10() +     annotation_logticks(sides = \"l\") #> Warning in scale_y_log10(): log-10 transformation introduced #> infinite values. plotColData(sfe, x = \"sum_losh\", y = \"detected_losh\", color_by = \"cluster\") +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. plotColData(sfe, x = \"sum\", y = \"sum_losh\", color_by = \"cluster\") +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale."},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"spatial-analyses-for-gene-expression","dir":"Articles","previous_headings":"","what":"â€œSpatialâ€ analyses for gene expression","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"First, need reorganize differential expression results:","code":"top_markers_df <- lapply(seq_along(markers), function(i) {     out <- markers[[i]][markers[[i]]$FDR < 0.05, c(\"FDR\", \"summary.AUC\")]     if (nrow(out)) out$cluster <- i     out }) top_markers_df <- do.call(rbind, top_markers_df) top_markers_df$symbol <- rowData(sce)[rownames(top_markers_df), \"Symbol\"]"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"morans-i-1","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for gene expression","what":"Moranâ€™s I","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"results added rowData(sfe). NAâ€™s non-highly variable genes, Moranâ€™s computed highly variable genes . Moranâ€™s â€™s highly variable genes distributed? Also, top cluster marker genes distribution?  top marker genes quite positive Moranâ€™s k nearest neighbor graph. also interesting color histogram gene sets. Since k nearest neighbor graph found PCA space, based gene expression, expected, Moranâ€™s graph mostly positive, although often strong. small number genes slightly negative Moranâ€™s . top genes look like PCA?   marker genes cluster, cluster 9. Perhaps genes high Moranâ€™s specific cell type. Moranâ€™s relate cluster AUC cluster differential expression p-value? differential expression p-value relate Moranâ€™s ?  Generally, significant marker genes tend higher Moranâ€™s . surprising clusters Moranâ€™s based k nearest neighbor graph.  Similarly, genes higher AUC tend higher Moranâ€™s . clusters, generally speaking, genes specific cluster tend higher Moranâ€™s . Letâ€™s use permutation testing see Moranâ€™s statistically significant:  seem significant. correlogram finds Moranâ€™s higher order neighbors can proxy distance.  see different patterns decay spatial autocorrelation different length scales spatial autocorrelation. CLU marker gene specific smallest cluster, higher order neighbors likely clusters. Marker genes larger clusters hundreds cells nevertheless display different patterns correlogram.","code":"sfe <- runMoransI(sfe, features = hvgs, BPPARAM = MulticoreParam(2)) rowData(sfe) #> DataFrame with 21932 rows and 6 columns #>                              ID      Symbol            Type subsets_mito #>                     <character> <character>     <character>    <logical> #> ENSG00000238009 ENSG00000238009  AL627309.1 Gene Expression        FALSE #> ENSG00000239945 ENSG00000239945  AL627309.3 Gene Expression        FALSE #> ENSG00000241599 ENSG00000241599  AL627309.4 Gene Expression        FALSE #> ENSG00000229905 ENSG00000229905  AL669831.2 Gene Expression        FALSE #> ENSG00000237491 ENSG00000237491  AL669831.5 Gene Expression        FALSE #> ...                         ...         ...             ...          ... #> ENSG00000278817 ENSG00000278817  AC007325.4 Gene Expression        FALSE #> ENSG00000278384 ENSG00000278384  AL354822.1 Gene Expression        FALSE #> ENSG00000277856 ENSG00000277856  AC233755.2 Gene Expression        FALSE #> ENSG00000275063 ENSG00000275063  AC233755.1 Gene Expression        FALSE #> ENSG00000271254 ENSG00000271254  AC240274.1 Gene Expression        FALSE #>                 moran_sample01 K_sample01 #>                      <numeric>  <numeric> #> ENSG00000238009             NA         NA #> ENSG00000239945             NA         NA #> ENSG00000241599             NA         NA #> ENSG00000229905             NA         NA #> ENSG00000237491             NA         NA #> ...                        ...        ... #> ENSG00000278817             NA         NA #> ENSG00000278384             NA         NA #> ENSG00000277856             NA         NA #> ENSG00000275063             NA         NA #> ENSG00000271254             NA         NA plotRowDataHistogram(sfe, \"moran_sample01\", bins = 50) +     geom_vline(data = as.data.frame(rowData(sfe)[top_markers,]) |>                     mutate(index = seq_along(top_markers)),                aes(xintercept = moran_sample01, color = index)) +     scale_color_continuous(breaks = scales::breaks_width(2)) #> Warning: Removed 19932 rows containing non-finite outside the scale range #> (`stat_bin()`). #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_vline()`). top_moran <- head(rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)], 4) plotSpatialFeature(sfe, top_moran, ncol = 2) top_moran_symbol <- rowData(sfe)[top_moran, \"Symbol\"] plotExpression(sfe, top_moran_symbol, swap_rownames = \"Symbol\") # See if markers are unique to clusters anyDuplicated(rownames(top_markers_df)) #> [1] 0 top_markers_df$moran <- rowData(sfe)[rownames(top_markers_df), \"moran_sample01\"] top_markers_df$log_p_adj <- -log10(top_markers_df$FDR) top_markers_df$cluster <- factor(top_markers_df$cluster,                                   levels = seq_len(length(unique(top_markers_df$cluster)))) as.data.frame(top_markers_df) |>      ggplot(aes(log_p_adj, moran)) +     geom_point(aes(color = cluster)) +     geom_smooth(method = \"lm\") +     scale_color_manual(values = ditto_colors) #> `geom_smooth()` using formula = 'y ~ x' #> Warning: Removed 633 rows containing non-finite outside the scale range #> (`stat_smooth()`). #> Warning: Removed 633 rows containing missing values or values outside the scale range #> (`geom_point()`). as.data.frame(top_markers_df) |>      ggplot(aes(summary.AUC, moran)) +     geom_point(aes(color = cluster)) +     geom_smooth(method = \"lm\") +     scale_color_manual(values = ditto_colors) #> `geom_smooth()` using formula = 'y ~ x' #> Warning: Removed 633 rows containing non-finite outside the scale range #> (`stat_smooth()`). #> Warning: Removed 633 rows containing missing values or values outside the scale range #> (`geom_point()`). sfe <- runUnivariate(sfe, \"moran.mc\", features = top_markers, nsim = 200) top_markers_symbol #> [1] \"TRAC\"   \"MNDA\"   \"RPL18\"  \"CD79A\"  \"CD74\"   \"AIF1\"   \"NKG7\"   \"MALAT1\" #> [9] \"PGRMC1\" plotMoranMC(sfe, top_markers, swap_rownames = \"Symbol\") system.time({     sfe <- runUnivariate(sfe, \"sp.correlogram\", top_markers, order = 6,                       zero.policy = TRUE, BPPARAM = MulticoreParam(2)) }) #>    user  system elapsed  #> 186.097   1.132 229.352 plotCorrelogram(sfe, top_markers, swap_rownames = \"Symbol\")"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"local-morans-i-1","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for gene expression","what":"Local Moranâ€™s I","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"also plot histograms, now results need added colData first.  , y axis log transformed make tail visible. clusters, top marker geneâ€™s local Moranâ€™s forms peak cells cluster higher local Moranâ€™s cells. However, sometimes cells within cluster form long tail shared cells clusters. local Moranâ€™s another method differential expression. since local Moranâ€™s Leiden clustering use k nearest neighbor graph PCA space, local Moranâ€™s marker genes perhaps eigengenes signifying gene programs cell type k nearest neighbor graph can validate criticize Leiden clusters. Furthermore, interestingly, genes, tallest peak histogram away 0. scatter plots shown â€œspatialâ€ analyses QC metrics section can made see local Moranâ€™s relates expression gene .  gene, just like total UMI counts, two wings central value local Moranâ€™s around 0. Generally, cells higher expression gene higher local Moranâ€™s gene well. density contours show cells concentrate around 0 expression weaker positive local Moran. streak cells 0 expression means many cells donâ€™t express gene, neighbors low slightly homogeneous expression gene. pattern may different different genes. Also, p-values cell local Moranâ€™s available corrected multiple hypothesis testing, can plotted. p-values based z score local Moran statistic, although statistic distributed gene expression data warrants investigation. p-value can also computed permutation (see localmoran_perm()).","code":"sfe <- runUnivariate(sfe, \"localmoran\", features = top_markers) plotLocalResult(sfe, \"localmoran\", top_markers, colGeometryName = \"centroids\",                  divergent = TRUE, diverge_center = 0, ncol = 3,                 swap_rownames = \"Symbol\") new_colname <- paste0(\"cluster\", seq_along(top_markers), \"_\",                        top_markers_symbol, \"_localmoran\") for (i in seq_along(top_markers)) {     g <- top_markers[i]     colData(sfe)[[new_colname[i]]] <-          localResult(sfe, \"localmoran\", g)[,\"Ii\"] } plotColDataFreqpoly(sfe, new_colname, color_by = \"cluster\") +     ggtitle(\"Local Moran's I\") +     theme(legend.position = \"top\") +     scale_y_log10() +     annotation_logticks(sides = \"l\") #> Warning in scale_y_log10(): log-10 transformation introduced #> infinite values. i <- 6 # Change if running this notebook plotExpression(sfe, top_markers_symbol[i], x = new_colname[i], color_by = \"cluster\",                swap_rownames = \"Symbol\") +     scale_color_manual(values = ditto_colors) +     coord_flip() +     # comment out in case of error after changing i     geom_density2d(data = as.data.frame(colData(sfe)) |>                         mutate(gene = logcounts(sfe)[top_markers[i],]),                    mapping = aes(x = .data[[new_colname[i]]], y = gene),                     color = \"blue\", linewidth = 0.3)  #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. localResultAttrs(sfe, \"localmoran\", top_markers[1]) #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\""},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"losh","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for gene expression","what":"LOSH","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"two genes right, â€™s interesting see higher LOSH middle cluster. two genes left outliers throwing dynamic range, seems high LOSH regions different. , plot histograms:  relationship expression LOSH complicated. genes, top marker gene cluster 1 LYAR, cells cluster higher expression also higher LOSH - much like Poisson negative binomial distributions, higher mean also means higher variance. However, genes, top marker gene cluster 2 CTSS, lower LOSH among cells higher expression, means expression gene homogeneous within cluster, consistent local Moran.  gene, density contour indicates many cells donâ€™t express gene homogeneous neighborhoods also low expression. streak around 0 expression means neighbors cells donâ€™t express gene different levels heterogeneity gene.","code":"sfe <- runUnivariate(sfe, \"LOSH\", top_markers) plotLocalResult(sfe, \"LOSH\", top_markers, colGeometryName = \"centroids\", ncol = 3,                 swap_rownames = \"Symbol\") new_colname2 <- paste0(\"cluster\", seq_along(top_markers), \"_\",                        top_markers_symbol, \"_losh\") for (i in seq_along(top_markers)) {     g <- top_markers[i]     colData(sfe)[[new_colname2[i]]] <-          localResult(sfe, \"LOSH\", g)[,\"Hi\"] } plotColDataFreqpoly(sfe, new_colname2, color_by = \"cluster\") +     ggtitle(\"Local heteroscedasticity\") +     theme(legend.position = \"top\") +     scale_y_log10() +     annotation_logticks(sides = \"l\") #> Warning in scale_y_log10(): log-10 transformation introduced #> infinite values. i <- 6 # Change if running this notebook plotExpression(sfe, top_markers_symbol[i], x = new_colname2[i],                 color_by = \"cluster\", swap_rownames = \"Symbol\") +     scale_color_manual(values = ditto_colors) +     coord_flip() +     # comment out in case of error after changing i     geom_density2d(data = as.data.frame(colData(sfe)) |>                         mutate(gene = logcounts(sfe)[top_markers[i],]),                    mapping = aes(x = .data[[new_colname2[i]]], y = gene),                     color = \"blue\", linewidth = 0.3)  #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale."},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"moran-plot-1","dir":"Articles","previous_headings":"â€œSpatialâ€ analyses for gene expression","what":"Moran plot","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"make Moran plots top marker genes. reference, show Moranâ€™s top marker genes, slope line fitted Moran scatter plot. significant marker gene cluster 7. plots shown sequence  genes, points concentrated around origin arenâ€™t â€œenoughâ€ points elsewhere plot density contours. cells express genes, clusters plot. genes expressed many cells, cells neighbors express gene, hence vertical streak x = 0. tutorial, applied univariate spatial statistics k nearest neighbor graph gene expression PCA space rather histological space. Just like histological space, impractical examine statistics gene gene, multivariate analyses incorporate k nearest neighbor graph may interesting.","code":"sfe <- runUnivariate(sfe, \"moran.plot\", features = top_markers, colGraphName = \"knn10\") top_markers_df[top_markers,] #> DataFrame with 9 rows and 6 columns #>                         FDR summary.AUC  cluster      symbol     moran #>                   <numeric>   <numeric> <factor> <character> <numeric> #> ENSG00000277734 3.37482e-13    0.975250        1        TRAC  0.768167 #> ENSG00000163563 4.66765e-15    1.000000        2        MNDA  0.955553 #> ENSG00000063177 2.11153e-16    1.000000        3       RPL18        NA #> ENSG00000105369 1.03673e-14    0.999937        4       CD79A  0.944921 #> ENSG00000019582 5.88269e-11    0.760702        5        CD74  0.865464 #> ENSG00000204472 1.55788e-12    1.000000        6        AIF1  0.884852 #> ENSG00000105374 1.58791e-14    0.999822        7        NKG7  0.931310 #> ENSG00000251562 7.40288e-12    0.998755        8      MALAT1  0.811310 #> ENSG00000101856 6.37250e-13    1.000000        9      PGRMC1  0.363735 #>                 log_p_adj #>                 <numeric> #> ENSG00000277734   12.4717 #> ENSG00000163563   14.3309 #> ENSG00000063177   15.6754 #> ENSG00000105369   13.9843 #> ENSG00000019582   10.2304 #> ENSG00000204472   11.8075 #> ENSG00000105374   13.7992 #> ENSG00000251562   11.1306 #> ENSG00000101856   12.1957 plts <- lapply(top_markers, moranPlot, sfe = sfe, color_by = \"cluster\",                 swap_rownames = \"Symbol\") #> Warning in value[[3L]](cond): Too few points for stat_density2d, not plotting #> contours. #> Warning in value[[3L]](cond): Too few points for stat_density2d, not plotting #> contours. wrap_plots(plts, widths = 1, heights = 1) +     plot_layout(ncol = 3, guides = \"collect\") +     plot_annotation(tag_levels = \"1\")"},{"path":"https://pachterlab.github.io/voyager/articles/nonspatial.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Apply spatial analyses to non-spatial scRNA-seq data","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] reticulate_1.40.0              dplyr_1.1.4                    #>  [3] patchwork_1.3.0                spdep_1.3-6                    #>  [5] sf_1.0-19                      spData_2.3.3                   #>  [7] BiocSingular_1.22.0            stringr_1.5.1                  #>  [9] BiocParallel_1.40.0            bluster_1.16.0                 #> [11] scran_1.34.0                   scater_1.34.0                  #> [13] ggplot2_3.5.1                  scuttle_1.16.0                 #> [15] BiocNeighbors_2.0.0            DropletUtils_1.26.0            #> [17] SpatialExperiment_1.16.0       SingleCellExperiment_1.28.1    #> [19] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [21] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [23] IRanges_2.40.0                 S4Vectors_0.44.0               #> [25] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [27] matrixStats_1.4.1              Voyager_1.8.1                  #> [29] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               DelayedMatrixStats_1.28.0 #>  [15] RCurl_1.98-1.16           terra_1.7-83              #>  [17] htmltools_0.5.8.1         S4Arrays_1.6.0            #>  [19] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [21] SparseArray_1.6.0         rhdf5_2.50.0              #>  [23] LearnBayes_2.15.1         sass_0.4.9                #>  [25] KernSmooth_2.23-24        bslib_0.8.0               #>  [27] htmlwidgets_1.6.4         desc_1.4.3                #>  [29] sandwich_3.1-1            zoo_1.8-12                #>  [31] cachem_1.1.0              igraph_2.1.1              #>  [33] lifecycle_1.0.4           pkgconfig_2.0.3           #>  [35] rsvd_1.0.5                Matrix_1.7-1              #>  [37] R6_2.5.1                  fastmap_1.2.0             #>  [39] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [41] colorspace_2.1-1          ggnewscale_0.5.0          #>  [43] irlba_2.3.5.1             dqrng_0.4.1               #>  [45] RSpectra_0.16-2           textshaping_0.4.0         #>  [47] beachmat_2.22.0           labeling_0.4.3            #>  [49] fansi_1.0.6               spatialreg_1.3-5          #>  [51] mgcv_1.9-1                httr_1.4.7                #>  [53] abind_1.4-8               compiler_4.4.2            #>  [55] proxy_0.4-27              withr_3.0.2               #>  [57] tiff_0.1-12               viridis_0.6.5             #>  [59] DBI_1.2.3                 HDF5Array_1.34.0          #>  [61] R.utils_2.12.3            MASS_7.3-61               #>  [63] DelayedArray_0.32.0       rjson_0.2.23              #>  [65] classInt_0.4-10           tools_4.4.2               #>  [67] units_0.8-5               vipor_0.4.7               #>  [69] beeswarm_0.4.0            R.oo_1.27.0               #>  [71] glue_1.8.0                nlme_3.1-166              #>  [73] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [75] grid_4.4.2                cluster_2.1.6             #>  [77] memuse_4.2-3              generics_0.1.3            #>  [79] isoband_0.2.7             gtable_0.3.6              #>  [81] R.methodsS3_1.8.2         class_7.3-22              #>  [83] data.table_1.16.2         metapod_1.14.0            #>  [85] ScaledMatrix_1.14.0       sp_2.1-4                  #>  [87] utf8_1.2.4                XVector_0.46.0            #>  [89] ggrepel_0.9.6             pillar_1.9.0              #>  [91] limma_3.62.1              splines_4.4.2             #>  [93] lattice_0.22-6            survival_3.7-0            #>  [95] deldir_2.0-4              tidyselect_1.2.1          #>  [97] locfit_1.5-9.10           sfheaders_0.4.4           #>  [99] knitr_1.49                gridExtra_2.3             #> [101] edgeR_4.4.0               xfun_0.49                 #> [103] statmod_1.5.0             stringi_1.8.4             #> [105] UCSC.utils_1.2.0          fftwtools_0.9-11          #> [107] yaml_2.3.10               boot_1.3-31               #> [109] evaluate_1.0.1            codetools_0.2-20          #> [111] tibble_3.2.1              cli_3.6.3                 #> [113] systemfonts_1.1.0         munsell_0.5.1             #> [115] jquerylib_0.1.4           Rcpp_1.0.13-1             #> [117] zeallot_0.1.0             coda_0.19-4.1             #> [119] png_0.1-8                 parallel_4.4.2            #> [121] pkgdown_2.1.1             jpeg_0.1-10               #> [123] sparseMatrixStats_1.18.0  bitops_1.0-9              #> [125] viridisLite_0.4.2         mvtnorm_1.3-2             #> [127] scales_1.3.0              e1071_1.7-16              #> [129] crayon_1.5.3              scico_1.5.0               #> [131] rlang_1.1.4               cowplot_1.1.3             #> [133] multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"10X Chromium v3 preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"10X Chromium v3 preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"preprocessing-for-chromium-v3-chemistry","dir":"Articles","previous_headings":"","what":"Preprocessing for Chromium V3 Chemistry","title":"10X Chromium v3 preprocessing with cellatlas","text":"data example located cellatlas/examples/rna-10xv3/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/rna-10xv3/* .\") system(\"gunzip 3M-february-2018.txt.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Chromium V3 Chemistry","what":"Fetch the references","title":"10X Chromium v3 preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf homo_sapiens\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium V3 Chemistry","what":"Build the pipeline","title":"10X Chromium v3 preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m rna\",     \"-fa\", FA,   \"-g\", GTF,   \"-fb\", \"feature_barcodes.txt\",   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium V3 Chemistry","what":"Run the pipeline","title":"10X Chromium v3 preprocessing with cellatlas","text":"run pipeline simply extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_10xv3.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Chromium V3 Chemistry","what":"Inspect the output","title":"10X Chromium v3 preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"preprocessing-for-chromium-single-cell-atac-seq","dir":"Articles","previous_headings":"","what":"Preprocessing for Chromium Single Cell ATAC-seq","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"data example located cellatlas/examples/atac-10xatac/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/atac-10xatac/* .\") system(\"gunzip *.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC-seq","what":"Fetch the references","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf homo_sapiens\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC-seq","what":"Build the pipeline","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m atac\",     \"-fa\", FA,   \"-g\", GTF,   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz fastqs/I2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC-seq","what":"Run the pipeline","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"run pipeline extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_trim(cmds) cmds <- str_remove_all(cmds, '\\\\\\\",$|\\\\\\\"$|^\\\\\\\"') cmds <- str_replace_all(cmds, fixed(\"\\\\\\\"\"), \"\\\"\") cmds <- str_replace_all(cmds, fixed(\"\\\\t\"), \"\\t\")  cmds lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_atac.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC-seq","what":"Inspect the output","title":"10X Chromium ATAC-seq preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"ClickTags preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"ClickTags preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"preprocessing-for-clicktags","dir":"Articles","previous_headings":"","what":"Preprocessing for ClickTags","title":"ClickTags preprocessing with cellatlas","text":"data example located cellatlas/examples/tag-clicktag/* directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/tag-clicktag/* .\") system(\"gunzip 737K-august-2016.txt.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for ClickTags","what":"Fetch the references","title":"ClickTags preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf homo_sapiens\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for ClickTags","what":"Build the pipeline","title":"ClickTags preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m tag\",     \"-fa\", FA,   \"-g\", GTF,   \"-fb\", \"feature_barcodes.txt\",   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for ClickTags","what":"Run the pipeline","title":"ClickTags preprocessing with cellatlas","text":"run pipeline simply extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_clicktag.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for ClickTags","what":"Inspect the output","title":"ClickTags preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"preprocessing-for-chromium-single-cell-crispr-screening","dir":"Articles","previous_headings":"","what":"Preprocessing for Chromium Single Cell CRISPR Screening","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"data example located cellatlas/examples/crispr-10xcrispr/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/crispr-10xcrispr/* .\") system(\"gunzip *.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell CRISPR Screening","what":"Fetch the references","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf homo_sapiens\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell CRISPR Screening","what":"Build the pipeline","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m crispr\",     \"-fa\", FA,   \"-g\", GTF,   \"-fb\", \"feature_barcodes.txt\",   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell CRISPR Screening","what":"Run the pipeline","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"run pipeline extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  cmds lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_crispr.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell CRISPR Screening","what":"Inspect the output","title":"10X Chromium CRISPR screening preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"10X Multiome ATAC preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"10X Multiome ATAC preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"preprocessing-for-chromium-single-cell-atac-multiome-atac","dir":"Articles","previous_headings":"","what":"Preprocessing for Chromium Single Cell ATAC Multiome ATAC","title":"10X Multiome ATAC preprocessing with cellatlas","text":"data example located cellatlas/examples/atac-10xmultiome/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/atac-10xmultiome/* .\") system(\"gunzip *.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC Multiome ATAC","what":"Fetch the references","title":"10X Multiome ATAC preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf mus_musculus\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC Multiome ATAC","what":"Build the pipeline","title":"10X Multiome ATAC preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m atac\",     \"-fa\", FA,   \"-g\", GTF,   \"fastqs/atac_R1.fastq.gz fastqs/atac_R2.fastq.gz fastqs/atac_I2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC Multiome ATAC","what":"Run the pipeline","title":"10X Multiome ATAC preprocessing with cellatlas","text":"run pipeline extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_trim(cmds) cmds <- str_remove_all(cmds, '\\\\\\\",$|\\\\\\\"$|^\\\\\\\"') cmds <- str_replace_all(cmds, fixed(\"\\\\\\\"\"), \"\\\"\") cmds <- str_replace_all(cmds, fixed(\"\\\\t\"), \"\\t\")  cmds lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_multiome.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Chromium Single Cell ATAC Multiome ATAC","what":"Inspect the output","title":"10X Multiome ATAC preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"10X Chromium nuclei preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"10X Chromium nuclei preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"preprocessing-for-chromium-nuclei-isolation","dir":"Articles","previous_headings":"","what":"Preprocessing for Chromium Nuclei Isolation","title":"10X Chromium nuclei preprocessing with cellatlas","text":"data example located cellatlas/examples/rna-10xv3-nuclei/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/rna-10xv3-nuclei/* .\") system(\"gunzip *.gz\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Chromium Nuclei Isolation","what":"Fetch the references","title":"10X Chromium nuclei preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf homo_sapiens\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Nuclei Isolation","what":"Build the pipeline","title":"10X Chromium nuclei preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.homo_sapiens.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m rna\",     \"-fb feature_barcodes.txt\",   \"-fa\", FA,   \"-g\", GTF,   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Chromium Nuclei Isolation","what":"Run the pipeline","title":"10X Chromium nuclei preprocessing with cellatlas","text":"run pipeline extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  cmds lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_nuclei.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Chromium Nuclei Isolation","what":"Inspect the output","title":"10X Chromium nuclei preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"Split-seq preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"Split-seq preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"preprocessing-for-split-seq","dir":"Articles","previous_headings":"","what":"Preprocessing for SPLiT-seq","title":"Split-seq preprocessing with cellatlas","text":"Note: move relevant data working directory gunzip barcode onlist. data example located cellatlas/examples/rna-splitseq/ directory. seqspec print command prints ordered tree representation sequenced elements contained FASTQ files. Note names nodes seqspec must match names FASTQ files. seqspec SPLiT-seq contains specification multiple split-pool rounds. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/rna-splitseq/* .\") system(\"gunzip barcode*\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for SPLiT-seq","what":"Fetch the references","title":"Split-seq preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf mus_musculus\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for SPLiT-seq","what":"Build the pipeline","title":"Split-seq preprocessing with cellatlas","text":"","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m rna\",     \"-fa\", FA,   \"-g\", GTF,   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for SPLiT-seq","what":"Run the pipeline","title":"Split-seq preprocessing with cellatlas","text":"run pipeline simply extract commands /cellatlas_info.json run command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_splitseq.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for SPLiT-seq","what":"Inspect the output","title":"Split-seq preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"building-count-matrices-with-cellatlas","dir":"Articles","previous_headings":"","what":"Building Count Matrices with cellatlas","title":"Visium preprocessing with cellatlas","text":"major challenge uniformly preprocessing large amounts single-cell genomics data variety different assays identifying handling sequenced elements coherent consistent fashion. Cell barcodes reads RNAseq data 10x Multiome, example, must extracted error corrected manner cell barcodes reads ATACseq data 10x Multiome barcode-barcode registration can occur. Uniform processing way minimzes computational variability enables cross-assay comparisons. notebook demonstrate single-cell genomics data can preprocessed generate cell feature count matrix. requires: FASTQ files seqspec specification FASTQ files Genome Sequence FASTA Genome Annotation GTF (optional) Feature barcode list","code":""},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"install-packages","dir":"Articles","previous_headings":"","what":"Install Packages","title":"Visium preprocessing with cellatlas","text":"vignette makes use two non-standard command line tools, jq tree. code cell installs tools Linux operating system updated Mac Windows users. continue dependencies can installed operating system.","code":"# Install `jq`, a command-line tool for extracting key value pairs from JSON files  system(\"wget --quiet --show-progress https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\") system(\"chmod +x jq-linux64 && mv jq-linux64 /usr/local/bin/jq\") # Clone the cellatlas repo and install the package system(\"git clone https://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@github.com/cellatlas/cellatlas.git\") system(\"cd cellatlas && pip install .\")  # Install dependencies system(\"yes | pip uninstall --quiet seqspec\") system(\"pip install --quiet git+https://github.com/IGVF/seqspec.git\") system(\"pip install --quiet gget kb-python\")"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"examine-the-spec","dir":"Articles","previous_headings":"Preprocessing for Visium","what":"Examine the spec","title":"Visium preprocessing with cellatlas","text":"Note: move relevant data working directory gunzip barcode onlist. first use seqspec print check read structure matches expect. command prints ordered tree representation sequenced elements contained FASTQ files. Note names nodes seqspec must match names FASTQ files. Note Google Colab, go Runtime -> View runtime logs see output system.","code":"system(\"mv cellatlas/examples/rna-visium-spatial/* .\") system(\"seqspec print spec.yaml\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"fetch-the-references","dir":"Articles","previous_headings":"Preprocessing for Visium","what":"Fetch the references","title":"Visium preprocessing with cellatlas","text":"step necessary modality processing uses transcriptome reference-based alignment.","code":"system(\"gget ref -o ref.json -w dna,gtf mus_musculus\")"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"build-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Visium","what":"Build the pipeline","title":"Visium preprocessing with cellatlas","text":"now supply relevant objects cellatlas build produce appropriate commands run build pipeline. includes reference building step read counting quantification step performed kallisto bustools part kb-python package.","code":"FA <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.genome_dna.ftp'\", \"ref.json\"),   stdout = TRUE)  GTF <- system2(\"jq\",   args = c(\"-r\", \"'.mus_musculus.annotation_gtf.ftp'\", \"ref.json\"),   stdout = TRUE) args <- c(   \"-o out\",    \"-s spec.yaml\",   \"-m rna\",     \"-fa\", FA,   \"-g\", GTF,   \"fastqs/R1.fastq.gz fastqs/R2.fastq.gz\")  system2(command = \"cellatlas\", args = c(\"build\", args))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"run-the-pipeline","dir":"Articles","previous_headings":"Preprocessing for Visium","what":"Run the pipeline","title":"Visium preprocessing with cellatlas","text":"can extract view commands pipeline using jq. Now can run commands /cellatlas_info.json command line.","code":"cmds <- system2(\"jq\", \"-r '.commands[] | values[]' out/cellatlas_info.json\", stdout=TRUE) cmds <- str_subset(cmds, \"[\\\\[\\\\]]\", negate=TRUE) cmds <- str_extract(cmds, \"kb.*(txt|gz)\")  cmds lapply(cmds, function(cmd) system(cmd))"},{"path":"https://pachterlab.github.io/voyager/articles/preprocess_visium.html","id":"inspect-the-output","dir":"Articles","previous_headings":"Preprocessing for Visium","what":"Inspect the output","title":"Visium preprocessing with cellatlas","text":"inspect /run_info.json /kb_info.json simple QC pipeline.","code":"list.files(\"out\") rjson::fromJSON(file = \"out/run_info.json\")"},{"path":"https://pachterlab.github.io/voyager/articles/seqfish_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"seqFISH Processing Workflows with Voyager","text":"Pros: Single cell resolution High detection efficiency Commercial kit coming Get subcellular transcript localization information Compatible histological features DAPI membrane staining Cons: Need pre-select panel usually hundred genes","code":""},{"path":"https://pachterlab.github.io/voyager/articles/seqfish_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"seqFISH Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked available.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/sfemethod.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Use your own spatial method in Voyager","text":"multiple different ways certain things. different ways pros cons, sometimes can tell somewhat different stories. Often different ways come different syntaxes, increasing learning curve users. Voyager took inspiration caret tidymodels (Kuhn2020-fm?) machine learning, foreach, future, BiocParallel parallel processing different backends, bluster different clustering algorithms, BiocNeighbors different algorithms find nearest neighbors. packages provide uniform user interfaces different methods achieve given goal. caret tidymodels, users can make uniform user interface fit custom models included package eliminate lot duplicate code. Voyager, done SFEMethod S4 class. vignette shows use SFEMethod class use Voyagerâ€™s uniform user interface custom methods. load packages used: Voyager categorizes exploratory spatial data analysis (ESDA) methods number variables whether method gives one result entire dataset (global) gives results location (local). process create SFEMethod object mostly across categories, category specific arguments. Also, make SFEMethod object, see method interest already Voyager. methods can listed listSFEMethods() function. calling calculate*variate() run*variate(), type (2nd) argument takes either SFEMethod object string matches entry name column data frame returned listSFEMethods() Voyager search S4 object name matching string.","code":"library(Voyager) #> Loading required package: SpatialFeatureExperiment #>  #> Attaching package: 'SpatialFeatureExperiment' #> The following object is masked from 'package:base': #>  #>     scale library(spdep) #> Loading required package: spData #> To access larger datasets in this package, install the spDataLarge #> package with: `install.packages('spDataLarge', #> repos='https://nowosad.github.io/drat/', type='source')` #> Loading required package: sf #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/sfemethod.html","id":"global","dir":"Articles","previous_headings":"Univariate","what":"Global","title":"Use your own spatial method in Voyager","text":"univariate global methods Voyager: code used create SFEMethod object run Moranâ€™s , SFEMethod() constructor: package argument used check package installed method run. function run method fun argument. univariate methods use spatial neighborhood graph (use_graph = TRUE) must arguments: x vector input listw spatial neighborhood graph listw object, zero.policy cells spots donâ€™t spatial neighbors. See spdep documentation (e.g.Â spdep::moran()) zero.policy argument behaves. case wrote think wrapper fill confusing arguments may confuse users. function running method another package different arguments, write thin wrapper make required arguments. Extra arguments can passed fun .... reorganize_fun argument takes function reorganize output fun form DataFrame results genes can added rowData(sfe). Moranâ€™s , function univariate bivariate global methods, function must : argument take output fun multiple genes features name take name results stored case method run genes different parameters donâ€™t want overwrite previous results. name name specified SFEMethod() constructor default, can set user calling calculate*variate() run*variate(), ... reorganize_fun univariate global methods Voyager, sp.correlogram, needs arguments. spatial methods use spatial distances rather graphs, variogram. code used create SFEMethod object variogram: function fun univariate methods donâ€™t use spatial neighborhood graph must arguments x coords_df (sf data frame spatial coordinates) arguments allowed. .variogram function: rule reorganize_fun remains , .other2df function:","code":"listSFEMethods(\"uni\", \"global\") #>              name                                           description #> 1           moran                                             Moran's I #> 2           geary                                             Geary's C #> 3        moran.mc                    Moran's I with permutation testing #> 4        geary.mc                    Geary's C with permutation testing #> 5    sp.mantel.mc Mantel-Hubert spatial general cross product statistic #> 6      moran.test                                        Moran's I test #> 7      geary.test                                        Geary's C test #> 8    globalG.test                                         Global G test #> 9  sp.correlogram                                           Correlogram #> 10      variogram                                  Variogram with model #> 11  variogram_map                                         Variogram map moran <- SFEMethod(     name = \"moran\", title = \"Moran's I\", package = \"spdep\",      variate = \"uni\", scope = \"global\",     fun = function(x, listw, zero.policy = NULL)         spdep::moran(x, listw, n = length(listw$neighbours), S0 = spdep::Szero(listw),                      zero.policy = zero.policy),     use_graph = TRUE,     reorganize_fun = .moran2df ) .moran2df <- function(out, name, ...) {     rns <- names(out)     out <- lapply(out, unlist, use.names = TRUE)     out <- Reduce(rbind, out)     if (!is.matrix(out)) out <- t(as.matrix(out))     rownames(out) <- rns     out <- DataFrame(out)     names(out)[1] <- name     out } variogram <- SFEMethod(package = \"automap\", variate = \"uni\", scope = \"global\",                        default_attr = NA, name = \"variogram\", title = \"Variogram\",                        fun = .variogram,                        reorganize_fun = .other2df,                        use_graph = FALSE) .variogram <- function(x, coords_df, formula = x ~ 1, scale = TRUE, ...) {     coords_df$x <- x     if (scale) coords_df$x <- scale(coords_df$x)     dots <- list(...)     # Deal with alpha myself and fit a global variogram to avoid further gstat warnings     have_alpha <- \"alpha\" %in% names(dots)     if (have_alpha) {         empirical <- gstat::variogram(formula, data = coords_df, alpha = dots$alpha)         dots$alpha <- NULL     }     out <- do.call(automap::autofitVariogram,                    c(list(formula = formula, input_data = coords_df,                           map = FALSE, cloud = FALSE), dots))     if (have_alpha) {         out$exp_var <- empirical     }     out } .other2df <- function(out, name, ...) {     if (!is.atomic(out)) out <- I(out)     out_df <- DataFrame(res = out)     names(out_df) <- name     rownames(out_df) <- names(out)     out_df }"},{"path":"https://pachterlab.github.io/voyager/articles/sfemethod.html","id":"local","dir":"Articles","previous_headings":"Univariate","what":"Local","title":"Use your own spatial method in Voyager","text":"univariate local methods Voyager: code used create SFEMethod object localmoran: spdep::localmoran already right arguments, including x, listw, zero.policy. local methods, title default_attr arguments important, used plotLocalResults() plot title. Many local methods return matrix data frame results gene, default_attr specifies column use default plotting, local Moranâ€™s values (Ii) case. fields results can p-values adjusted p-values. reorganize_fun different univariate global methods local results organized differently. .localmoran2df function: function must arguments: results fun genes, list element results one gene. nb neighbor object class nb, part listw object spatial neighborhood graphs. used correct multiple hypothesis testing p.adjustSP() p.adjust.method specify method correct multiple testing. See p.adjust() available methods. output list organized results, element one gene, converted DataFrame added localResults(sfe).","code":"listSFEMethods(\"uni\", \"local\") #>               name                                          description #> 1       localmoran                                      Local Moran's I #> 2  localmoran_perm                  Local Moran's I permutation testing #> 3           localC                                      Local Geary's C #> 4      localC_perm                  Local Geary's C permutation testing #> 5           localG                                      Getis-Ord Gi(*) #> 6      localG_perm             Getis-Ord Gi(*) with permutation testing #> 7             LOSH                     Local spatial heteroscedasticity #> 8          LOSH.mc Local spatial heteroscedasticity permutation testing #> 9          LOSH.cs     Local spatial heteroscedasticity Chi-square test #> 10      moran.plot                                   Moran scatter plot localmoran <- SFEMethod(     name = \"localmoran\", title = \"Local Moran's I\",     package = \"spdep\", scope = \"local\", default_attr = \"Ii\",     fun = spdep::localmoran,     use_graph = TRUE,     reorganize_fun = .localmoran2df ) .localmoran2df <- function(out, nb, p.adjust.method) {     lapply(out, function(o) {         o1 <- as.data.frame(o)         quadr <- attr(o, \"quadr\")         I(.add_log_p(cbind(o1, quadr), nb, p.adjust.method))     }) }"},{"path":"https://pachterlab.github.io/voyager/articles/sfemethod.html","id":"bivariate","dir":"Articles","previous_headings":"","what":"Bivariate","title":"Use your own spatial method in Voyager","text":"bivariate global methods Voyager: bivariate local methods Voyager: SFEMethod construction bivariate methods similar univariate methods, except function fun must argument y x. code used create SFEMethod object lee, Leeâ€™s L: Note use_matrix argument, specific bivariate methods. means whether method can take matrix argument compute statistic pairwise combinations matrixâ€™s rows. way computation can expressed matrix operations much efficient R loops loops pushed underlying C Fortran code BLAS Matrix package sparse matrices. â€™s .lee_mat function: Due matrix operation, listw can sparse dense adjacency matrix spatial neighborhood graph. conform scRNA-seq conventions, x y genes rows matrices. reorganize_fun bivariate global methods donâ€™t return DataFrame, bivariate global results canâ€™t stored SFE object. However, reorganize_fun bivariate local methods follow rules univariate local methods results also go localResults(sfe).","code":"listSFEMethods(\"bi\", \"global\") #>                  name                                     description #> 1                 lee                       Lee's bivariate statistic #> 2              lee.mc Lee's bivariate static with permutation testing #> 3            lee.test                                    Lee's L test #> 4     cross_variogram                                 Cross variogram #> 5 cross_variogram_map                             Cross variogram map listSFEMethods(\"bi\", \"local\") #>            name                     description #> 1      locallee Local Lee's bivariate statistic #> 2 localmoran_bv       Local bivariate Moran's I lee <- SFEMethod(name = \"lee\", fun = .lee_mat, title = \"Lee's bivariate statistic\",                  reorganize_fun = function(out, name, ...) out,                  package = \"Voyager\", variate = \"bi\", scope = \"global\",                  use_matrix = TRUE) .lee_mat <- function(x, y = NULL, listw, zero.policy = TRUE, ...) {     # X has genes in rows     if (is(listw, \"listw\"))         W <- listw2sparse(listw)     else W <- listw     x <- .scale_n(x)     if (!is.null(y)) {         y <- .scale_n(y)     } else y <- x     n <- ncol(x) # dimension of y is checked in calculateBivariate     out <- x %*% (t(W) %*% W) %*% t(y)/sum(rowSums(W)^2) * n     if (all(dim(out) == 1L)) out <- out[1,1]     out }"},{"path":"https://pachterlab.github.io/voyager/articles/sfemethod.html","id":"multivariate","dir":"Articles","previous_headings":"","what":"Multivariate","title":"Use your own spatial method in Voyager","text":"multivariate methods Voyager: SFEMethod construction bivariate methods similar univariate methods, except two arguments: joint indicate whether makes sense run method multiple samples jointly just like non-spatial PCA, dest indicate whether results go reducedDims(sfe) colData(sfe). code multivariate generalization local Gearyâ€™s C (Anselin2019-uv?) permutation testing: results, single vector, goes colData(sfe), make sense run across multiple samples jointly sample separate spatial neighborhood graph, run sample separately. function reorganize_fun return vector, matrix, data frame ready added reducedDims(sfe) colData(sfe). results can go colData, rules arguments univariate local methods, permutation testing multivariate local Gearyâ€™s C, multiple testing correction performed reorganize_fun. results go reducedDims, needs one argument output.","code":"listSFEMethods(\"multi\") #>                name                                      description #> 1        multispati                                   MULTISPATI PCA #> 2      localC_multi                     Multivariate local Geary's C #> 3 localC_perm_multi Multivariate local Geary's C permutation testing .localC_multi_fun <- function(perm = FALSE) {     function(x, listw, ..., zero.policy) {         x <- as.matrix(x)         fun <- if (perm) spdep::localC_perm else spdep::localC         fun(x, listw = listw, zero.policy = zero.policy, ...)     } }  .localCpermmulti2df <- function(out, nb, p.adjust.method) {     .attrmat2df(list(out), \"pseudo-p\", \"localC_perm_multi\", nb, p.adjust.method)[[1]] }  localC_perm_multi <- SFEMethod(     name = \"localC_perm_multi\", title = \"Multivariate local Geary's C permutation testing\",     package = \"spdep\", variate = \"multi\", default_attr = \"localC\",     fun = .localC_multi_fun(TRUE),     reorganize_fun = .localCpermmulti2df,     dest = \"colData\" )"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/slideseqV2_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"Slide-seqV2 Processing Workflows with Voyager","text":"Pros: Higher resolution Visium, beads 10 Î¼\\mum diameter Transcriptome wide Recently commercialized Curio, commercial kit coming Cons: Still single cell resolution two cells can occupy bead Relatively low detection efficiency transcripts Existing datasets may come histology image","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/slideseqV2_landing.html","id":"dowload-data-and-create-a-spatialfeatureexperiment-object","dir":"Articles","previous_headings":"Getting Started","what":"Dowload Data and Create a SpatialFeatureExperiment object","title":"Slide-seqV2 Processing Workflows with Voyager","text":"vignettes demonstrate convert sequencing data spatial transcriptomics experiment SpatialFeatureExperiment object R. Many technologies yet standardized output formats, vignettes provide examples generate SFE object various output file types.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/slideseqV2_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"Slide-seqV2 Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using data generated Slide-seqV2 platform. analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked available.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/splitseq_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"SPLiT-seq Processing Workflows with Voyager","text":"Pros: Commercial kit Low cost Single well capture randomly primed polyT oligos library Cons: * Fewer datasets available compared single cell technologies","code":""},{"path":"https://pachterlab.github.io/voyager/articles/splitseq_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"SPLiT-seq Processing Workflows with Voyager","text":"vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix. process output various transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/splitseq_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"SPLiT-seq Processing Workflows with Voyager","text":"analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Google Colab notebooks linked.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Variogram","text":"geostatistical data, underlying spatial process sampled known locations. Kriging uses Gaussian process model interpolate values sample locations, semivariogram used model spatial dependency locations covariance Gaussian process. kriging, semivariogram can used exploratory data analysis tool find length scale anisotropy spatial autocorrelation. semivariogram defined Î³(t)=12Var(Xtâˆ’X0), \\gamma(t) = \\frac 1 2 \\mathrm{Var}(X_t - X_0), XX value gene expression, tt spatial vector. X0X_0 value location interest, XtX_t value lagged tt. positive spatial autocorrelation, variance smaller among nearby values, variogram increase distance, eventually leveling distance beyond length scale spatial autocorrelation. â€œsemiâ€ comes 1/2, comes assumption Gaussian process weakly stationary, .e.Â covariance two locations depends spatial lag : Var(Xt2âˆ’Xt1)=Var(Xt2)+Var(Xt1)âˆ’2Cov(Xt2,Xt1)=2Ï(0)âˆ’2Ï(t2âˆ’t1),\\begin{align} \\mathrm{Var}(X_{t_2} - X_{t_1}) &= \\mathrm{Var}(X_{t_2}) + \\mathrm{Var}(X_{t_1}) - 2\\mathrm{Cov}(X_{t_2}, X_{t_1}) \\\\ &= 2\\rho(0) - 2\\rho(t_2 - t_1), \\end{align} Ï\\rho covariance function t1t_1 t2t_2 spatial locations. model can fitted empirical semivariogram, model Ï\\rho. variance differences value across locations depends spatial lag means intrinsically stationary, even weaker generalizable weakly stationary. weaker assumption used kriging. vignette demonstrates variogram ESDA tool, including interpretation univariate variogram, anisotropic variograms (variograms different directions), variogram maps, bivariate cross variograms. load packages: Slide-seq melanoma metastasis data (Biermann2022-cu?) used demonstration. QC performed another vignette. Variograms demonstrated top highly variable genes (HVGs)","code":"library(Voyager) library(SFEData) library(SpatialFeatureExperiment) library(scater) library(scran) library(ggplot2) library(BiocParallel) library(bluster) library(dplyr) theme_set(theme_bw()) (sfe <- BiermannMelaMetasData(dataset = \"MBM05_rep1\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 27566 29536  #> metadata(0): #> assays(1): counts #> rownames(27566): A1BG A1BG-AS1 ... ZZZ3 snoZ196 #> rowData names(3): means vars cv2 #> colnames(29536): ACCACTCATTTCTC-1 GTTCANTCCACGTA-1 ... ACGCGCAATCGTAG-1 #>   TTGTTCCGTTCATA-1 #> colData names(4): sample_id nCounts nGenes prop_mito #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : xcoord ycoord #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01: sfe <- sfe[, colData(sfe)$prop_mito < 0.1] sfe <- sfe[rowSums(counts(sfe)) > 0,] sfe <- logNormCounts(sfe) dec <- modelGeneVar(sfe) hvgs <- getTopHVGs(dec, n = 50)"},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"variogram","dir":"Articles","previous_headings":"","what":"Variogram","title":"Variogram","text":"user interface used run Moranâ€™s can used compute variograms. However, since variogram uses spatial distances instead spatial neighborhood graph, colGraph need specified. Instead, colGeometry can specified, geometry POINT, spatialCoords(sfe) used compute distances. Behind scene, automap package used, fits number different variogram models empirical variogram chooses one fits best. automap package user friendly wrapper gstat, time honored package geostatistics.  data binned distance spots variance computed bin. gstatâ€™s plotting functions say â€œsemivarianceâ€, data scaled variance 1, think variance rather semivariance plotted. numbers points plot indicate number pairs spots bin. â€œSteâ€ means Matern model M. Steinâ€™s parameterization fitted points. Nugget variance distance 0, variance within first distance bin. data scaled default prior variogram computation make variograms multiple genes comparable. Spatial autocorrelation makes variance smaller shorter distances. variogram levels , means spatial autocorrelation longer effect distance. Sill variance variogram levels . Range distance variogram levels . first 4 genes, IGHG3 IGKC seem stronger spatial autocorrelation dissipate 100 200 units (whether â€™s microns pixels unclear publication), whereas spatial autocorrelation B2M MT-RNR1 much weaker longer length scale. genes plotted space:  length scales spatial autocorrelation genes quite obvious just plotting genes. â€™s point plotting variograms ESDA? can also compute variograms larger number genes cluster variograms patterns spatial autocorrelation length scales, compare variograms genes across different samples. cluster variograms top highly variable genes (HVGs): BLUSPARAM argument used specify methods clustering, implemented bluster package. use hierarchical clustering. plot clusters:  seems many genes, like MT-RNR1, weak spatial autocorrelation longer length scales, genes stronger shorter range spatial autocorrelation (around 150 200 units) like IGKC, genes somewhat longer length scale spatial autocorrelation (around 400 units). Plot one gene cluster space:  MT-RNR1 widely expressed. IGKC ICHC3 restricted smaller areas, IGHM restricted even smaller areas. Note genes variograms cluster donâ€™t co-expressed; need similar length scales strengths spatial autocorrelation.","code":"sfe <- runUnivariate(sfe, \"variogram\", hvgs, BPPARAM = SnowParam(2),                      model = \"Ste\") #> Warning: <anonymous>: ... may be used in an incorrect context: 'fun(x[i, ], ...)' plotVariogram(sfe, hvgs[1:4], name = \"variogram\") plotSpatialFeature(sfe, hvgs[1:4], size = 0.3) &      theme_bw() # To show the length units clusts <- clusterVariograms(sfe, hvgs, BLUSPARAM = HclustParam()) plotVariogram(sfe, hvgs, color_by = clusts, group = \"feature\", use_lty = FALSE,               show_np = FALSE) genes_clusts <- clusts |>      group_by(cluster) |>      slice_head(n = 1) |>      pull(feature) plotSpatialFeature(sfe, genes_clusts, size = 0.3)"},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"anisotropy","dir":"Articles","previous_headings":"","what":"Anisotropy","title":"Variogram","text":"Anisotropy means different different directions. example cerebral cortex, layered structure. variogram can computed different directions.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"anisotropic-variogram","dir":"Articles","previous_headings":"Anisotropy","what":"Anisotropic variogram","title":"Variogram","text":"directions compute variograms can explicitly specified, alpha argument. However, since gstat fit anisotropic variograms, model fitted directions empirical variograms angle plotted separately. compute anisotropic variograms 4 genes :  line variogram model fitted directions text describes model. points show angles different colors. Zero degree points north (), angles go clockwise.","code":"sfe <- runUnivariate(sfe, \"variogram\", genes_clusts, alpha = c(0, 45, 90, 135),                      # To not to overwrite omnidirectional variogram results                      name = \"variogram_anis\", model = \"Ste\",                       BPPARAM = SnowParam(2)) #> gstat does not fit anisotropic variograms. Variogram model is fitted to the whole dataset. #> Warning: <anonymous>: ... may be used in an incorrect context: 'fun(x[i, ], ...)' plotVariogram(sfe, genes_clusts, group = \"angle\", name = \"variogram_anis\",               show_np = FALSE)"},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"variogram-map","dir":"Articles","previous_headings":"Anisotropy","what":"Variogram map","title":"Variogram","text":"variogram map another way visualize spatial autocorrelation different directions. bins distances x distances y, grid distances variance computed. Just like variograms , origin usually low value, spatial autocorrelation reduces variance short distance, values increase increasing distance origin, can increase quickly directions others. compute variogram maps 4 genes : width argument width bins, cutoff maximum distance.","code":"sfe <- runUnivariate(sfe, \"variogram_map\", genes_clusts, width = 100,                       cutoff = 800, BPPARAM = SnowParam(2), name = \"variogram_map2\") #> Warning: <anonymous>: ... may be used in an incorrect context: 'fun(x[i, ], ...)' plotVariogramMap(sfe, genes_clusts, name = \"variogram_map2\")"},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"cross-variogram","dir":"Articles","previous_headings":"","what":"Cross variogram","title":"Variogram","text":"cross variogram used cokriging, uses multiple variables spatial interpolation model. cross variogram defined Î³(t)=12Cov(Xtâˆ’X0,Ytâˆ’Y0), \\gamma(t) = \\frac 1 2 \\mathrm{Cov}(X_t - X_0, Y_t - Y_0), YY another variable. cross variogram also nugget, sill, range. shows covariance two variables changes distance. Voyager supports multiple bivariate spatial methods, cross variogram one . Just like univariate spatial methods, Voyager provides uniform user interface bivariate methods. However, bivariate local methods canâ€™t stored SFE object present tend different formats outputs (e.g.Â correlation matrix Leeâ€™s L list methods) may straightforward store SFE object.  facets shown matrix, whose diagonal variogram gene, diagonal entries cross variograms. IGKC IGHG3, length scale covariance similar spatial autocorrelation. also cross variogram map show cross variogram different directions:","code":"cross_v <- calculateBivariate(sfe, \"cross_variogram\",                                feature1 = \"IGKC\", feature2 = \"IGHG3\") plotCrossVariogram(cross_v, show_np = FALSE) cross_v_map <- calculateBivariate(sfe, \"cross_variogram_map\",                                   feature1 = \"IGKC\", feature2 = \"IGHG3\",                                   width = 100, cutoff = 800) plotCrossVariogramMap(cross_v_map)"},{"path":"https://pachterlab.github.io/voyager/articles/variogram.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Variogram","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] dplyr_1.1.4                    bluster_1.16.0                 #>  [3] BiocParallel_1.40.0            scran_1.34.0                   #>  [5] scater_1.34.0                  ggplot2_3.5.1                  #>  [7] scuttle_1.16.0                 SingleCellExperiment_1.28.1    #>  [9] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [11] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [13] IRanges_2.40.0                 S4Vectors_0.44.0               #> [15] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [17] matrixStats_1.4.1              SFEData_1.8.0                  #> [19] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               xts_0.14.1                #>   [7] lifecycle_1.0.4           sf_1.0-19                 #>   [9] edgeR_4.4.0               lattice_0.22-6            #>  [11] MASS_7.3-61               magrittr_2.0.3            #>  [13] limma_3.62.1              sass_0.4.9                #>  [15] rmarkdown_2.29            jquerylib_0.1.4           #>  [17] yaml_2.3.10               metapod_1.14.0            #>  [19] sp_2.1-4                  RColorBrewer_1.1-3        #>  [21] DBI_1.2.3                 multcomp_1.4-26           #>  [23] abind_1.4-8               spatialreg_1.3-5          #>  [25] zlibbioc_1.52.0           purrr_1.0.2               #>  [27] R.utils_2.12.3            RCurl_1.98-1.16           #>  [29] TH.data_1.1-2             rappdirs_0.3.3            #>  [31] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [33] ggrepel_0.9.6             irlba_2.3.5.1             #>  [35] terra_1.7-83              units_0.8-5               #>  [37] RSpectra_0.16-2           dqrng_0.4.1               #>  [39] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [41] codetools_0.2-20          DropletUtils_1.26.0       #>  [43] DelayedArray_0.32.0       gstat_2.1-2               #>  [45] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [47] memuse_4.2-3              farver_2.1.2              #>  [49] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [51] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [53] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [55] survival_3.7-0            systemfonts_1.1.0         #>  [57] tools_4.4.2               ggnewscale_0.5.0          #>  [59] ragg_1.3.3                snow_0.4-4                #>  [61] Rcpp_1.0.13-1             glue_1.8.0                #>  [63] gridExtra_2.3             SparseArray_1.6.0         #>  [65] xfun_0.49                 EBImage_4.48.0            #>  [67] HDF5Array_1.34.0          withr_3.0.2               #>  [69] BiocManager_1.30.25       fastmap_1.2.0             #>  [71] ggh4x_0.2.8               boot_1.3-31               #>  [73] rhdf5filters_1.18.0       fansi_1.0.6               #>  [75] spData_2.3.3              digest_0.6.37             #>  [77] rsvd_1.0.5                mime_0.12                 #>  [79] R6_2.5.1                  textshaping_0.4.0         #>  [81] colorspace_2.1-1          wk_0.9.4                  #>  [83] LearnBayes_2.15.1         jpeg_0.1-10               #>  [85] RSQLite_2.3.8             R.methodsS3_1.8.2         #>  [87] intervals_0.15.5          utf8_1.2.4                #>  [89] generics_0.1.3            data.table_1.16.2         #>  [91] FNN_1.1.4.1               class_7.3-22              #>  [93] httr_1.4.7                htmlwidgets_1.6.4         #>  [95] S4Arrays_1.6.0            spdep_1.3-6               #>  [97] pkgconfig_2.0.3           scico_1.5.0               #>  [99] gtable_0.3.6              blob_1.2.4                #> [101] XVector_0.46.0            htmltools_0.5.8.1         #> [103] fftwtools_0.9-11          automap_1.1-12            #> [105] scales_1.3.0              png_0.1-8                 #> [107] SpatialExperiment_1.16.0  knitr_1.49                #> [109] rjson_0.2.23              spacetime_1.3-2           #> [111] coda_0.19-4.1             nlme_3.1-166              #> [113] curl_6.0.1                proxy_0.4-27              #> [115] cachem_1.1.0              zoo_1.8-12                #> [117] rhdf5_2.50.0              BiocVersion_3.20.0        #> [119] KernSmooth_2.23-24        vipor_0.4.7               #> [121] parallel_4.4.2            AnnotationDbi_1.68.0      #> [123] desc_1.4.3                s2_1.1.7                  #> [125] reshape_0.8.9             pillar_1.9.0              #> [127] grid_4.4.2                vctrs_0.6.5               #> [129] BiocSingular_1.22.0       dbplyr_2.5.0              #> [131] beachmat_2.22.0           sfheaders_0.4.4           #> [133] cluster_2.1.6             beeswarm_0.4.0            #> [135] evaluate_1.0.1            zeallot_0.1.0             #> [137] magick_2.8.5              mvtnorm_1.3-2             #> [139] cli_3.6.3                 locfit_1.5-9.10           #> [141] compiler_4.4.2            rlang_1.1.4               #> [143] crayon_1.5.3              labeling_0.4.3            #> [145] classInt_0.4-10           plyr_1.8.9                #> [147] ggbeeswarm_0.7.2          fs_1.6.5                  #> [149] stars_0.6-7               viridisLite_0.4.2         #> [151] deldir_2.0-4              munsell_0.5.1             #> [153] Biostrings_2.74.0         tiff_0.1-12               #> [155] Matrix_1.7-1              ExperimentHub_2.14.0      #> [157] patchwork_1.3.0           sparseMatrixStats_1.18.0  #> [159] bit64_4.5.2               Rhdf5lib_1.28.0           #> [161] KEGGREST_1.46.0           statmod_1.5.0             #> [163] AnnotationHub_3.14.0      igraph_2.1.1              #> [165] memoise_2.0.1             bslib_0.8.0               #> [167] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig10_10x_nuclei.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Chromium nuclei isolation basic quality control","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SingleCellExperiment object.","code":"library(stringr) library(Matrix) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) library(ggplot2) theme_set(theme_bw()) if (!file.exists(\"10x_nuclei.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/10x_nuclei.rds\", destfile = \"10x_nuclei.rds\") sce <- readRDS(\"10x_nuclei.rds\") is_mito <- str_detect(rowData(sce)$gene_name, regex(\"^mt-\", ignore_case=TRUE)) sum(is_mito) #> [1] 37 sce <- addPerCellQCMetrics(sce, subsets = list(mito = is_mito)) names(colData(sce)) #> [1] \"sum\"                   \"detected\"              \"subsets_mito_sum\"      #> [4] \"subsets_mito_detected\" \"subsets_mito_percent\"  \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") +     plotColData(sce, \"subsets_mito_percent\") #> Warning: Removed 2931 rows containing non-finite outside the scale range #> (`stat_ydensity()`). #> Warning: Removed 2931 rows containing missing values or values outside the scale range #> (`position_quasirandom()`). plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. plotColData(sce, x = \"sum\", y = \"subsets_mito_detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. sce <- sce[, which(sce$subsets_mito_percent < 20)] sce <- sce[rowSums(counts(sce)) > 0,]  sce #> class: SingleCellExperiment  #> dim: 5260 9091  #> metadata(0): #> assays(1): counts #> rownames(5260): ENSG00000142611.17 ENSG00000142655.13 ... #>   ENSG00000225685.2 ENSG00000291031.1 #> rowData names(2): gene_name subsets_mito #> colnames(9091): AAACCCAAGACCATAA AAACCCAAGGTTTGAA ... TTTGTTGTCATCTGTT #>   TTTGTTGTCCTCCACA #> colData names(6): sum detected ... subsets_mito_percent total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #>  [9] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [11] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [13] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [15] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [17] Matrix_1.7-1                   stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] bluster_1.16.0            rjson_0.2.23              #>  [69] classInt_0.4-10           tools_4.4.2               #>  [71] units_0.8-5               vipor_0.4.7               #>  [73] beeswarm_0.4.0            R.oo_1.27.0               #>  [75] glue_1.8.0                nlme_3.1-166              #>  [77] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [79] grid_4.4.2                sf_1.0-19                 #>  [81] cluster_2.1.6             memuse_4.2-3              #>  [83] generics_0.1.3            gtable_0.3.6              #>  [85] R.methodsS3_1.8.2         class_7.3-22              #>  [87] data.table_1.16.2         ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] DropletUtils_1.26.0       stringi_1.8.4             #> [111] UCSC.utils_1.2.0          fftwtools_0.9-11          #> [113] yaml_2.3.10               boot_1.3-31               #> [115] evaluate_1.0.1            codetools_0.2-20          #> [117] tibble_3.2.1              cli_3.6.3                 #> [119] systemfonts_1.1.0         munsell_0.5.1             #> [121] jquerylib_0.1.4           Rcpp_1.0.13-1             #> [123] zeallot_0.1.0             coda_0.19-4.1             #> [125] png_0.1-8                 parallel_4.4.2            #> [127] pkgdown_2.1.1             jpeg_0.1-10               #> [129] sparseMatrixStats_1.18.0  bitops_1.0-9              #> [131] viridisLite_0.4.2         mvtnorm_1.3-2             #> [133] scales_1.3.0              e1071_1.7-16              #> [135] crayon_1.5.3              scico_1.5.0               #> [137] rlang_1.1.4               cowplot_1.1.3             #> [139] multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/vig11_clicktags.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic quality control on scRNA-seq data with ClickTag barcodes","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SingleCellExperiment object.","code":"library(stringr) library(DropletUtils) library(Matrix) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) library(ggplot2) theme_set(theme_bw()) if (!file.exists(\"clicktags.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/clicktags.rds\", destfile = \"clicktags.rds\") sce <- readRDS(\"clicktags.rds\") sce <- addPerCellQCMetrics(sce) names(colData(sce)) #> [1] \"sum\"      \"detected\" \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. bcrank <- barcodeRanks(counts(sce))  knee <- metadata(bcrank)$knee inflection <- metadata(bcrank)$inflection  plot(bcrank$rank, bcrank$total, log=\"xy\",       xlab=\"Rank\", ylab=\"Total ClickTags count\", cex.lab=1.2) #> Warning in xy.coords(x, y, xlabel, ylabel, log): 1 y value <= 0 omitted from #> logarithmic plot  abline(h=inflection, col=\"darkgreen\", lty=2) abline(h=knee, col=\"dodgerblue\", lty=2) sce <- sce[, colSums(counts(sce)) > inflection]  sce #> class: SingleCellExperiment  #> dim: 20 3368  #> metadata(0): #> assays(1): counts #> rownames(20): ClickTag1 ClickTag2 ... ClickTag19 ClickTag20 #> rowData names(1): feature_name #> colnames(3368): AAACCTGCAAACTGCT AAACCTGGTAGCTTGT ... TTTGTCAGTCACCCAG #>   TTTGTCATCTCTTATG #> colData names(3): sum detected total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] Matrix_1.7-1                   DropletUtils_1.26.0            #>  [9] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [11] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [13] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [15] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [17] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [19] stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] bluster_1.16.0            rjson_0.2.23              #>  [69] classInt_0.4-10           tools_4.4.2               #>  [71] units_0.8-5               vipor_0.4.7               #>  [73] beeswarm_0.4.0            R.oo_1.27.0               #>  [75] glue_1.8.0                nlme_3.1-166              #>  [77] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [79] grid_4.4.2                sf_1.0-19                 #>  [81] cluster_2.1.6             memuse_4.2-3              #>  [83] generics_0.1.3            gtable_0.3.6              #>  [85] R.methodsS3_1.8.2         class_7.3-22              #>  [87] data.table_1.16.2         ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] stringi_1.8.4             UCSC.utils_1.2.0          #> [111] fftwtools_0.9-11          yaml_2.3.10               #> [113] boot_1.3-31               evaluate_1.0.1            #> [115] codetools_0.2-20          tibble_3.2.1              #> [117] cli_3.6.3                 systemfonts_1.1.0         #> [119] munsell_0.5.1             jquerylib_0.1.4           #> [121] Rcpp_1.0.13-1             zeallot_0.1.0             #> [123] coda_0.19-4.1             png_0.1-8                 #> [125] parallel_4.4.2            pkgdown_2.1.1             #> [127] jpeg_0.1-10               sparseMatrixStats_1.18.0  #> [129] bitops_1.0-9              viridisLite_0.4.2         #> [131] mvtnorm_1.3-2             scales_1.3.0              #> [133] e1071_1.7-16              crayon_1.5.3              #> [135] scico_1.5.0               rlang_1.1.4               #> [137] cowplot_1.1.3             multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/vig12_crispr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quality control on Chromium CRISPR Guide Capture libraries","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SingleCellExperiment object.","code":"library(stringr) library(Matrix) library(DropletUtils) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) library(ggplot2) theme_set(theme_bw()) if (!file.exists(\"10xcrispr.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/10xcrispr.rds\", destfile = \"10xcrispr.rds\") sce <- readRDS(\"10xcrispr.rds\") is_mito <- str_detect(rowData(sce)$gene_name, regex(\"^mt-\", ignore_case=TRUE)) sum(is_mito) #> [1] 0 sce <- addPerCellQCMetrics(sce, subsets = list(mito = is_mito)) names(colData(sce)) #> [1] \"sum\"                   \"detected\"              \"subsets_mito_sum\"      #> [4] \"subsets_mito_detected\" \"subsets_mito_percent\"  \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. plotColData(sce, x = \"sum\", y = \"subsets_mito_detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. #> Warning: Computation failed in `stat_bin2d()`. #> Caused by error in `bin2d_breaks()`: #> ! `origin` must be a number, not `NaN`. bcrank <- barcodeRanks(counts(sce))  knee <- metadata(bcrank)$knee inflection <- metadata(bcrank)$inflection  plot(bcrank$rank, bcrank$total, log=\"xy\",       xlab=\"Rank\", ylab=\"Total ClickTags count\", cex.lab=1.2) #> Warning in xy.coords(x, y, xlabel, ylabel, log): 3 y values <= 0 omitted from #> logarithmic plot  abline(h=inflection, col=\"darkgreen\", lty=2) abline(h=knee, col=\"dodgerblue\", lty=2) sce <- sce[, which(sce$total > inflection)] sce <- sce[rowSums(counts(sce)) > 0,]  sce #> class: SingleCellExperiment  #> dim: 89 293  #> metadata(0): #> assays(1): counts #> rownames(89): Non-Targeting-5 Non-Targeting-7 ... HDAC1-1 HDAC1-2 #> rowData names(2): feature_name subsets_mito #> colnames(293): AAAGAACAGAAACGAA AAAGAACGTTTGTCGA ... TTTGATCCAGGAGAAA #>   TTTGATCGTGGTAGTG #> colData names(6): sum detected ... subsets_mito_percent total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] DropletUtils_1.26.0            SingleCellExperiment_1.28.1    #>  [9] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [11] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [13] IRanges_2.40.0                 S4Vectors_0.44.0               #> [15] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [17] matrixStats_1.4.1              Matrix_1.7-1                   #> [19] stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] bluster_1.16.0            rjson_0.2.23              #>  [69] classInt_0.4-10           tools_4.4.2               #>  [71] units_0.8-5               vipor_0.4.7               #>  [73] beeswarm_0.4.0            R.oo_1.27.0               #>  [75] glue_1.8.0                nlme_3.1-166              #>  [77] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [79] grid_4.4.2                sf_1.0-19                 #>  [81] cluster_2.1.6             memuse_4.2-3              #>  [83] generics_0.1.3            gtable_0.3.6              #>  [85] R.methodsS3_1.8.2         class_7.3-22              #>  [87] data.table_1.16.2         ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] stringi_1.8.4             UCSC.utils_1.2.0          #> [111] fftwtools_0.9-11          yaml_2.3.10               #> [113] boot_1.3-31               evaluate_1.0.1            #> [115] codetools_0.2-20          tibble_3.2.1              #> [117] cli_3.6.3                 systemfonts_1.1.0         #> [119] munsell_0.5.1             jquerylib_0.1.4           #> [121] Rcpp_1.0.13-1             zeallot_0.1.0             #> [123] coda_0.19-4.1             png_0.1-8                 #> [125] parallel_4.4.2            pkgdown_2.1.1             #> [127] jpeg_0.1-10               sparseMatrixStats_1.18.0  #> [129] bitops_1.0-9              viridisLite_0.4.2         #> [131] mvtnorm_1.3-2             scales_1.3.0              #> [133] e1071_1.7-16              crayon_1.5.3              #> [135] scico_1.5.0               rlang_1.1.4               #> [137] cowplot_1.1.3             multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/vig13_10xatac.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"10X ATAC-seq basic quality control ","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SingleCellExperiment object.","code":"library(stringr) library(DropletUtils) library(Matrix) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) library(ggplot2) theme_set(theme_bw()) if (!file.exists(\"10xatac.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/10xatac.rds\", destfile = \"10xatac.rds\") sce <- readRDS(\"10xatac.rds\") sce <- addPerCellQCMetrics(sce) names(colData(sce)) #> [1] \"sum\"      \"detected\" \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. sce <- sce[, which(sce$total > 0)] sce <- sce[rowSums(counts(sce)) > 0,]  sce #> class: SingleCellExperiment  #> dim: 209 166  #> metadata(0): #> assays(1): counts #> rownames(209): 1:9410718-9410885 1:14968574-14969617 ... #>   X:119775524-119775794 X:154317937-154318131 #> rowData names(0): #> colnames(166): AAACTCGCATTCTCGC AAAGGGCGTTGGCTTA ... TTGTCTACAGGTCCTG #>   TTTGTGTCATCGTACA #> colData names(3): sum detected total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] Matrix_1.7-1                   DropletUtils_1.26.0            #>  [9] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [11] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [13] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [15] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [17] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [19] stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] bluster_1.16.0            rjson_0.2.23              #>  [69] classInt_0.4-10           tools_4.4.2               #>  [71] units_0.8-5               vipor_0.4.7               #>  [73] beeswarm_0.4.0            R.oo_1.27.0               #>  [75] glue_1.8.0                nlme_3.1-166              #>  [77] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [79] grid_4.4.2                sf_1.0-19                 #>  [81] cluster_2.1.6             memuse_4.2-3              #>  [83] generics_0.1.3            gtable_0.3.6              #>  [85] R.methodsS3_1.8.2         class_7.3-22              #>  [87] data.table_1.16.2         ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] stringi_1.8.4             UCSC.utils_1.2.0          #> [111] fftwtools_0.9-11          yaml_2.3.10               #> [113] boot_1.3-31               evaluate_1.0.1            #> [115] codetools_0.2-20          tibble_3.2.1              #> [117] cli_3.6.3                 systemfonts_1.1.0         #> [119] munsell_0.5.1             jquerylib_0.1.4           #> [121] Rcpp_1.0.13-1             zeallot_0.1.0             #> [123] coda_0.19-4.1             png_0.1-8                 #> [125] parallel_4.4.2            pkgdown_2.1.1             #> [127] jpeg_0.1-10               sparseMatrixStats_1.18.0  #> [129] bitops_1.0-9              viridisLite_0.4.2         #> [131] mvtnorm_1.3-2             scales_1.3.0              #> [133] e1071_1.7-16              crayon_1.5.3              #> [135] scico_1.5.0               rlang_1.1.4               #> [137] cowplot_1.1.3             multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/vig14_10xmultiome.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"10X Multiome ATAC-seq basic quality control ","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SingleCellExperiment object.","code":"library(stringr) library(DropletUtils) library(Matrix) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) library(ggplot2) theme_set(theme_bw()) if (!file.exists(\"10xmultiome.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/10xmultiome.rds\", destfile = \"10xmultiome.rds\") sce <- readRDS(\"10xmultiome.rds\") sce <- addPerCellQCMetrics(sce) names(colData(sce)) #> [1] \"sum\"      \"detected\" \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. sce <- sce[, which(sce$total > 0)] sce <- sce[rowSums(counts(sce)) > 0,]  sce #> class: SingleCellExperiment  #> dim: 277 198  #> metadata(0): #> assays(1): counts #> rownames(277): 1:39574808-39575296 1:43131572-43131673 ... #>   X:152281428-152281521 X:166010316-166010375 #> rowData names(0): #> colnames(198): AAACGGTTCATTAGCT AAACGGTTCCGAAACG ... TTTCAAGGTACTAACC #>   TTTCCGGCATTAGCAG #> colData names(3): sum detected total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] Matrix_1.7-1                   DropletUtils_1.26.0            #>  [9] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [11] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [13] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [15] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [17] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [19] stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] bluster_1.16.0            rjson_0.2.23              #>  [69] classInt_0.4-10           tools_4.4.2               #>  [71] units_0.8-5               vipor_0.4.7               #>  [73] beeswarm_0.4.0            R.oo_1.27.0               #>  [75] glue_1.8.0                nlme_3.1-166              #>  [77] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [79] grid_4.4.2                sf_1.0-19                 #>  [81] cluster_2.1.6             memuse_4.2-3              #>  [83] generics_0.1.3            gtable_0.3.6              #>  [85] R.methodsS3_1.8.2         class_7.3-22              #>  [87] data.table_1.16.2         ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] stringi_1.8.4             UCSC.utils_1.2.0          #> [111] fftwtools_0.9-11          yaml_2.3.10               #> [113] boot_1.3-31               evaluate_1.0.1            #> [115] codetools_0.2-20          tibble_3.2.1              #> [117] cli_3.6.3                 systemfonts_1.1.0         #> [119] munsell_0.5.1             jquerylib_0.1.4           #> [121] Rcpp_1.0.13-1             zeallot_0.1.0             #> [123] coda_0.19-4.1             png_0.1-8                 #> [125] parallel_4.4.2            pkgdown_2.1.1             #> [127] jpeg_0.1-10               sparseMatrixStats_1.18.0  #> [129] bitops_1.0-9              viridisLite_0.4.2         #> [131] mvtnorm_1.3-2             scales_1.3.0              #> [133] e1071_1.7-16              crayon_1.5.3              #> [135] scico_1.5.0               rlang_1.1.4               #> [137] cowplot_1.1.3             multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic Visium exploratory data analysis","text":"introductory vignette SpatialFeatureExperiment data representation Voyager analysis package, demonstrate basic exploratory data analysis (EDA) spatial transcriptomics data. Basic knowledge R SingleCellExperiment assumed. vignette showcases packages Visium spatial gene expression system dataset. technology chosen due popularity, therefore availability numerous publicly available datasets analysis (Moses2022-xz?). Voyager developed goal facilitating use geospatial methods spatial genomics, introductory vignette restricted non-spatial scRNA-seq EDA Visium dataset. vignette illustrating univariate spatial analysis dataset, see advanced exploratory spatial data analyis vignette dataset. load packages used vignette.","code":"library(Voyager) library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SpatialExperiment) library(scater) library(scran) library(patchwork) library(bluster) library(SFEData) library(BiocParallel) library(stringr) library(ggplot2) library(sparseMatrixStats) library(dplyr) library(reticulate) library(concordexR) library(BiocNeighbors) library(pheatmap) theme_set(theme_bw(10)) # Specify Python version to use gget PY_PATH <- Sys.which(\"python\") use_python(PY_PATH) py_config() gget <- import(\"gget\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"mouse-skeletal-muscle-dataset","dir":"Articles","previous_headings":"","what":"Mouse skeletal muscle dataset","title":"Basic Visium exploratory data analysis","text":"dataset used vignette paper Large-scale integration single-cell transcriptomic data captures transitional progenitor states mouse skeletal muscle regeneration (McKellar2021-ek?). Notexin injected tibialis anterior muscle mice induce injury, healing muscle collected 2, 5, 7 days post injury Visium analysis. dataset vignette timepoint day 2. vignette starts SpatialFeatureExperiment (SFE) object. gene count matrix directly downloaded GEO. 4992 spots, whether tissue , included. tissue boundary found thresholding H&E image OpenCV, small polygons removed likely debris. Spot polygons constructed spot centroid coordinates diameter Space Ranger output. in_tissue column colData indicates spot polygons intersect tissue polygons, based st_intersects(). Tissue boundary, nuclei, myofiber, Visium spot polygons stored sf data frames SFE object. Visium spot polygons called â€œspotPolyâ€ SFE object. SpatialFeatureExperiment package convenience wrappers get set common types geometries, including spotPoly() Visium (technologies relevant) spot polygons, cellSeg() cell segmentation, nucSeg() nuclei segmentation, centroids() cell centroids. Behind scene specially named sf data frames. See vignette SpatialFeatureExperiment details structure SFE object. SFE object dataset provided SFEData package; begin downloading data loading R. authors provided full resolution hematoxylin eosin (H&E) image GEO, downsized facilitate display: image can added SFE object plotted behind geometries, needs flipped align spots origin top left image bottom left geometries.","code":"(sfe <- McKellarMuscleData(\"full\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 4992  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG #>   TTGTTTGTGTAAATTC #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A: if (!file.exists(\"tissue_lowres_5a.jpeg\")) {     download.file(\"https://raw.githubusercontent.com/pachterlab/voyager/main/vignettes/tissue_lowres_5a.jpeg\",                   destfile = \"tissue_lowres_5a.jpeg\") } sfe <- addImg(sfe, imageSource = \"tissue_lowres_5a.jpeg\", sample_id = \"Vis5A\",                image_id = \"lowres\",                scale_fct = 1024/22208) # Don't need to mirror for terra >= 1.7.83 #sfe <- mirrorImg(sfe, sample_id = \"Vis5A\", image_id = \"lowres\")"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"spots","dir":"Articles","previous_headings":"Quality control","what":"Spots","title":"Basic Visium exploratory data analysis","text":"begin quality control (QC) plotting various metrics violin plots space. QC metrics pre-computed stored colData (spots) rowData SFE object. plot total unique molecular identifier (UMI) counts per spot. commented line code shows compute total UMI counts. maxcell argument maximum number pixels plot image; image downsampled pixels maxcells. can speed plotting plotting image multiple facets.  spots injury site leukocyte infiltration high total counts. Spatial autocorrelation total counts apparent, discussed later section vignette. Next find number genes detected per spot. commented line code shows find number genes detected.  commonly done scRNA-seq data, plot nCounts vs.Â nGenes  plot two branches spots tissue, turn related myofiber size. See exploratory spatial data analysis (ESDA) Visium vignette. commonly done scRNA-seq data, plot proportion mitochondrially encoded counts. commented code shows find proportion:  expected, spots outside tissue higher proportion mitochondrial counts, tissue lysed, mitochondrial transcripts less likely degrade cytosolic transcripts protected double membrane. However, spots myofibers also high proportion mitochondrial counts, function myofibers. injury site leukocyte infiltration lower proportion mitochondrial counts. see relationship proportion mitochondrial counts total UMI counts, plot commonly done scRNA-seq analysis identify low quality cells, .e.Â cells UMI counts high proportion mitochondrial counts.  two clusters spots tissue, also turn related myofiber size. See ESDA Visium vignette. far havenâ€™t seen spots obvious outliers QC metrics. following analyses use spots tissue, selected follows:","code":"names(colData(sfe)) #>  [1] \"barcode\"   \"col\"       \"row\"       \"x\"         \"y\"         \"dia\"       #>  [7] \"tissue\"    \"sample_id\" \"nCounts\"   \"nGenes\"    \"prop_mito\" \"in_tissue\" # colData(sfe)$nCounts <- colSums(counts(sfe)) violin <- plotColData(sfe, \"nCounts\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\",                                image = \"lowres\", maxcell = 5e4,                               annot_fixed = list(fill = NA, color = \"black\")) +     theme_void() violin + spatial # colData(sfe)$nGenes <- colSums(counts(sfe) > 0) violin <- plotColData(sfe, \"nGenes\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\",                               image = \"lowres\", maxcell = 5e4,                               annot_fixed = list(fill = NA, color = \"black\")) +     theme_void() violin + spatial plotColData(sfe, x = \"nCounts\", y = \"nGenes\", colour_by = \"in_tissue\") # mito_ind <- str_detect(rowData(sfe)$symbol, \"^Mt-\") # colData(sfe)$prop_mito <- colSums(counts(sfe)[mito_ind,]) / colData(sfe)$nCounts violin <- plotColData(sfe, \"prop_mito\", x = \"in_tissue\", colour_by = \"in_tissue\") +     theme(legend.position = \"top\") spatial <- plotSpatialFeature(sfe, \"prop_mito\", colGeometryName = \"spotPoly\",                               annotGeometryName = \"tissueBoundary\",                               image = \"lowres\", maxcell = 5e4,                               annot_fixed = list(fill = NA, color = \"black\")) +     theme_void() violin + spatial plotColData(sfe, x = \"nCounts\", y = \"prop_mito\", colour_by = \"in_tissue\") sfe_tissue <- sfe[, colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"Basic Visium exploratory data analysis","text":"scRNA-seq, gene expression variance Visium measurements overdispersed compared variance counts Poisson distributed. understand mean-variance relationship, compute mean, variance, coefficient variance (CV2) gene among spots tissue: avoid overplotting better show point density plot, use 2D histogram. color bin indicates number points bin.  red line, y=xy = x expected Poisson distributed data, find variance higher highly expressed genes expected Poisson distributed counts. coefficient variation shows .","code":"rowData(sfe_tissue)$means <- rowMeans(counts(sfe_tissue)) rowData(sfe_tissue)$vars <- rowVars(counts(sfe_tissue)) # Coefficient of variance rowData(sfe_tissue)$cv2 <- rowData(sfe_tissue)$vars/rowData(sfe_tissue)$means^2 plotRowData(sfe, x = \"means\", y = \"vars\", bins = 50) +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     annotation_logticks() +     coord_equal() #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. plotRowData(sfe, x = \"means\", y = \"cv2\", bins = 50) +     geom_abline(slope = -1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     annotation_logticks() +     coord_equal() #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale."},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"normalize-data","dir":"Articles","previous_headings":"","what":"Normalize data","title":"Basic Visium exploratory data analysis","text":"demonstrate use scater normalization , although note necessarily best approach normalizing spatial transcriptomics data. problem normalize spatial transcriptomics data non-trivial , nCounts plot space shows , spatial autocorrelation evident. Furthemrore, Visium, reverse transcription occurs situ spots, PCR amplification occurs cDNA dissociated spots. Artifacts may subsequently introduced amplification step, associated spatial origin. Spatial artifacts may arise diffusion transcripts tissue permeablization. However, given total counts seem correspond histological regions, total counts may biological component hence treated technical artifact normalized away scRNA-seq data normalization methods. words, issue normalization spatial transcriptomics data, Visium particular, complex currently unsolved. one way normalize non-spatial scRNA-seq data. commented code implements scran method (Lun2016-yq?). simplify matter, perform logNormCounts() introductory vignette. Note scaterâ€™s logNormCounts() quite different Seurat. Let NN denote total UMI count one Visium spot, Nâ€¾\\bar N average total UMI count spots dataset, xx denote UMI count one gene Visium spot interest. Seurat performs log normalization log(xN/10000+1)\\mathrm{log}\\left( \\frac{x}{N/10000} + 1 \\right), natural log used. contrast, default parameters, scater uses log2(xN/Nâ€¾+1)\\mathrm{log_2}\\left( \\frac{x}{N/\\bar N} + 1 \\right). pseudocount (default 1), library size factors (default N/Nâ€¾N/\\bar N), transform (default log2) can changed. Log 2 used differences values can interpreted log fold change. Next, identify highly variable genes (HVGs), used principal component analysis (PCA) dimensionality reduction. , different ways identify HVGs, scater differently Seurat. frameworks, log normalized data used default. summary, Seurat, default parameters, Loess curve fitted log transformed data (log normalized data log transformed fitting purposes), fitted values exponentiated expected variance gene. expected variance mean used standardize log normalized gene expression; standardized values used calculate standardized variance gene. top HVGs genes largest standardized variance. scater, default parameters, parametric non-linear curve variance vs.Â mean gene log normalized data. log ratio actual variance fitted variance curve calculated, Loess curve fitted log ratio vs.Â mean gene. â€œtechnicalâ€ component variance fitted values Loess curve. â€œbiologicalâ€ component difference actual variance Loess fitted variance. top HVGs genes largest biological component. See documentation modelGeneVar(), fitTrendVar(), getTopHVGs() details. differences can lead different downstream results. donâ€™t comment way better vignette, â€™s important aware differences.","code":"# clusters <- quickCluster(sfe_tissue) # sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) # sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 2000)"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Dimension reduction and clustering","title":"Basic Visium exploratory data analysis","text":"clustering show dimension reduction plots  principal components (PCs) can plotted space. Due spatial autocorrelation many genes spatial regions different histological characters, even though spatial information used PCA procedure, PCs may show spatial structure.  PC1, explains far variance PC2, separates injury site leukocytes myofibers close site Visium myofibers. PC2 highlights center injury site myofibers near edge. PC3 highlights muscle tendon junctions. PC4 seem informative; might picked outlier. also possible run UMAP following PCA, done scRNA-seq. recommend producing UMAP since procedure distorts distances, respect either local global structure data (Chari2021-hb?). However, completeness, show compute UMAP :  UMAP often used visualize clusters. alternative UMAP concordex, quantitatively shows proportion neighbors k nearest neighbor graph cluster label. consistent default igraph Leiden clustering, use k = 10. result neighborhood consolidation matrix can help finding spatial regions, see concordex paper. heatmap shows proportion spatial neighborhood (k nearest neighbors k = 18 2nd order neighbors hexagonal array) spot belongs given gene expression based cluster; matrix shown heatmap clustered   Also plot clusters use spatial information  spatial information explicitly used clustering, due spatial autocorrelation gene expression histological regions, clusters spatially contiguous. many methods find spatially informed clusters, BayesSpace (Zhao2021-vb?), Bioconductor. Remark spatial regions: geographical space, usually one single way define spatial regions. example, influenced sociology geology, LA county can partitioned regions Eastside, Westside, South Central, San Fernado Valley, San Gabriel Valley, Pomona Valley, Gateway Cities, South Bay, etc., containing multiple smaller cities parts LA City, can divided many neighborhoods, Koreatown, Highland Park, Lincoln Heights, etc. Definitions regions subject dispute. Meanwhile, LA county can also partitioned watersheds LA River, San Gabriel River, Ballona Creek, etc., well different rock formations. kind spatial region resolution relevant depends question asked. also gray areas spatial regions. example, Whittier Narrows dam intercepts San Gabriel River Rio Hondo (large tributary LA River), whether dam area belongs watershed San Gabriel River LA River unclear. Similarly, spatial transcriptomics, methods identifying spatial regions currently generally aim give one result, multiple results different resolutions depending question asked may relevant. Furthermore, methods spatial region demarcation used spatial -omics ideally provide uncertainty assessments assignment cells Visium spots. existing geospatial method accounts uncertainty geocmeans (Zhao2013-tw?), CRAN. geographical histological space, conflicting views spatial variation. one hand, methods identify spatially variable genes SpatialDE often assume gene expression vary smoothly continuously space. hand, methods identifying spatial regions attempt identify discrete regions. continuous variation features might definitions geographical neighborhoods often subject dispute. existing methods attempt harmonize two views. example, spatially variable gene method belayer (Ma2022-dc?) takes discrete tissue layers account.","code":"sfe_tissue <- runPCA(sfe_tissue, ncomponents = 30, subset_row = hvgs,                      scale = TRUE) # scale as in Seurat ElbowPlot(sfe_tissue, ndims = 30) plotDimLoadings(sfe_tissue, dims = 1:4, swap_rownames = \"symbol\") colData(sfe_tissue)$cluster <- clusterRows(reducedDim(sfe_tissue, \"PCA\")[,1:3],                                            BLUSPARAM = SNNGraphParam(                                                cluster.fun = \"leiden\",                                                cluster.args = list(                                                    resolution_parameter = 0.5,                                                    objective_function = \"modularity\"))) plotPCA(sfe_tissue, ncomponents = 3, colour_by = \"cluster\") spatialReducedDim(sfe_tissue, \"PCA\", ncomponents = 4,                    colGeometryName = \"spotPoly\", divergent = TRUE,                    diverge_center = 0, image = \"lowres\", maxcell = 5e4) set.seed(29) sfe_tissue <- runUMAP(sfe_tissue, dimred = \"PCA\", n_dimred = 3) plotUMAP(sfe_tissue, colour_by = \"cluster\") res <- calculateConcordex(sfe_tissue, labels = sfe_tissue$cluster,                            n_neighbors = 18,                           BLUSPARAM = SNNGraphParam(                               cluster.fun = \"leiden\",                               cluster.args = list(                                   resolution_parameter = 0.5,                                   objective_function = \"modularity\"))) pheatmap(res) sfe_tissue$concordex <- attr(res, \"shrs\") plotSpatialFeature(sfe_tissue, \"concordex\", image = \"lowres\", maxcell = 5e4) plotSpatialFeature(sfe_tissue, \"cluster\", colGeometryName = \"spotPoly\",                    image = \"lowres\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"non-spatial-differential-expression","dir":"Articles","previous_headings":"","what":"Non-spatial differential expression","title":"Basic Visium exploratory data analysis","text":"Cluster marker genes can found using differential analysis methods commonly done scRNA-seq. example Wilcoxon rank sum test: result sorted p-values: can use gget enrichr module gget package perform gene enrichment analysis. can choose >200 enrichment databases listed Enrichr website. , analyzing top 20 genes cluster 1 using default ontology database GO_Biological_Process_2021: Significant markers cluster can obtained follows:  â€™ll use module gget info get additional information genes, descriptions, synonyms, transcripts collection reference databases including Ensembl, UniProt, NCBI. , showing gene descriptions NCBI: genes interesting view spatial context:","code":"markers <- findMarkers(sfe_tissue, groups = colData(sfe_tissue)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[1]] #> DataFrame with 15043 rows and 9 columns #>                        p.value         FDR summary.AUC     AUC.2     AUC.3 #>                      <numeric>   <numeric>   <numeric> <numeric> <numeric> #> ENSMUSG00000019787 6.69790e-09 6.45951e-05    0.736790  0.736790  0.859166 #> ENSMUSG00000030730 8.58806e-09 6.45951e-05    0.735012  0.735012  0.930827 #> ENSMUSG00000005716 4.47525e-07 2.24404e-03    0.671429  0.713580  0.902507 #> ENSMUSG00000051747 2.79997e-06 1.05300e-02    0.689284  0.689284  0.953086 #> ENSMUSG00000038170 7.69174e-04 1.00000e+00    0.611523  0.673975  0.745305 #> ...                        ...         ...         ...       ...       ... #> ENSMUSG00000043969           1           1         0.5  0.500000  0.500000 #> ENSMUSG00000091378           1           1         0.5  0.500000  0.500000 #> ENSMUSG00000072437           1           1         0.5  0.500000  0.500000 #> ENSMUSG00000003228           1           1         0.5  0.500000  0.477273 #> ENSMUSG00000094649           1           1         0.5  0.493333  0.500000 #>                        AUC.4     AUC.5     AUC.6     AUC.7 #>                    <numeric> <numeric> <numeric> <numeric> #> ENSMUSG00000019787  0.740476  0.939893  0.712373  0.731262 #> ENSMUSG00000030730  0.712513  0.990557  0.827984  0.758349 #> ENSMUSG00000005716  0.671429  0.972349  0.797531  0.792844 #> ENSMUSG00000051747  0.769868  0.990161  0.866118  0.824074 #> ENSMUSG00000038170  0.629894  0.876986  0.611523  0.661456 #> ...                      ...       ...       ...       ... #> ENSMUSG00000043969  0.500000  0.496183  0.500000       0.5 #> ENSMUSG00000091378  0.500000  0.496183  0.500000       0.5 #> ENSMUSG00000072437  0.500000  0.492366  0.500000       0.5 #> ENSMUSG00000003228  0.492857  0.473282  0.488889       0.5 #> ENSMUSG00000094649  0.500000  0.500000  0.500000       0.5 enrichr_genes <- rownames(markers[[1]])[1:20] gget_e <- gget$enrichr(enrichr_genes, ensembl=TRUE, database = \"ontology\")  # Plot results of gene enrichment analysis # Count number of overlapping genes gget_e$overlapping_genes_count <- lapply(gget_e$overlapping_genes, length) |> as.numeric() # Only keep the top 10 results gget_e <- gget_e[1:10,] gget_e |>     ggplot() +     geom_bar(aes(         x = -log10(adj_p_val),         y = reorder(path_name, -adj_p_val)     ),     stat = \"identity\",     fill = \"lightgrey\",     width = 0.5,     color = \"black\") +     geom_text(         aes(             y = path_name,             x = (-log10(adj_p_val)),             label = overlapping_genes_count         ),         nudge_x = 0.25,         show.legend = NA,         color = \"red\"     ) +     geom_text(         aes(             y = Inf,             x = Inf,                 hjust = 1,                 vjust = 1,             label = \"# of overlapping genes\"         ),         show.legend = NA,         size=4,         color = \"red\"     ) +     geom_vline(linetype = \"dashed\", linewidth = 0.5, xintercept = -log10(0.05)) +     ylab(\"Pathway name\") +     xlab(\"-log10(adjusted P value)\") genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe_tissue, rowData(sfe_tissue)[genes_use, \"symbol\"], x = \"cluster\",                colour_by = \"cluster\", swap_rownames = \"symbol\") gget_info <- gget$info(genes_use)  rownames(gget_info) <- gget_info$primary_gene_name select(gget_info, ncbi_description) plotSpatialFeature(sfe_tissue, genes_use, colGeometryName = \"spotPoly\", ncol = 3,                    image = \"lowres\", maxcell = 5e4, swap_rownames = \"symbol\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moranâ€™s I","title":"Basic Visium exploratory data analysis","text":"Toblerâ€™s first law geography (Tobler1970-hz?) states Everything related everything else. near things related distant things. observation motivates examination spatial autocorrelation. Positive spatial autocorrelation evident nearby things tend similar, weather Pasadena downtown Los Angeles (opposed weather Pasadena San Francisco). Negative spatial autocorrelation evident nearby things tend dissimilar, like squares chessboard. Spatial autocorrelation can arise intrinsic process diffusion communication physical contact, result covariate intrinsic process, areal data, areal units observation smaller scale spatial process. commonly used measure spatial autocorrelation Moranâ€™s (Moran1950-aq?), defined =nâˆ‘=1nâˆ‘j=1nwijâˆ‘=1nâˆ‘j=1nwij(xiâˆ’xâ€¾)(xjâˆ’xâ€¾)âˆ‘=1n(xiâˆ’xâ€¾)2, = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}, nn number spots locations, ii jj different locations, spots Visium context, xx variable values location, wijw_{ij} spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood whether normalize number neighbors. spdep package uses neighborhood. Moranâ€™s similar Pearson correlation value location average value neighbors (identical, see (Lee2001-tm?)). Just like Pearson correlation, Moranâ€™s generally bound -1 1, positive value indicates positive spatial autocorrelation negative value indicates negative spatial autocorrelation. Spatial dependence analysis spdep requires spatial neighborhood graph. graph adjacent Visium spot can found mentioned spatial autocorrelation apparent total UMI counts. â€™s Moranâ€™s shows: K means kurtosis. positive values Moranâ€™s indicate positive spatial autocorrelation.","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) calculateMoransI(t(colData(sfe_tissue)[,c(\"nCounts\", \"nGenes\")]),                   listw = colGraph(sfe_tissue, \"visium\")) #> DataFrame with 2 rows and 2 columns #>             moran         K #>         <numeric> <numeric> #> nCounts  0.528705   3.00082 #> nGenes   0.384028   3.88036"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"spatially-variable-genes","dir":"Articles","previous_headings":"Moranâ€™s I","what":"Spatially variable genes","title":"Basic Visium exploratory data analysis","text":"spatially variable gene gene whose expression depends spatial locations, rather spatially random, like salt grains spread soup. Spatially variable genes can identified spatial autocorrelation signatures, sometimes Moranâ€™s used compare assess spatially variable genes identified different methods. BPPARAM used paralelize computation Moranâ€™s 2000 highly variable genes, 2 cores used SNOW backend. results stored rowData NAâ€™s genes highly variable Moranâ€™s computed genes. rank genes Moranâ€™s plot space follows: see genes strong positive spatial autocorrelation, donâ€™t observe strong negative spatial autocorrelation. Letâ€™s get additional information genes strongest positive spatial autocorrelation space using gget info : <<<<<<< HEAD Letâ€™s plot genes:  genes indeed look spatially variable. However, spatial variability can simply due histological regions space, words, spatial distribution different cell types. many methods identify spatially variable genes, often involving Gaussian process modeling, far complex Moranâ€™s , SpatialDE (Svensson2018-sx?). However, methods usually donâ€™t account histological regions, except C-SIDE (Cable2022-ma?), identifies spatially variable genes within cell types. leads question really meant â€œcell typeâ€. remains see spatial methods made specifically identifying spatially variable genes compare methods donâ€™t explicitly use spatial information simply perform differential analysis cell types often spatially defined histological regions. Another consideration using Moranâ€™s extent strength spatial autocorrelation varies space. gene exhibits strong spatial autocorrelation one region, another? different histological regions analyzed separately cases? ways see whether Moranâ€™s statistically significant, many methods explore spatial autocorrelation. discussed advanced ESDA Visium vignette.","code":"sfe_tissue <- runMoransI(sfe_tissue, features = hvgs, colGraphName = \"visium\",                          BPPARAM = SnowParam(2)) #> Warning: <anonymous>: ... may be used in an incorrect context: 'fun(x[i, ], ...)' rowData(sfe_tissue) #> DataFrame with 15043 rows and 8 columns #>                               Ensembl      symbol            type      means #>                           <character> <character>     <character>  <numeric> #> ENSMUSG00000025902 ENSMUSG00000025902       Sox17 Gene Expression 0.03969957 #> ENSMUSG00000096126 ENSMUSG00000096126     Gm22307 Gene Expression 0.00107296 #> ENSMUSG00000033845 ENSMUSG00000033845      Mrpl15 Gene Expression 0.38197425 #> ENSMUSG00000025903 ENSMUSG00000025903      Lypla1 Gene Expression 0.28755365 #> ENSMUSG00000033813 ENSMUSG00000033813       Tcea1 Gene Expression 0.26502146 #> ...                               ...         ...             ...        ... #> ENSMUSG00000064360 ENSMUSG00000064360      mt-Nd3 Gene Expression  56.445279 #> ENSMUSG00000064363 ENSMUSG00000064363      mt-Nd4 Gene Expression 123.991416 #> ENSMUSG00000064367 ENSMUSG00000064367      mt-Nd5 Gene Expression  14.645923 #> ENSMUSG00000064368 ENSMUSG00000064368      mt-Nd6 Gene Expression   0.109442 #> ENSMUSG00000064370 ENSMUSG00000064370     mt-Cytb Gene Expression 121.273605 #>                           vars       cv2 moran_Vis5A   K_Vis5A #>                      <numeric> <numeric>   <numeric> <numeric> #> ENSMUSG00000025902  0.04460915  28.30429          NA        NA #> ENSMUSG00000096126  0.00107296 932.00000          NA        NA #> ENSMUSG00000033845  0.47048031   3.22458          NA        NA #> ENSMUSG00000025903  0.34686963   4.19497          NA        NA #> ENSMUSG00000033813  0.32388797   4.61140   0.0489758   19.2181 #> ...                        ...       ...         ...       ... #> ENSMUSG00000064360 2.47976e+03  0.778314    0.410657  11.31069 #> ENSMUSG00000064363 1.45282e+04  0.944991    0.546964  13.62886 #> ENSMUSG00000064367 2.34858e+02  1.094895    0.480634   3.75345 #> ENSMUSG00000064368 1.31941e-01 11.015664          NA        NA #> ENSMUSG00000064370 1.48225e+04  1.007833    0.621060  10.71784 df <- rowData(sfe_tissue)[hvgs,] ord <- order(df$moran_Vis5A, decreasing = TRUE) df[ord, c(\"symbol\", \"moran_Vis5A\")] #> DataFrame with 2000 rows and 2 columns #>                         symbol moran_Vis5A #>                    <character>   <numeric> #> ENSMUSG00000064351      mt-Co1    0.764044 #> ENSMUSG00000050335      Lgals3    0.741474 #> ENSMUSG00000029304        Spp1    0.734937 #> ENSMUSG00000021939        Ctsb    0.708362 #> ENSMUSG00000004207        Psap    0.706552 #> ...                        ...         ... #> ENSMUSG00000039911       Spsb1  -0.0333357 #> ENSMUSG00000015711       Prune  -0.0354638 #> ENSMUSG00000042675       Ypel3  -0.0369055 #> ENSMUSG00000090262       Mpv17  -0.0412250 #> ENSMUSG00000020964       Sel1l  -0.0443975 ======= >>>>>>> documentation gget_info2 <- gget$info(rownames(df)[1:6])  rownames(gget_info2) <- gget_info2$primary_gene_name select(gget_info2, ncbi_description) plotSpatialFeature(sfe_tissue, rownames(df)[1:6], colGeometryName = \"spotPoly\",                    image = \"lowres\", maxcell = 5e4, swap_rownames = \"symbol\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig1_visium_basic.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Basic Visium exploratory data analysis","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] pheatmap_1.0.12                BiocNeighbors_2.0.0            #>  [3] concordexR_1.6.0               reticulate_1.40.0              #>  [5] dplyr_1.1.4                    sparseMatrixStats_1.18.0       #>  [7] stringr_1.5.1                  BiocParallel_1.40.0            #>  [9] SFEData_1.8.0                  bluster_1.16.0                 #> [11] patchwork_1.3.0                scran_1.34.0                   #> [13] scater_1.34.0                  ggplot2_3.5.1                  #> [15] scuttle_1.16.0                 SpatialExperiment_1.16.0       #> [17] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [19] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [21] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [23] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [25] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [27] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             filelock_1.0.3            #>   [3] bitops_1.0-9              tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] sf_1.0-19                 edgeR_4.4.0               #>   [9] lattice_0.22-6            MASS_7.3-61               #>  [11] magrittr_2.0.3            limma_3.62.1              #>  [13] sass_0.4.9                rmarkdown_2.29            #>  [15] jquerylib_0.1.4           yaml_2.3.10               #>  [17] metapod_1.14.0            sp_2.1-4                  #>  [19] cowplot_1.1.3             RColorBrewer_1.1-3        #>  [21] DBI_1.2.3                 multcomp_1.4-26           #>  [23] abind_1.4-8               spatialreg_1.3-5          #>  [25] zlibbioc_1.52.0           purrr_1.0.2               #>  [27] R.utils_2.12.3            RCurl_1.98-1.16           #>  [29] TH.data_1.1-2             rappdirs_0.3.3            #>  [31] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [33] ggrepel_0.9.6             irlba_2.3.5.1             #>  [35] terra_1.7-83              units_0.8-5               #>  [37] RSpectra_0.16-2           dqrng_0.4.1               #>  [39] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [41] codetools_0.2-20          DropletUtils_1.26.0       #>  [43] DelayedArray_0.32.0       tidyselect_1.2.1          #>  [45] UCSC.utils_1.2.0          memuse_4.2-3              #>  [47] farver_2.1.2              ScaledMatrix_1.14.0       #>  [49] viridis_0.6.5             BiocFileCache_2.14.0      #>  [51] jsonlite_1.8.9            e1071_1.7-16              #>  [53] survival_3.7-0            systemfonts_1.1.0         #>  [55] dbscan_1.2-0              tools_4.4.2               #>  [57] ggnewscale_0.5.0          ragg_1.3.3                #>  [59] snow_0.4-4                Rcpp_1.0.13-1             #>  [61] glue_1.8.0                gridExtra_2.3             #>  [63] SparseArray_1.6.0         xfun_0.49                 #>  [65] EBImage_4.48.0            HDF5Array_1.34.0          #>  [67] withr_3.0.2               BiocManager_1.30.25       #>  [69] fastmap_1.2.0             boot_1.3-31               #>  [71] rhdf5filters_1.18.0       fansi_1.0.6               #>  [73] spData_2.3.3              digest_0.6.37             #>  [75] rsvd_1.0.5                mime_0.12                 #>  [77] R6_2.5.1                  textshaping_0.4.0         #>  [79] colorspace_2.1-1          wk_0.9.4                  #>  [81] LearnBayes_2.15.1         jpeg_0.1-10               #>  [83] RSQLite_2.3.8             R.methodsS3_1.8.2         #>  [85] utf8_1.2.4                generics_0.1.3            #>  [87] data.table_1.16.2         FNN_1.1.4.1               #>  [89] class_7.3-22              httr_1.4.7                #>  [91] htmlwidgets_1.6.4         S4Arrays_1.6.0            #>  [93] spdep_1.3-6               uwot_0.2.2                #>  [95] pkgconfig_2.0.3           scico_1.5.0               #>  [97] gtable_0.3.6              blob_1.2.4                #>  [99] XVector_0.46.0            htmltools_0.5.8.1         #> [101] fftwtools_0.9-11          scales_1.3.0              #> [103] png_0.1-8                 knitr_1.49                #> [105] rjson_0.2.23              curl_6.0.1                #> [107] coda_0.19-4.1             nlme_3.1-166              #> [109] proxy_0.4-27              cachem_1.1.0              #> [111] zoo_1.8-12                rhdf5_2.50.0              #> [113] BiocVersion_3.20.0        KernSmooth_2.23-24        #> [115] parallel_4.4.2            vipor_0.4.7               #> [117] AnnotationDbi_1.68.0      desc_1.4.3                #> [119] s2_1.1.7                  pillar_1.9.0              #> [121] grid_4.4.2                vctrs_0.6.5               #> [123] BiocSingular_1.22.0       dbplyr_2.5.0              #> [125] beachmat_2.22.0           sfheaders_0.4.4           #> [127] cluster_2.1.6             beeswarm_0.4.0            #> [129] evaluate_1.0.1            zeallot_0.1.0             #> [131] magick_2.8.5              mvtnorm_1.3-2             #> [133] cli_3.6.3                 locfit_1.5-9.10           #> [135] compiler_4.4.2            rlang_1.1.4               #> [137] crayon_1.5.3              labeling_0.4.3            #> [139] classInt_0.4-10           fs_1.6.5                  #> [141] ggbeeswarm_0.7.2          stringi_1.8.4             #> [143] viridisLite_0.4.2         deldir_2.0-4              #> [145] Biostrings_2.74.0         munsell_0.5.1             #> [147] tiff_0.1-12               Matrix_1.7-1              #> [149] ExperimentHub_2.14.0      bit64_4.5.2               #> [151] Rhdf5lib_1.28.0           KEGGREST_1.46.0           #> [153] statmod_1.5.0             AnnotationHub_3.14.0      #> [155] igraph_2.1.1              memoise_2.0.1             #> [157] bslib_0.8.0               bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatial Visium exploratory data analysis","text":"vignette provides introduction exploratory spatial data analysis methods via Voyager package context Visium dataset. <<<<<<< HEAD","code":"library(Voyager) library(SpatialFeatureExperiment) library(scater) library(scran) library(SFEData) library(sf) library(ggplot2) library(scales) library(patchwork) library(BiocParallel) library(bluster) library(dplyr) library(reticulate) theme_set(theme_bw(10)) ======= >>>>>>> documentation # Specify Python version to use gget PY_PATH <- system(\"which python\", intern = TRUE) use_python(PY_PATH) py_config()  # Load gget gget <- import(\"gget\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Spatial Visium exploratory data analysis","text":"dataset used vignette paper Large-scale integration single-cell transcriptomic data captures transitional progenitor states mouse skeletal muscle regeneration (McKellar2021-ek?). Notexin injected tibialis anterior muscle mice induce injury, healing muscle collected 2, 5, 7 days post injury Visium analysis. dataset vignette timepoint day 2. vignette starts SpatialFeatureExperiment (SFE) object. gene count matrix directly downloaded GEO. 4992 spots, whether tissue , included. H&E image used nuclei myofiber segmentation. subset nuclei randomly selected regions 3 timepoints manually annotated train StarDist model segment rest nuclei, myofibers manually segmented. tissue boundary found thresholding OpenCV, small polygons removed likely debris. Spot polygons constructed spot centroid coordinates diameter Space Ranger output. in_tissue column colData indicates spot polygons intersect tissue polygons, based st_intersects(). Tissue boundary, nuclei, myofiber, Visium spot polygons stored sf data frames SFE object. See vignette SpatialFeatureExperiment details structure SFE object. SFE object dataset provided SFEData package; begin downloading data loading R. H&E image section: image can added SFE object plotted behind geometries, needs flipped align spots origin top left image bottom left geometries.","code":"(sfe <- McKellarMuscleData(\"full\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 15123 4992  #> metadata(0): #> assays(1): counts #> rownames(15123): ENSMUSG00000025902 ENSMUSG00000096126 ... #>   ENSMUSG00000064368 ENSMUSG00000064370 #> rowData names(6): Ensembl symbol ... vars cv2 #> colnames(4992): AAACAACGAATAGTTC AAACAAGTATCTCCCA ... TTGTTTGTATTACACG #>   TTGTTTGTGTAAATTC #> colData names(12): barcode col ... prop_mito in_tissue #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : imageX imageY #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: spotPoly (POLYGON)  #> annotGeometries: tissueBoundary (POLYGON), myofiber_full (POLYGON), myofiber_simplified (POLYGON), nuclei (POLYGON), nuclei_centroid (POINT)  #>  #> Graphs: #> Vis5A: if (!file.exists(\"tissue_lowres_5a.jpeg\")) {     download.file(\"https://raw.githubusercontent.com/pachterlab/voyager/main/vignettes/tissue_lowres_5a.jpeg\",                   destfile = \"tissue_lowres_5a.jpeg\") } sfe <- addImg(sfe, imageSource = \"tissue_lowres_5a.jpeg\", sample_id = \"Vis5A\",                image_id = \"lowres\",                scale_fct = 1024/22208)"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"spots-in-tissue","dir":"Articles","previous_headings":"Exploratory data analysis","what":"Spots in tissue","title":"Spatial Visium exploratory data analysis","text":"example dataset Visium spots whether tissue , spots intersect tissue used analyses. Total UMI counts (nCounts), number genes detected per spot (nGenes), proportion mitochondrially encoded counts (prop_mito) precomputed colData(sfe). plotSpatialFeature function can used visualize various attributes space: expression gene, colData values, geometry attributes colGeometry annotGeometry. Visium spots plotted polygons reflecting actual size relative tissue, rather points, case packages plot Visium data. plotting geometries performed hood geom_sf. tissue boundary found thresholding H&E image removing small polygons likely debris. in_tissue column colData(sfe) indicates Visium spot polygon intersects tissue polygon; can found SpatialFeatureExperiment::annotPred(). demonstrate use scran (Lun2016-yq?) normalization , although note necessarily best approach normalizing spatial transcriptomics data. problem normalize spatial transcriptomics data non-trivial , nCounts plot space shows , spatial autocorrelation evident. Furthemrore, Visium, reverse transcription occurs situ spots, PCR amplification occurs cDNA dissociated spots. Artifacts may subsequently introduced amplification step, associated spatial origin. Spatial artifacts may arise diffusion transcripts tissue permeablization. However, given total counts seem correspond histological regions, total counts may biological component hence treated technical artifact normalized away scRNA-seq data normalization methods. words, issue normalization spatial transcriptomics data, Visium particular, complex currently unsolved. Myofiber nuclei segmentation polygons available dataset annotGeometries field. Myofibers manually segmented, nuclei segmented StarDist trained manually segmented subset.","code":"names(colData(sfe)) #>  [1] \"barcode\"   \"col\"       \"row\"       \"x\"         \"y\"         \"dia\"       #>  [7] \"tissue\"    \"sample_id\" \"nCounts\"   \"nGenes\"    \"prop_mito\" \"in_tissue\" sfe_tissue <- sfe[,colData(sfe)$in_tissue] sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,] #clusters <- quickCluster(sfe_tissue) #sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) #sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) annotGeometryNames(sfe_tissue) #> [1] \"tissueBoundary\"      \"myofiber_full\"       \"myofiber_simplified\" #> [4] \"nuclei\"              \"nuclei_centroid\""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"from-myofibers-and-nuclei-to-visium-spots","dir":"Articles","previous_headings":"Exploratory data analysis > Spots in tissue","what":"From myofibers and nuclei to Visium spots","title":"Spatial Visium exploratory data analysis","text":"plotSpatialFeature() function can also used plot attributes geometries, .e.Â non-geometry columns sf data frames rowGeometries, colGeometries, annotGeometries fields SFE object. rowGeometries colGeometries, columns associated sf data frames rather rowData colData, allowed one can specify columns associate geometries (see st_agr documentation st_sf). attribute annotGeometry plotted along side gene expression colData colGeometry attribute, annotGeometry attribute plotted different color palette distinguish column associated values. myofiber polygons annotGeometries can plotted shown , colored cross section area observed tissue section. aes_use argument set color rather fill (default polygons) plot Visium spot outlines make myofiber polygons visible. fill argument set NA make Visium spots look hollow, size argument controls thickness outlines. annot_aes argument specifies column annotGeometry use specify values aesthstic, just like aes ggplot2 (aes_string precise, since tidyeval used ). annot_fixed argument (used ) can set fixed size, alpha, color, etc. annotGeometry.  larger myofibers seem fewer total counts, possibly larger size myofibers dilutes transcripts. hints need normalization procedure. SpatialFeatureExperiment, can find number myofibers nuclei intersect Visium spot. predicate can anything implemented sf, example, number nuclei fully covered Visium spot can also found. default predicate st_intersects().  one--one mapping Visium spots myofibers. However, can relate attributes myofibers gene expression detected Visium spots. One way summarize attributes myofibers intersect (choose another better predicate implemented sf) spot, calculate mean, median, sum. can done annotSummary() function SpatialFeatureExperiment. default predicate st_intersects(), default summary function mean().  reveals relationship mean area myofibers intersecting Visium spot aspects spots, total counts gene expression. NAs designate spots intersecting myofibers, e.g.Â inflammatory region. Basic Visium vignette, encountered two mysterious branches two clusters nGenes vs.Â nCounts plot proportion mitochondrial counts vs.Â nCounts plot. Now see two clusters seem related myofiber size.","code":"plotSpatialFeature(sfe_tissue, features = \"nCounts\",                     colGeometryName = \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     aes_use = \"color\", linewidth = 0.5, fill = NA,                    annot_aes = list(fill = \"area\")) colData(sfe_tissue)$n_myofibers <-    annotNPred(sfe_tissue, colGeometryName = \"spotPoly\",              annotGeometryName = \"myofiber_simplified\") plotSpatialFeature(sfe_tissue, features = \"n_myofibers\",                     colGeometryName = \"spotPoly\", image = \"lowres\", color = \"black\",                    linewidth = 0.1) colData(sfe_tissue)$mean_myofiber_area <-    annotSummary(sfe_tissue, \"spotPoly\", \"myofiber_simplified\",                 annotColNames = \"area\")[,1] # it always returns a data frame # The gray spots don't intersect any myofiber plotSpatialFeature(sfe_tissue, \"mean_myofiber_area\", \"spotPoly\", image = \"lowres\",                     color = \"black\", linewidth = 0.1) plotColData(sfe_tissue, x = \"nCounts\", y = \"nGenes\", colour_by = \"mean_myofiber_area\") plotColData(sfe_tissue, x = \"nCounts\", y = \"prop_mito\", colour_by = \"mean_myofiber_area\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"myofiber-types","dir":"Articles","previous_headings":"Exploratory data analysis > Spots in tissue","what":"Myofiber types","title":"Spatial Visium exploratory data analysis","text":"Marker genes: Myh7 (Type , slow twitch, aerobic), Myh2 (Type IIa, fast twitch, somewhat aerobic), Myh4 (Type IIb, fast twitch, anareobic), Myh1 (Type IIx, fast twitch, anaerobic), protocol (Wang2017-li?) can use gget search gget info modules gget package get Ensembl IDs additional information (example NCBI description) marker genes: <<<<<<< HEAD <<<<<<< HEAD first examine Type myofibers. fast twitch muscle, donâ€™t expect many slow twitch Type myofibers. Row names sfe_tissue Ensembl IDs order avoid ambiguity sometimes multiple Ensembl IDs gene symbol genes aliases. However, gene symbols shorter human readable Ensembl IDs, better suited display plots. plotSpatialFeature() function functions Voyager, even row names recorded Ensembl IDs, features argument can take gene symbols swap_rownames argument indicating column rowData(sfe) stores gene symbols. Gene symbols also shown plots instead Ensembl IDs. one gene symbol matches multiple Ensembl IDs dataset, warning given. exprs_values argument specifies assay use, default â€œlogcountsâ€, .e.Â log normalized data. default may may suitable practice given total UMI counts may biological relevance spatial data. Therefore, plot raw counts log normalized counts:  marker gene type IIa myofibers shown . straightforward modify plotting display markers type IIb type IIx myofibers:  Type IIa myofibers also tend clustered together left side tissue. SFE inherits SCE, non-spatial EDA plots scater package can also used:  Plotting proportion mitochondrial counts vs.Â mean myofiber area, see two clusters, one higher proportion mitochondrial counts smaller area, another lower proportion mitochondrial counts average slightly larger area. Type IIa myofibers tend smaller area larger proportion mitochondrial counts.","code":"markers <- c(I = \"Myh7\", IIa = \"Myh2\", IIb = \"Myh4\", IIx = \"Myh1\") ======= >>>>>>> documentation gget_search <- gget$search(list(\"Myh7\", \"Myh2\", \"Myh4\", \"Myh1\"), species=\"mouse\") gget_search <- gget_search[gget_search$gene_name %in% list(\"Myh7\", \"Myh2\", \"Myh4\", \"Myh1\"), ] gget_search ======= >>>>>>> documentation gget_info <- gget$info(gget_search$ensembl_id)  rownames(gget_info) <- gget_info$primary_gene_name select(gget_info, ncbi_description) # Function specific for this vignette, with some hard coded values plot_counts_logcounts <- function(sfe, feature) {   p1 <- plotSpatialFeature(sfe, feature, \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"), swap_rownames = \"symbol\",                     exprs_values = \"counts\", aes_use = \"color\", linewidth = 0.5,                    fill = NA) +     ggtitle(\"Raw counts\")   p2 <- plotSpatialFeature(sfe, feature, \"spotPoly\",                    annotGeometryName = \"myofiber_simplified\",                     annot_aes = list(fill = \"area\"), swap_rownames = \"symbol\",                     exprs_values = \"logcounts\", aes_use = \"color\", linewidth = 0.5,                    fill = NA) +     ggtitle(\"Log normalized counts\")   p1 + p2 +     plot_annotation(title = feature) } plot_counts_logcounts(sfe_tissue, markers[\"I\"]) plot_counts_logcounts(sfe_tissue, markers[\"IIa\"]) plotColData(sfe_tissue, x = \"mean_myofiber_area\", y = \"prop_mito\",              colour_by = markers[\"IIa\"], by_exprs_values = \"logcounts\",              swap_rownames = \"symbol\") #> Warning: Removed 36 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"spatial-neighborhood-graphs","dir":"Articles","previous_headings":"","what":"Spatial neighborhood graphs","title":"Spatial Visium exploratory data analysis","text":"spatial neighborhood graph required compute spatial dependency metrics Moranâ€™s Gearyâ€™s C. SpatialFeatureExperiment package wraps methods spdep find spatial neighborhood graphs, stored within SFE object (see spdep documentation gabrielneigh(), knearneigh(), poly2nb(), tri2nb()). Voyager package uses graphs spatial dependency analyses, based spdep first version, methods geospatial packages, also use spatial neighborhood graphs, may added later. Visium, spots hexagonal grid, spatial neighborhood graph straightforward. However, spatial technologies single cell resolution, e.g.Â MERFISH, different methods can used find spatial neighborhood graph. example, method â€œpoly2nbâ€ used myofibers, identifies myofiber polygons physically touch . zero.policy = TRUE allow singletons, .e.Â nodes without neighbors graph; inflamed region, singletons. yet benchmarked spatial neighborhood construction methods determine â€œbestâ€ different technologies; particular method used demonstration purposes may best practice: plotColGraph() function plots graph space associated colGeometry, along geometry interest.  Similarly, plotAnnotGraph() function plots graph associated annotGeometry, along geometry interest.  plotRowGraph yet since havenâ€™t worked dataset spatial graphs related genes relevant, although SFE object supports row graphs.","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) annotGraph(sfe_tissue, \"myofiber_poly2nb\") <-    findSpatialNeighbors(sfe_tissue, type = \"myofiber_simplified\", MARGIN = 3,                        method = \"poly2nb\", zero.policy = TRUE) #> Warning in (function (pl, row.names = NULL, snap = NULL, queen = TRUE, useC = TRUE, : some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning in (function (pl, row.names = NULL, snap = NULL, queen = TRUE, useC = TRUE, : neighbour object has 75 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. plotColGraph(sfe_tissue, colGraphName = \"visium\", colGeometryName = \"spotPoly\") +     theme_void() plotAnnotGraph(sfe_tissue, annotGraphName = \"myofiber_poly2nb\",                 annotGeometryName = \"myofiber_simplified\") + theme_void()"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"exploratory-spatial-data-analysis","dir":"Articles","previous_headings":"","what":"Exploratory spatial data analysis","title":"Spatial Visium exploratory data analysis","text":"spatial autocorrelation metrics package can computed directly vector matrix rather SFE object. user interface emulates dimension reductions scater package (e.g.Â calculateUMAP() takes matrix SCE object returns matrix, runUMAP() takes SCE object adds results reducedDims field SCE object). calculate* functions take matrix SFE object directly return results (format results depends structure results), run* functions take SFE object add results object. addition, colData* functions compute metrics numeric variables colData. colGeometry* functions compute metrics numeric columns colGeometry. annotGeometry* functions compute metrics numeric columns annotGeometry.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"univariate-global","dir":"Articles","previous_headings":"","what":"Univariate global","title":"Spatial Visium exploratory data analysis","text":"Voyager supports many univariate global spatial autocorrelation implemented spdep ESDA: Moranâ€™s Gearyâ€™s C, permutation testing Moranâ€™s Gearyâ€™s C, Moran plot, correlograms. addition, beyond spdep, Voyager can cluster Moran plots correlograms. Plotting functions taking SFE objects implemented plot results ggplot2 customization options spdep plotting functions. functions calculateUnivariate(), runUnivariate(), colDataUnivariate(), colGeometryUnivariate(), annotGeometryUnivariate() compute univariate spatial statistics. argument type, indicates corresponding function names spdep, determines spatial statistics computed. univariate global methods Voyager listed : calling calculate*variate() run*variate(), type (2nd) argument takes either SFEMethod object (see SFEMethod() vignette SFEMethod) string matches entry name column data frame returned listSFEMethods(). demonstrate spatial autocorrelation gene expression, top highly variable genes (HVGs) used. HVGs found scran method. global statistic yields one result entire dataset.","code":"listSFEMethods(variate = \"uni\", scope = \"global\") #>              name                                           description #> 1           moran                                             Moran's I #> 2           geary                                             Geary's C #> 3        moran.mc                    Moran's I with permutation testing #> 4        geary.mc                    Geary's C with permutation testing #> 5    sp.mantel.mc Mantel-Hubert spatial general cross product statistic #> 6      moran.test                                        Moran's I test #> 7      geary.test                                        Geary's C test #> 8    globalG.test                                         Global G test #> 9  sp.correlogram                                           Correlogram #> 10      variogram                                  Variogram with model #> 11  variogram_map                                         Variogram map dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 50)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"morans-i","dir":"Articles","previous_headings":"Univariate global","what":"Moranâ€™s I","title":"Spatial Visium exploratory data analysis","text":"several ways quantify spatial autocorrelation, common Moranâ€™s : =nâˆ‘=1nâˆ‘j=1nwijâˆ‘=1nâˆ‘j=1nwij(xiâˆ’xâ€¾)(xjâˆ’xâ€¾)âˆ‘=1n(xiâˆ’xâ€¾)2, = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}, nn number spots locations, ii jj different locations, spots Visium context, xx variable values location, wijw_{ij} spatial weight, can inversely proportional distance spots indicator whether two spots neighbors, subject various definitions neighborhood whether normalize number neighbors. spdep package uses neighborhood. Moranâ€™s can understood Pearson correlation value location average value neighbors. Just like Pearson correlation, Moranâ€™s generally bound -1 1, positive value indicates positive spatial autocorrelation negative value indicates negative spatial autocorrelation. Upon visual inspection, total UMI counts per spot seem spatial autocorrelation. spatial neighborhood graph required compute Moranâ€™s , specified listw argument. matrices, rows features, gene count matrix. â€œmoranâ€ Moranâ€™s , K sample kurtosis. add results SFE object, specifically colData: colData, results added colFeatureData(sfe), features Moranâ€™s calculated NA. column names featureData distinguishes different samples (â€™s one sample dataset), parsed plotting functions. add results SFE object, specifically geometries: â€œareaâ€ area cross section myofiber seen tissue section â€œeccentricityâ€ eccentricity ellipse fitted myofiber. non-geometry column colGeometry, colGeometryUnivariate() like annotGeometryUnivariate() , none colGeometries dataset extra columns. gene expression, logcounts assay used default (use exprs_values argument change assay), though may may best practice. metrics computed large number features, parallel computing supported, BiocParallel, BPPARAM argument.","code":"# Directly use vector or matrix, and multiple features can be specified at once calculateUnivariate(t(colData(sfe_tissue)[,c(\"nCounts\", \"nGenes\")]),                      type = \"moran\",                     listw = colGraph(sfe_tissue, \"visium\")) #> DataFrame with 2 rows and 2 columns #>             moran         K #>         <numeric> <numeric> #> nCounts  0.528705   3.00082 #> nGenes   0.384028   3.88036 sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                 colGraphName = \"visium\", type = \"moran\") colFeatureData(sfe_tissue)[c(\"nCounts\", \"nGenes\"),] #> DataFrame with 2 rows and 2 columns #>         moran_Vis5A   K_Vis5A #>           <numeric> <numeric> #> nCounts    0.528705   3.00082 #> nGenes     0.384028   3.88036 # Remember zero.policy = TRUE since there're singletons sfe_tissue <- annotGeometryUnivariate(sfe_tissue, type = \"moran\",                                       features = c(\"area\", \"eccentricity\"),                                        annotGeometryName = \"myofiber_simplified\",                                       annotGraphName = \"myofiber_poly2nb\",                                        zero.policy = TRUE) head(attr(annotGeometry(sfe_tissue, \"myofiber_simplified\"), \"featureData\")) #> DataFrame with 6 rows and 2 columns #>              moran_Vis5A   K_Vis5A #>                <numeric> <numeric> #> lyr.1                 NA        NA #> area            0.327888   4.95675 #> perimeter             NA        NA #> eccentricity    0.110938   3.26913 #> theta                 NA        NA #> sine_theta            NA        NA sfe_tissue <- runUnivariate(sfe_tissue, type = \"moran\", features = hvgs,                              colGraphName = \"visium\",                              BPPARAM = MulticoreParam(2)) rowData(sfe_tissue)[head(hvgs),] #> DataFrame with 6 rows and 8 columns #>                               Ensembl      symbol            type     means #>                           <character> <character>     <character> <numeric> #> ENSMUSG00000029304 ENSMUSG00000029304        Spp1 Gene Expression   1.63722 #> ENSMUSG00000050708 ENSMUSG00000050708        Ftl1 Gene Expression   2.37981 #> ENSMUSG00000050335 ENSMUSG00000050335      Lgals3 Gene Expression   1.43189 #> ENSMUSG00000021939 ENSMUSG00000021939        Ctsb Gene Expression   2.73117 #> ENSMUSG00000021190 ENSMUSG00000021190        Lgmn Gene Expression   1.11278 #> ENSMUSG00000018893 ENSMUSG00000018893          Mb Gene Expression   2.11118 #>                         vars       cv2 moran_Vis5A   K_Vis5A #>                    <numeric> <numeric>   <numeric> <numeric> #> ENSMUSG00000029304   60.1583   22.4430    0.734937   1.63516 #> ENSMUSG00000050708  162.1931   28.6384    0.665563   1.81841 #> ENSMUSG00000050335   48.0739   23.4471    0.741474   1.68098 #> ENSMUSG00000021939  131.6232   17.6455    0.708362   1.86896 #> ENSMUSG00000021190   21.4505   17.3228    0.659916   1.66838 #> ENSMUSG00000018893   74.1782   16.6428    0.675840   1.82510"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"gearys-c","dir":"Articles","previous_headings":"Univariate global","what":"Gearyâ€™s C","title":"Spatial Visium exploratory data analysis","text":"Another spatial autocorrelation metric Gearyâ€™s C, defined : C=(nâˆ’1)2âˆ‘=1nâˆ‘j=1nwijâˆ‘=1nâˆ‘j=1nwij(xiâˆ’xj)2âˆ‘=1n(xiâˆ’xâ€¾)2 C = \\frac{(n-1)}{2\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}(x_i - x_j)^2}{{\\sum_{=1}^n (x_i - \\bar{x})^2}} Gearyâ€™s C 1 indicates positive spatial autocorrelation, 1 indicates negative spatial autocorrelation. compute Gearyâ€™s C features interest replace type = \"moran\" previous section type = \"geary\", add results SFE object. example, colData â€™s one column K since â€™s Moranâ€™s Gearyâ€™s C. Moranâ€™s Gearyâ€™s C suggest positive spatial autocorrelation nCounts nGenes. univariate global methods, including permutation testing Moranâ€™s Gearyâ€™s C, correlograms, Moran scatter plot can also called functions runUnivariate, specifying type argument. See documentation runUnivariate see available methods see documentation corresponding spdep functions see extra arguments required method.","code":"sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                 colGraphName = \"visium\", type = \"geary\") colFeatureData(sfe_tissue)[c(\"nCounts\", \"nGenes\"),] #> DataFrame with 2 rows and 3 columns #>         moran_Vis5A   K_Vis5A geary_Vis5A #>           <numeric> <numeric>   <numeric> #> nCounts    0.528705   3.00082    0.474892 #> nGenes     0.384028   3.88036    0.605797"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"permutation-testing","dir":"Articles","previous_headings":"Univariate global","what":"Permutation testing","title":"Spatial Visium exploratory data analysis","text":"establish whether spatial autocorrelation statistically significant, moran.test() function spdep can used. provides p-value, p-value may accurate data normally distributed. gene expression data generally normally distributed data normalization doesnâ€™t always work well, use permutation testing test significance Moranâ€™s Gearyâ€™s C, wrapping moran.mc() spdep. â€œmcâ€ stands Monte Carlo. nsim argument specifies number simulations. following adds results SFE object: Note test performed multiple features, p-values corrected multiple hypothesis testing. results can plotted:  default, colorblind friendly palette dittoSeq used categorical variables. density plot Moranâ€™s simulations values permuted disconnected spatial locations, vertical line actual Moranâ€™s value. simulation indicates actual Moranâ€™s much higher simulations values dissociated spatial locations permuted among locations, indicating spatial autocorrelation significant. Use type = \"geary.mc\" permutation testing Gearyâ€™s C. spdep package can also compute p-values Moranâ€™s analytically, theory behind mean variance null distribution Moranâ€™s assumes normal distribution data, gene expression data generally non-normal. However, according (Griffith2010-uy?), large sample size (â€œpreferably least 100â€), mean variance Moranâ€™s several iid non-normal simulated datasets (including negative binomial, commonly used model gene expression data) donâ€™t seem deviate much values expected normally distributed data. Spatial transcriptomics datasets typically thousands spots cells, sample size likely large enough. Hence using analytical test non-normal data might bad. However, large sample size, minuscule difference can create significant p-values. perform analytical test Moranâ€™s : Now compare p-values permutation analytical test; cases , default alternative hypothesis positive spatial autocorrelation: p-values permutation limited number permutations (1000 ). Either way, permutation analytical tests indicate significant positive spatial autocorrelation. limitation permutation testing Moranâ€™s assumes permutation values among locations equally likely, necessarily true. instance, epidemiology, disease rate regions small population likely assumes extreme values (Assuncao1999-xu?), analogous rare cell types lowly expressed genes histological space given divide total UMI counts per spot. extent happens may depend tissue, gene interest, technology, data normalization method.","code":"set.seed(29) sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                  colGraphName = \"visium\", nsim = 1000,                                 type = \"moran.mc\") colFeatureData(sfe_tissue)[c(\"nCounts\", \"nGenes\"),] #> DataFrame with 2 rows and 9 columns #>         moran_Vis5A   K_Vis5A geary_Vis5A moran.mc_statistic_Vis5A #>           <numeric> <numeric>   <numeric>                <numeric> #> nCounts    0.528705   3.00082    0.474892                 0.528705 #> nGenes     0.384028   3.88036    0.605797                 0.384028 #>         moran.mc_parameter_Vis5A moran.mc_p.value_Vis5A #>                        <numeric>              <numeric> #> nCounts                     1001            0.000999001 #> nGenes                      1001            0.000999001 #>         moran.mc_alternative_Vis5A  moran.mc_method_Vis5A #>                        <character>            <character> #> nCounts                    greater Monte-Carlo simulati.. #> nGenes                     greater Monte-Carlo simulati.. #>                                 moran.mc_res_Vis5A #>                                             <list> #> nCounts    -0.01090202, 0.00921862,-0.00293951,... #> nGenes  -0.000585631, 0.035577943,-0.002816707,... plotMoranMC(sfe_tissue, c(\"nCounts\", \"nGenes\")) sfe_tissue <- colDataUnivariate(sfe_tissue, features = c(\"nCounts\", \"nGenes\"),                                  colGraphName = \"visium\", type = \"moran.test\") names(colFeatureData(sfe_tissue)) #>  [1] \"moran_Vis5A\"                        \"K_Vis5A\"                            #>  [3] \"geary_Vis5A\"                        \"moran.mc_statistic_Vis5A\"           #>  [5] \"moran.mc_parameter_Vis5A\"           \"moran.mc_p.value_Vis5A\"             #>  [7] \"moran.mc_alternative_Vis5A\"         \"moran.mc_method_Vis5A\"              #>  [9] \"moran.mc_res_Vis5A\"                 \"moran.test_statistic_Vis5A\"         #> [11] \"moran.test_p.value_Vis5A\"           \"moran.test_alternative_Vis5A\"       #> [13] \"moran.test_method_Vis5A\"            \"moran.test_Moran.I.statistic_Vis5A\" #> [15] \"moran.test_Expectation_Vis5A\"       \"moran.test_Variance_Vis5A\" # permutation colFeatureData(sfe_tissue)[c(\"nCounts\", \"nGenes\"), c(\"moran.mc_p.value_Vis5A\", \"moran.test_p.value_Vis5A\")] #> DataFrame with 2 rows and 2 columns #>         moran.mc_p.value_Vis5A moran.test_p.value_Vis5A #>                      <numeric>                <numeric> #> nCounts            0.000999001             5.41958e-163 #> nGenes             0.000999001              2.82666e-87"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"correlogram","dir":"Articles","previous_headings":"Univariate global","what":"Correlogram","title":"Spatial Visium exploratory data analysis","text":"correlogram, spatial autocorrelation higher orders neighbors (e.g.Â second order neighbors neighbors neighbors) calculated see decays orders. Visium, regular hexagonal grid, order neighbors proxy distance. irregular patterns single cells, different methods find spatial neighbors may give different results. colData, Moranâ€™s correlogram computed results can plotted plotCorrelogram:  error bars twice standard deviation Moranâ€™s value. standard deviation p-values (null hypothesis Moranâ€™s 0) come moran.test() (Gearyâ€™s C correlogram, geary.test()); taken grain salt data normally distributed. p-values corrected multiple hypothesis testing across orders features. usual, . means p < 0.1, * means p < 0.05, ** means p < 0.01, *** means p < 0.001. , can done Gearyâ€™s C, colData, annotGeometry, etc.","code":"sfe_tissue <- runUnivariate(sfe_tissue, hvgs[1:2], colGraphName = \"visium\",                              order = 10, type = \"sp.correlogram\") plotCorrelogram(sfe_tissue, hvgs[1:2], swap_rownames = \"symbol\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"univariate-local","dir":"Articles","previous_headings":"","what":"Univariate local","title":"Spatial Visium exploratory data analysis","text":"Local statistics yield result location rather whole dataset, global statistics may obscure local heterogeneity. See (Fotheringham2009-ak?) interesting discussion relationships global local spatial statistics. Local statistics stored localResults field SFE object, can accessed localResult() localResults() functions SpatialFeatureExperiment package. univariate local methods Voyager listed :","code":"listSFEMethods(variate = \"uni\", scope = \"local\") #>               name                                          description #> 1       localmoran                                      Local Moran's I #> 2  localmoran_perm                  Local Moran's I permutation testing #> 3           localC                                      Local Geary's C #> 4      localC_perm                  Local Geary's C permutation testing #> 5           localG                                      Getis-Ord Gi(*) #> 6      localG_perm             Getis-Ord Gi(*) with permutation testing #> 7             LOSH                     Local spatial heteroscedasticity #> 8          LOSH.mc Local spatial heteroscedasticity permutation testing #> 9          LOSH.cs     Local spatial heteroscedasticity Chi-square test #> 10      moran.plot                                   Moran scatter plot"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"moran-scatter-plot","dir":"Articles","previous_headings":"Univariate local","what":"Moran scatter plot","title":"Spatial Visium exploratory data analysis","text":"Moran scatter plot (Anselin1996-mo?), x axis value spot, y axis average value neighbors. slope fitted line Moranâ€™s . Sometimes clusters appear plot, showing different kinds neighborhoods. gene expression, use one gene (log normalized value) demonstrate:  dashed lines mark mean Myh2 spatially lagged Myh2. singletons . Visium spots lower Myh2 expression neighbors donâ€™t express Myh2 spots donâ€™t express Myh2 usually least neighbors . twp main clusters spots whose neighbors express Myh2: high (average) expression whose neighbors also high expression, low expression whose neighbors also low expression. features may show different kinds clusters. can use k-means clustering identify clusters, though clustering method supported bluster package can used. can use gget search module get Ensembl ID Myh2: <<<<<<< HEAD  Plot clusters space  can also done colData, annotGeometry, etc. Moranâ€™s permutation testing.","code":"sfe_tissue <- runUnivariate(sfe_tissue, \"Myh2\", colGraphName = \"visium\",                              type = \"moran.plot\", swap_rownames = \"symbol\") moranPlot(sfe_tissue, \"Myh2\", graphName = \"visium\", swap_rownames = \"symbol\") set.seed(29) clusts <- clusterMoranPlot(sfe_tissue, \"Myh2\", BLUSPARAM = KmeansParam(2),                            swap_rownames = \"symbol\") ======= >>>>>>> documentation gget$search(\"Myh2\", species=\"mouse\") moranPlot(sfe_tissue, \"Myh2\", graphName = \"visium\",            color_by = clusts$ENSMUSG00000033196, swap_rownames = \"symbol\") colData(sfe_tissue)$Myh2_moranPlot_clust <- clusts$ENSMUSG00000033196 plotSpatialFeature(sfe_tissue, \"Myh2_moranPlot_clust\", colGeometryName = \"spotPoly\",                    image = \"lowres\", color = \"black\", linewidth = 0.1)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"local-morans-i","dir":"Articles","previous_headings":"Univariate local","what":"Local Moranâ€™s I","title":"Spatial Visium exploratory data analysis","text":"recap, global Moranâ€™s defined =nâˆ‘=1nâˆ‘j=1nwijâˆ‘=1nâˆ‘j=1nwij(xiâˆ’xâ€¾)(xjâˆ’xâ€¾)âˆ‘=1n(xiâˆ’xâ€¾)2. = \\frac{n}{\\sum_{=1}^n \\sum_{j=1}^n w_{ij}} \\frac{\\sum_{=1}^n \\sum_{j=1}^n w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. Local Moranâ€™s (Anselin1995-cs?) defined Ii=(nâˆ’1)(xiâˆ’xâ€¾)âˆ‘j=1nwij(xjâˆ’xâ€¾)âˆ‘=1n(xiâˆ’xâ€¾)2. I_i = (n-1)\\frac{(x_i - \\bar{x})\\sum_{j=1}^n w_{ij} (x_j - \\bar{x})}{\\sum_{=1}^n (x_i - \\bar{x})^2}. â€™s similar global Moranâ€™s , values locations ii summed â€™s normalization sum spatial weights. useful plot log normalized Myh2 gene expression context interpret local results:   see regions higher Myh2 expression also stronger spatial autocorrelation. interesting see spatial autocorrelation relates gene expression level, much finding variance relates mean expression gene, usually indicates overdispersion compared Poisson scRNA-seq Visium data:  gene, Visium spots higher expression also tend higher local Moranâ€™s , may may apply genes. Local spatial analyses often return matrix data frame. plotLocalResult() function default column local spatial method, columns can plotted well. Use localResultAttrs() function see columns present, use attribute argument specify column plot. local spatial methods return p-values location, column name like Pr(z != E(Ii)), test two sided (default, can changed alternative argument runUnivariate() passed relevant underlying function spdep). Negative log p-value computed facilitate visualization, p-value corrected multiple hypothesis testing p.adjustSP() spdep, number tests number neighbors location rather total number locations (-log10p_adj).  plot following plots p-values, divergent palette used show locations significant adjusting multiple testing significant different colors. center divergent palette p = 0.05, brown spots significant dark blue means really significant. â€œpysalâ€ column displays quadrants relative means Moran plot. result similar k-means clustering shown .","code":"sfe_tissue <- runUnivariate(sfe_tissue, type = \"localmoran\", features = \"Myh2\",                             colGraphName = \"visium\", swap_rownames = \"symbol\") plotSpatialFeature(sfe_tissue, features = \"Myh2\", colGeometryName = \"spotPoly\",                    swap_rownames = \"symbol\", image_id = \"lowres\", color = \"black\",                    linewidth = 0.1) plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\",divergent = TRUE,                 diverge_center = 0, image_id = \"lowres\",                  swap_rownames = \"symbol\", color = \"black\",                 linewidth = 0.1) df <- data.frame(myh2 = logcounts(sfe_tissue)[rowData(sfe_tissue)$symbol == \"Myh2\",],                  Ii = localResult(sfe_tissue, \"localmoran\", \"Myh2\",                                    swap_rownames = \"symbol\")[,\"Ii\"]) ggplot(df, aes(myh2, Ii)) + geom_point(alpha = 0.3) +     labs(x = \"Myh2 (log counts)\", y = \"localmoran\") localResultAttrs(sfe_tissue, \"localmoran\", \"Myh2\", swap_rownames = \"symbol\") #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\" plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"-log10p_adj\", divergent = TRUE,                 diverge_center = -log10(0.05), swap_rownames = \"symbol\",                 image_id = \"lowres\", color = \"black\",                 linewidth = 0.1) plotLocalResult(sfe_tissue, \"localmoran\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", attribute = \"pysal\",                  swap_rownames = \"symbol\", image_id = \"lowres\", color = \"black\",                 linewidth = 0.1)"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"getis-ord-gi","dir":"Articles","previous_headings":"Univariate local","what":"Getis-Ord Gi*","title":"Spatial Visium exploratory data analysis","text":"Getis-Ord Gi* used find hotspots coldspots feature space. hotspot cluster high values space, coldspot cluster low values space. Getis-Ord Gi* essentially z-score spatially lagged value feature location ii (âˆ‘jwijxj\\sum_j w_{ij} x_j), wijw_{ij} spatial weight. original publication Getis-Ord Gi* 1992 (Getis1992-fr?), spatial weight distance-based binary weight indicating whether another location within certain distance location ii. Getis-Ord Gi excludes location ii computation mean variance lagged value, Gi* includes location ii . Usually Gi Gi* yield similar results. mean variance used z-score differ Gi Gi* described paper 1995 (Ord1995-?) derived (Getis1992-fr?). Binary weights recommended Getis-Ord Gi*.  High values Gi* indicate hotspots, low values Gi* indicate coldspots. Plot pseudo-p-values simulation  hotspots expected. warm color indicates adjusted p<0.05p < 0.05. Local results can also computed annotation geometries.   hotspots coldspots expected. Warm color indicates adjusted p<0.05p < 0.05.","code":"colGraph(sfe_tissue, \"visium_B\") <- findVisiumGraph(sfe_tissue, style = \"B\") sfe_tissue <- runUnivariate(sfe_tissue, type = \"localG_perm\", features = \"Myh2\",                             colGraphName = \"visium_B\", include_self = TRUE,                             swap_rownames = \"symbol\") plotLocalResult(sfe_tissue, \"localG_perm\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", divergent = TRUE,                 diverge_center = 0, image_id = \"lowres\", swap_rownames = \"symbol\",                  color = \"black\", linewidth = 0.1) localResultAttrs(sfe_tissue, \"localG_perm\", \"Myh2\", swap_rownames = \"symbol\") #>  [1] \"localG\"             \"Gi\"                 \"E.Gi\"               #>  [4] \"Var.Gi\"             \"StdDev.Gi\"          \"Pr(z != E(Gi))\"     #>  [7] \"Pr(z != E(Gi)) Sim\" \"Pr(folded) Sim\"     \"Skewness\"           #> [10] \"Kurtosis\"           \"-log10p Sim\"        \"-log10p_adj Sim\"    #> [13] \"cluster\" plotLocalResult(sfe_tissue, \"localG_perm\", features = \"Myh2\",                  attribute = \"-log10p_adj Sim\",                 colGeometryName = \"spotPoly\", divergent = TRUE,                 diverge_center = -log10(0.05), swap_rownames = \"symbol\",                 image_id = \"lowres\") annotGraph(sfe_tissue, \"myofiber_poly2nb_B\") <-    findSpatialNeighbors(sfe_tissue, type = \"myofiber_simplified\", MARGIN = 3,                        method = \"poly2nb\", zero.policy = TRUE, style = \"B\") #> Warning in (function (pl, row.names = NULL, snap = NULL, queen = TRUE, useC = TRUE, : some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning in (function (pl, row.names = NULL, snap = NULL, queen = TRUE, useC = TRUE, : neighbour object has 75 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. sfe_tissue <- annotGeometryUnivariate(sfe_tissue, \"localG_perm\", \"area\",                                        annotGeometryName = \"myofiber_simplified\",                                       annotGraphName = \"myofiber_poly2nb_B\",                                       include_self = TRUE, zero.policy = TRUE) plotLocalResult(sfe_tissue, \"localG_perm\", \"area\",                  annotGeometryName = \"myofiber_simplified\",                 divergent = TRUE, diverge_center = 0) plotLocalResult(sfe_tissue, \"localG_perm\", \"area\",                  annotGeometryName = \"myofiber_simplified\",                 attribute = \"-log10p_adj Sim\",                 divergent = TRUE, diverge_center = -log10(0.05))"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"local-spatial-heteroscedasticity-losh","dir":"Articles","previous_headings":"Univariate local","what":"Local spatial heteroscedasticity (LOSH)","title":"Spatial Visium exploratory data analysis","text":"LOSH (Ord2012-qi?) defined Hi=âˆ‘jwij|ej|ah1âˆ‘jwij H_i = \\frac{\\sum_j w_{ij}\\left| e_j \\right|^}{h_1\\sum_j w_{ij}} whereh1=âˆ‘|ei|/nh_1 = \\sum_i \\left| e_i \\right|^/n, ej=xjâˆ’xâ€¾je_j = x_j - \\bar{x}_j, xâ€¾j=âˆ‘jwjkxkâˆ‘jwjk. \\bar{x}_j = \\frac{\\sum_j w_{jk}x_k}{\\sum_j w_{jk}}. default, =2a = 2 LOSH like local variance. See (Ord2012-qi?) details interpretation.  gene, isnâ€™t clear whether LOSH relates gene expression levels. Voyager wrap LOSH.mc() perform permutation testing LOSH, time consuming. chi-squared approximation described 2012 LOSH paper account non-normality data approximate mean variance permutation distributions, p-values LOSH can quickly computed, LOSH.cs().  gene, local conditions mostly homogenous, except spots injury site. Warm color indicates adjusted p<0.05p < 0.05.","code":"sfe_tissue <- runUnivariate(sfe_tissue, \"LOSH.cs\", \"Myh2\",                              colGraphName = \"visium\", swap_rownames = \"symbol\") plotLocalResult(sfe_tissue, \"LOSH.cs\", features = \"Myh2\",                  colGeometryName = \"spotPoly\", swap_rownames = \"symbol\",                 image_id = \"lowres\") localResultAttrs(sfe_tissue, \"LOSH.cs\", \"Myh2\", swap_rownames = \"symbol\") #> [1] \"Hi\"          \"E.Hi\"        \"Var.Hi\"      \"Z.Hi\"        \"x_bar_i\"     #> [6] \"ei\"          \"Pr()\"        \"-log10p\"     \"-log10p_adj\" plotLocalResult(sfe_tissue, \"LOSH.cs\", features = \"Myh2\",                  attribute = \"-log10p_adj\", colGeometryName = \"spotPoly\",                 divergent = TRUE, diverge_center = -log10(0.05),                 swap_rownames = \"symbol\", image_id = \"lowres\") +     theme_void()"},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"caveats","dir":"Articles","previous_headings":"","what":"Caveats","title":"Spatial Visium exploratory data analysis","text":"H&E image can alter perception colors geometries. 2D data supported present, although principle, sf GEOS support 3D data. Spatial neighborhoods make sense within tissue section. multiple tissue sections, biological replica, different conditions? mouse brain, different biological replica can registered Allen Common Coordinate Framework (CCF) spatially comparable. Indeed, interesting see biological variability healthy wild type gene expression fine scaled region brain. However, CCF tissues without stereotypical structure, adipose skeletal muscle. donâ€™t good solution spatially compare different tissue sections yet. Perhaps global spatial statistics whole section histological regions within section can compared. problem remains select informative metrics compare. Perhaps spatially-informed dimension reduction method, taking gene count matrix, also adjacency matrices spatial neighborhood graphs (different sections different blocks matrix) projecting cells Visium spots different sections shared low dimensional space can facilitate comparison. batch effect must corrected, dimension reduction interpretable, scalable.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig2_visium.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Spatial Visium exploratory data analysis","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] reticulate_1.40.0              dplyr_1.1.4                    #>  [3] bluster_1.16.0                 BiocParallel_1.40.0            #>  [5] patchwork_1.3.0                scales_1.3.0                   #>  [7] sf_1.0-19                      SFEData_1.8.0                  #>  [9] scran_1.34.0                   scater_1.34.0                  #> [11] ggplot2_3.5.1                  scuttle_1.16.0                 #> [13] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [15] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [17] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [19] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [21] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [23] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             filelock_1.0.3            #>   [3] bitops_1.0-9              tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] edgeR_4.4.0               lattice_0.22-6            #>   [9] MASS_7.3-61               magrittr_2.0.3            #>  [11] limma_3.62.1              sass_0.4.9                #>  [13] rmarkdown_2.29            jquerylib_0.1.4           #>  [15] yaml_2.3.10               metapod_1.14.0            #>  [17] sp_2.1-4                  cowplot_1.1.3             #>  [19] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] purrr_1.0.2               R.utils_2.12.3            #>  [27] RCurl_1.98-1.16           TH.data_1.1-2             #>  [29] rappdirs_0.3.3            sandwich_3.1-1            #>  [31] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [33] irlba_2.3.5.1             terra_1.7-83              #>  [35] units_0.8-5               RSpectra_0.16-2           #>  [37] dqrng_0.4.1               pkgdown_2.1.1             #>  [39] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [41] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [43] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [45] memuse_4.2-3              farver_2.1.2              #>  [47] ScaledMatrix_1.14.0       viridis_0.6.5             #>  [49] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [51] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [53] survival_3.7-0            systemfonts_1.1.0         #>  [55] dbscan_1.2-0              tools_4.4.2               #>  [57] ggnewscale_0.5.0          ragg_1.3.3                #>  [59] Rcpp_1.0.13-1             glue_1.8.0                #>  [61] gridExtra_2.3             SparseArray_1.6.0         #>  [63] mgcv_1.9-1                xfun_0.49                 #>  [65] EBImage_4.48.0            HDF5Array_1.34.0          #>  [67] withr_3.0.2               BiocManager_1.30.25       #>  [69] fastmap_1.2.0             boot_1.3-31               #>  [71] rhdf5filters_1.18.0       fansi_1.0.6               #>  [73] spData_2.3.3              digest_0.6.37             #>  [75] rsvd_1.0.5                mime_0.12                 #>  [77] R6_2.5.1                  textshaping_0.4.0         #>  [79] colorspace_2.1-1          wk_0.9.4                  #>  [81] LearnBayes_2.15.1         jpeg_0.1-10               #>  [83] RSQLite_2.3.8             R.methodsS3_1.8.2         #>  [85] utf8_1.2.4                generics_0.1.3            #>  [87] data.table_1.16.2         class_7.3-22              #>  [89] httr_1.4.7                htmlwidgets_1.6.4         #>  [91] S4Arrays_1.6.0            spdep_1.3-6               #>  [93] pkgconfig_2.0.3           scico_1.5.0               #>  [95] gtable_0.3.6              blob_1.2.4                #>  [97] XVector_0.46.0            htmltools_0.5.8.1         #>  [99] fftwtools_0.9-11          png_0.1-8                 #> [101] SpatialExperiment_1.16.0  knitr_1.49                #> [103] rjson_0.2.23              curl_6.0.1                #> [105] coda_0.19-4.1             nlme_3.1-166              #> [107] proxy_0.4-27              cachem_1.1.0              #> [109] zoo_1.8-12                rhdf5_2.50.0              #> [111] BiocVersion_3.20.0        KernSmooth_2.23-24        #> [113] parallel_4.4.2            vipor_0.4.7               #> [115] AnnotationDbi_1.68.0      desc_1.4.3                #> [117] s2_1.1.7                  pillar_1.9.0              #> [119] grid_4.4.2                vctrs_0.6.5               #> [121] BiocSingular_1.22.0       dbplyr_2.5.0              #> [123] beachmat_2.22.0           sfheaders_0.4.4           #> [125] cluster_2.1.6             beeswarm_0.4.0            #> [127] evaluate_1.0.1            isoband_0.2.7             #> [129] zeallot_0.1.0             magick_2.8.5              #> [131] mvtnorm_1.3-2             cli_3.6.3                 #> [133] locfit_1.5-9.10           compiler_4.4.2            #> [135] rlang_1.1.4               crayon_1.5.3              #> [137] labeling_0.4.3            classInt_0.4-10           #> [139] fs_1.6.5                  ggbeeswarm_0.7.2          #> [141] viridisLite_0.4.2         deldir_2.0-4              #> [143] Biostrings_2.74.0         munsell_0.5.1             #> [145] tiff_0.1-12               Matrix_1.7-1              #> [147] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [149] bit64_4.5.2               Rhdf5lib_1.28.0           #> [151] KEGGREST_1.46.0           statmod_1.5.0             #> [153] AnnotationHub_3.14.0      igraph_2.1.1              #> [155] memoise_2.0.1             bslib_0.8.0               #> [157] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Slide-seq V2 spatial transcriptomic tool measures genome-wide expression using DNA-barcoded beads patterned slide non-regular array. beads used current protocol diameter 10Î¼m10 \\mu m thus larger single cell, number detected transcripts order magnitude higher compared previous iteration technology. vignette, use Voyager analyze dataset generated using Slide-Seq V2 technology. data described Dissecting treatment-naive ecosystem human melanoma brain metastasis (Biermann2022-cu?). raw counts cell metadata publicly available GEO. focus one human melanoma brain metastasis (MBM) samples provided SFEData package SpatialFeatureExperiment(SFE) object. SFE object contains raw counts, QC metrics number UMIs genes detected per barcode, centroid coordinates barcode sf POINT geometry. SFE object SFEData package includes information 27,566 features 29,536 beads/barcodes.","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater) library(scran) library(bluster) library(ggplot2) library(patchwork) library(spdep) library(BiocParallel)  theme_set(theme_bw()) (sfe <- BiermannMelaMetasData(dataset = \"MBM05_rep1\")) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 27566 29536  #> metadata(0): #> assays(1): counts #> rownames(27566): A1BG A1BG-AS1 ... ZZZ3 snoZ196 #> rowData names(3): means vars cv2 #> colnames(29536): ACCACTCATTTCTC-1 GTTCANTCCACGTA-1 ... ACGCGCAATCGTAG-1 #>   TTGTTCCGTTCATA-1 #> colData names(4): sample_id nCounts nGenes prop_mito #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : xcoord ycoord #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01:"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"quality-control-qc","dir":"Articles","previous_headings":"","what":"Quality control (QC)","title":"Slide-Seq V2 Exploratory Data Analysis","text":"begin performing exploratory data analysis barcodes tissue. pre-computed QC measures stored object. Total UMI counts (nCounts), number genes detected per spot (nGenes), proportion mitochondrially encoded counts (prop_mito). , plot total number UMI counts per barcode violin plot space. latter task, leverage function plotSpatialFeature() uses geom_sf() plot geometries applicable. first lines compute average number UMI counts per barcode average plotted red line violin plot.  barcode represented sf POINT geometry plot , note many beads quite low UMI counts, small regions throughout tissue appear high counts. perhaps due high cellular density melanoma cells, can speculate without image tissue. Interestingly, barcodes zero counts. contrast many scRNA-seq dataset many cells zero counts. Given density points, may choose aggregate points hexagonal grid avoid overplotting. hexagon colored total number UMI counts space hexagon may represent one barcode.  worthwhile note cell segmentation data included dataset. Even though Slide-Seq V2 profile gene expression single cell resolution, cell segmentation data can flexibly stored annotGeometries SFE object. geometries can plotted barcode-level data can used sf operations like finding number barcodes localized single cell.  plot visualizes number UMI counts per barcode log scale. appears barcodes higher counts co-localized regions throughout tissue, however, regions rather small may suggest spatial autocorrelation. Next find number genes detected per barcode. , QC feature provided nGenes colData attribute barcodes.  Similar number UMI counts per barcode, seem small regions higher number genes throughout tissue. may correspond regions cellular diversity high cellular density, might expected context melanoma. can compute degree number UMI counts per barcode depends spatial location measurement. relationship, spatial autocorrelation, can quantified using Moranâ€™s index spatial autocorrelation, Moranâ€™s . computation Moranâ€™s requires first definition constitutes objects â€œnearâ€ . simply, represented spatial weights matrix. One possible representation adjacency matrix. matrix can computed polygonal data resulting matrix can binary, entries 1 polygons share border, 0 elsewhere (including diagonal). entries can weighted different ways, including length border shared two polygons. schema necessarily lend well spatial transcriptomic technologies, polygonal boundaries cell objects may correspond measurements count matrix, individual spots barcodes may correspond multiple neighborhoods cells. Certainly, interpretation spatial weights matrix change depending technology. case, can generate putative spatial graph using k-nearest neighbors algorithm. implemented findSpatialNeighbors() function argument method = \"knearneigh\" . store result colGraphs() slot SFE object. Now compute Moran's barcode QC metrics using colDataMoransI(). results substantiate visual check spatial autocorrelation. continue investigating QC metrics. proportion UMIs mapping mitochondrial genes useful metric assessing cell quality scRNA-seq data. examine QC metric plotting versus total number UMI counts barcode.  keeping expectations, barcodes associated fewer counts appear associated higher proportions mitochondrial reads. exclude barcodes containing >10% mitochondrial reads subsequent analysis. second line removes barcodes zero counts, necessary dataset barcodes zero counts. keep just demonstrate method.","code":"names(colData(sfe)) #> [1] \"sample_id\" \"nCounts\"   \"nGenes\"    \"prop_mito\" avg <- as.data.frame(colData(sfe)) |>   dplyr::summarise(across(-sample_id, mean))  violin <- plotColData(sfe, \"nCounts\") +   geom_hline(aes(yintercept = nCounts), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"nCounts\",                                colGeometryName = \"centroids\", size = 0.2) +     theme_void() violin + spatial as.data.frame(cbind(spatialCoords(sfe), colData(sfe))) |>      ggplot(aes(xcoord, ycoord, z=nCounts)) +     stat_summary_hex(fun = function(x) sum(x), bins=100) +      scale_fill_distiller(palette = \"Blues\", direction = 1) +     labs(fill='nCounts')  +     theme_bw() + coord_equal() +     scale_x_continuous(expand = expansion()) +     scale_y_continuous(expand = expansion()) +     theme_void() colData(sfe)$log_nCounts <- log(colData(sfe)$nCounts)  avg <- as.data.frame(colData(sfe)) |>   dplyr::summarise(across(-sample_id, mean))  violin <- plotColData(sfe, \"log_nCounts\") +   geom_hline(aes(yintercept = log_nCounts), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"log_nCounts\",                                colGeometryName = \"centroids\",                               size = 0.2) violin + spatial violin <- plotColData(sfe, \"nGenes\") +    geom_hline(aes(yintercept = nGenes), avg, color=\"red\") +   theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, features = \"nGenes\",                               colGeometryName = \"centroids\",                               size = 0.2) violin + spatial colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                               dist_type = \"idw\", k = 5,                                                style = \"W\") features_use <- c(\"nCounts\", \"nGenes\") sfe <- colDataMoransI(sfe, features_use, colGraphName = \"knn5\") colFeatureData(sfe)[features_use,] #> DataFrame with 2 rows and 2 columns #>         moran_sample01 K_sample01 #>              <numeric>  <numeric> #> nCounts      0.0965909    48.6328 #> nGenes       0.0957030    11.2037 violin <- plotColData(sfe, \"prop_mito\") +     geom_hline(aes(yintercept = prop_mito), avg, color=\"red\") +     theme(legend.position = \"top\")   mito <- plotColData(sfe, x = \"nCounts\", y = \"prop_mito\")  violin + mito # Spatial neighborhood graph is reconstructed when subsetting columns # Use drop = TRUE to drop the graph without reconstruction, whose indices are  # no longer valid sfe_filt <- sfe[, colData(sfe)$prop_mito < 0.1] sfe_filt <- sfe_filt[rowSums(counts(sfe_filt)) > 0,]"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"data-normalization","dir":"Articles","previous_headings":"","what":"Data Normalization","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Normalization spatial transcriptomics data non-trivial requires thoughtful consideration. Similarly scRNA-seq data analysis, goal normalization remove effects technical variation derive quantity reflects biological variation. However, several questions arise considering best practices spatial data normalization. example, spatial methods average detect fewer UMIs single-cell counterparts, may preclude use normalization techniques log transformation shown . â€™s , always evident whether spatial autocorrelation genes (QC measures) artifact technology, thus, whether normalization methods preserve spatial autocorrelation architecture. questions provide avenues active research development, currently unresolved. end, log-normalize data cell identify variable genes subsequent analysis.","code":"sfe_filt <- logNormCounts(sfe_filt)  dec <- modelGeneVar(sfe_filt) hvgs <- getTopHVGs(dec, n = 2000)"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Dimension Reduction and Clustering","title":"Slide-Seq V2 Exploratory Data Analysis","text":"Much like scRNA-seq analysis, perform principal component analysis (PCA) clustering. note method use spatial information. can plot variance explained PC.  see first components explain variance data. principal components (PCs) can plotted space. notice PCs may show spatial structure correlates biological niches cells.  Without cellular overlays, can speculate potential relevance barcodes seem separated PC, PC doe seem separate distinct neighborhoods barcodes. Now can cluster barcodes using graph-based clustering algorithm plot space. plot colored cluster id. naive interpretation plot shows distinct niches barcodes separated abundant, intervening types. may indicative biological processes hand, namely melanoma metastasis, â€˜hotspotsâ€™ melanoma proliferation separated unaffected normal tissue.","code":"set.seed(29) sfe_filt <- runPCA(sfe_filt, ncomponents = 30, subset_row = hvgs,                    scale = TRUE, BSPARAM = BiocSingular::IrlbaParam())  # scale as in Seurat ElbowPlot(sfe_filt, ndims = 30) + theme_bw() spatialReducedDim(sfe_filt, \"PCA\", ncomponents = 4,                    colGeometryName = \"centroids\", divergent = TRUE,                    diverge_center = 0, scattermore = TRUE, pointsize = 0.5) colData(sfe_filt)$cluster <- clusterRows(reducedDim(sfe_filt, \"PCA\")[,1:3],                                            BLUSPARAM = SNNGraphParam(                                                cluster.fun = \"leiden\",                                                cluster.args = list(                                                    resolution_parameter = 0.5,                                                    objective_function = \"modularity\"))) plotSpatialFeature(sfe_filt, \"cluster\", colGeometryName = \"centroids\") +   guides(colour = guide_legend(override.aes = list(size=3)))"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"morans-i","dir":"Articles","previous_headings":"Dimension Reduction and Clustering","what":"Moranâ€™s I","title":"Slide-Seq V2 Exploratory Data Analysis","text":"One avenue future analysis includes identifying genes differentially expressed cluster, can interrogated findMarkers() non-spatial context calculateMoransI() spatial context. spatial case, consideration given whether differences seen across tissue represent biological difference artifacts field view. run global Moranâ€™s log normalized gene expression. Now, might ask: genes display spatial autocorrelation?  Spatial variability can also investigated using differential expression testing known anatomical regions complemented spatial location. One potential drawback approach variability induced melanoma, rather native tissue architecture, may preclude identification typical structures. analyses can done stage: gene expression patterns, , differentiate neighborhoods melanoma cells? genes differentially expressed cluster?","code":"sfe_filt <- runMoransI(sfe_filt, features = hvgs,                         BPPARAM = MulticoreParam(2)) top_moran <- rownames(sfe_filt)[order(rowData(sfe_filt)$moran_sample01,                                        decreasing = TRUE)[1:4]] plotSpatialFeature(sfe_filt, top_moran, colGeometryName = \"centroids\",                    scattermore = TRUE, pointsize = 0.5)"},{"path":"https://pachterlab.github.io/voyager/articles/vig3_slideseq_v2.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Slide-Seq V2 Exploratory Data Analysis","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] BiocParallel_1.40.0            spdep_1.3-6                    #>  [3] sf_1.0-19                      spData_2.3.3                   #>  [5] patchwork_1.3.0                bluster_1.16.0                 #>  [7] scran_1.34.0                   scater_1.34.0                  #>  [9] ggplot2_3.5.1                  scuttle_1.16.0                 #> [11] SpatialExperiment_1.16.0       SingleCellExperiment_1.28.1    #> [13] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [15] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [17] IRanges_2.40.0                 S4Vectors_0.44.0               #> [19] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [21] matrixStats_1.4.1              SFEData_1.8.0                  #> [23] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] edgeR_4.4.0               lattice_0.22-6            #>   [9] MASS_7.3-61               magrittr_2.0.3            #>  [11] limma_3.62.1              sass_0.4.9                #>  [13] rmarkdown_2.29            jquerylib_0.1.4           #>  [15] yaml_2.3.10               metapod_1.14.0            #>  [17] sp_2.1-4                  RColorBrewer_1.1-3        #>  [19] cowplot_1.1.3             DBI_1.2.3                 #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] purrr_1.0.2               R.utils_2.12.3            #>  [27] RCurl_1.98-1.16           TH.data_1.1-2             #>  [29] rappdirs_0.3.3            sandwich_3.1-1            #>  [31] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [33] irlba_2.3.5.1             terra_1.7-83              #>  [35] units_0.8-5               RSpectra_0.16-2           #>  [37] dqrng_0.4.1               pkgdown_2.1.1             #>  [39] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [41] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [43] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [45] memuse_4.2-3              farver_2.1.2              #>  [47] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [49] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [51] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [53] survival_3.7-0            systemfonts_1.1.0         #>  [55] tools_4.4.2               ggnewscale_0.5.0          #>  [57] ragg_1.3.3                Rcpp_1.0.13-1             #>  [59] glue_1.8.0                gridExtra_2.3             #>  [61] SparseArray_1.6.0         xfun_0.49                 #>  [63] EBImage_4.48.0            dplyr_1.1.4               #>  [65] HDF5Array_1.34.0          withr_3.0.2               #>  [67] BiocManager_1.30.25       fastmap_1.2.0             #>  [69] boot_1.3-31               rhdf5filters_1.18.0       #>  [71] fansi_1.0.6               digest_0.6.37             #>  [73] rsvd_1.0.5                mime_0.12                 #>  [75] R6_2.5.1                  textshaping_0.4.0         #>  [77] colorspace_2.1-1          wk_0.9.4                  #>  [79] scattermore_1.2           LearnBayes_2.15.1         #>  [81] jpeg_0.1-10               RSQLite_2.3.8             #>  [83] R.methodsS3_1.8.2         hexbin_1.28.5             #>  [85] utf8_1.2.4                generics_0.1.3            #>  [87] data.table_1.16.2         class_7.3-22              #>  [89] httr_1.4.7                htmlwidgets_1.6.4         #>  [91] S4Arrays_1.6.0            pkgconfig_2.0.3           #>  [93] scico_1.5.0               gtable_0.3.6              #>  [95] blob_1.2.4                XVector_0.46.0            #>  [97] htmltools_0.5.8.1         fftwtools_0.9-11          #>  [99] scales_1.3.0              png_0.1-8                 #> [101] knitr_1.49                rjson_0.2.23              #> [103] coda_0.19-4.1             nlme_3.1-166              #> [105] curl_6.0.1                proxy_0.4-27              #> [107] cachem_1.1.0              zoo_1.8-12                #> [109] rhdf5_2.50.0              BiocVersion_3.20.0        #> [111] KernSmooth_2.23-24        vipor_0.4.7               #> [113] parallel_4.4.2            AnnotationDbi_1.68.0      #> [115] desc_1.4.3                s2_1.1.7                  #> [117] pillar_1.9.0              grid_4.4.2                #> [119] vctrs_0.6.5               BiocSingular_1.22.0       #> [121] dbplyr_2.5.0              beachmat_2.22.0           #> [123] sfheaders_0.4.4           cluster_2.1.6             #> [125] beeswarm_0.4.0            evaluate_1.0.1            #> [127] zeallot_0.1.0             magick_2.8.5              #> [129] mvtnorm_1.3-2             cli_3.6.3                 #> [131] locfit_1.5-9.10           compiler_4.4.2            #> [133] rlang_1.1.4               crayon_1.5.3              #> [135] labeling_0.4.3            classInt_0.4-10           #> [137] ggbeeswarm_0.7.2          fs_1.6.5                  #> [139] viridisLite_0.4.2         deldir_2.0-4              #> [141] munsell_0.5.1             Biostrings_2.74.0         #> [143] tiff_0.1-12               Matrix_1.7-1              #> [145] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [147] bit64_4.5.2               Rhdf5lib_1.28.0           #> [149] KEGGREST_1.46.0           statmod_1.5.0             #> [151] AnnotationHub_3.14.0      igraph_2.1.1              #> [153] memoise_2.0.1             bslib_0.8.0               #> [155] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"CosMX non-small cell lung cancer data","text":"Nanostring GeoMX DSP popular spatial transcriptomics technology formalin fixed paraffin embedded (FFPE) tissues, doesnâ€™t single cell resolution. CosMX FISH based technology FFPE tissue (He2021-oy?) single cell resolution, vignette provides example analyze CosMX data voyager. Note FFPE common way preserve archive tissue, cases, samples available may FFPE. CosMX dataset non-small cell lung cancer used described (He2021-oy?). processed data available download Nanostring website. gene count matrix, cell metadata, cell segmentation polygon coordinates downloaded Nanostring website CSV files read R data frames. gene count matrix converted sparse matrix. cell metadata contains centroid coordinates cells. cell polygon data frames converted sf data frame df2sf() function SpatialFeatureExperiment (SFE). used construct SFE object. Cell segmentation available one z-plane. first biological replicate included SFEData package. biological replicate 980 features 100,290 cells. Take look cells space:  single cell resolution, lot details can seen, although â€™s artifact borders fields view (FOVs). Plot cell density","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater) # devel version of plotExpression library(scran) library(bluster) library(ggplot2) library(patchwork) library(stringr) library(spdep) library(BiocParallel) library(BiocSingular) theme_set(theme_bw()) (sfe <- HeNSCLCData()) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 980 100290  #> metadata(0): #> assays(1): counts #> rownames(980): AATK ABL1 ... NegPrb22 NegPrb23 #> rowData names(3): means vars cv2 #> colnames(100290): 1_1 1_2 ... 30_4759 30_4760 #> colData names(17): Area AspectRatio ... nCounts nGenes #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : CenterX_global_px CenterY_global_px #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01: plotGeometry(sfe, MARGIN = 2L, type = \"cellSeg\") #> Warning: The `type` argument of `plotGeometry()` is deprecated as of Voyager 1.8.0. #> â„¹ Please use colGeometryName, annotGeometryName, or rowGeometryName instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Warning: The `MARGIN` argument of `plotGeometry()` is deprecated as of Voyager 1.8.0. #> â„¹ Please use colGeometryName, annotGeometryName, or rowGeometryName instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. plotCellBin2D(sfe, hex = TRUE)"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"cells","dir":"Articles","previous_headings":"Quality control (QC)","what":"Cells","title":"CosMX non-small cell lung cancer data","text":"Single cell RNA-seq (scRNA-seq) technologies typically donâ€™t quantify cell morphology, gene expression Visium doesnâ€™t single cell resolution. single cell resolution smFISH based data, cell gene expression related QC metrics total number transcripts detected number genes detected, also cell morphology area (z-plane segmentation polygons provided) aspect ratio. Area relevant QC since can flag falsely undersegmented cells, .e.Â several cells falsely considered one cell segmentation program. However, since pre-defined gene panel used mitochondrially encoded genes quantified, scRNA-seq QC metric proportion mitochondrially encoded counts applicable. QC metrics precomputed stored colData Cell area, aspect ratio, marker stain intensities, .e.Â columns â€œsample_idâ€ come Nanostringâ€™s website. sf package can compute areas cell polygons. R, EBImage package can compute morphological metrics aspect ratio, eccentricity, orientation, etc., requires data converted raster. OpenCV can compute morphological metrics polygons without converting raster, needs called Python C++. Since math behind many basic morphological metrics pretty simple, may add Voyager future version. Since plotting 100,000 polygons slow plot isnâ€™t large enough us see polygons anyway, use scattermore rasterize plot speed plotting. Instead plotting every single point, now ggplot merely displays rasterized image. Number transcript spots detected per cell  make nCounts nGenes comparable across datasets, divide number genes probed. dataset, 960 genes, 20 negative controls. However, different genes may probed different datasets, can different tissues, make nCounts nGenes completely comparable across datasets. However, may still somewhat comparable, since genes highly expressed major cell types tissue tend selected gene panel.  means cells mostly less 1 transcript count per gene average, surprising since cells express genes. cells detected express less 30% genes probed. Number genes (980) detected per cell  Based spatial plot, seems nCounts nGenes biologically relevant, cells transcripts detected. nCounts relates nGenes  â€™s nature cells without transcripts?  cells without transcripts central cavity.  â€œemptyâ€ cells tend smaller cells also really large ones. Cell area distribution  Larger cells likely found certain areas tissue. biological, -segmentation likely cell type tissue region. area relate total counts?  may vaguely seem cells total counts tend larger (least z-plane), cells large low total counts. Negative control probes used dataset QC. calculate proportion transcripts attributed negative controls.  NAâ€™s empty cells, proportion low except outliers. prop_neg relate nCounts?  looks kind like proportion mitochondrial counts vs.Â nCounts plot scRNA-seq, cells fewer total counts tend higher proportion mitochondrial counts.  distribution obviously bimodal, since x-axis log transformed better visualize distribution, 0â€™s removed. â€™s kind arbitrary; now â€™ll remove cells 10% transcripts negative controls. removing low quality cells, 100,095 cells left.","code":"names(colData(sfe)) #>  [1] \"Area\"               \"AspectRatio\"        \"Width\"              #>  [4] \"Height\"             \"Mean.MembraneStain\" \"Max.MembraneStain\"  #>  [7] \"Mean.PanCK\"         \"Max.PanCK\"          \"Mean.CD45\"          #> [10] \"Max.CD45\"           \"Mean.CD3\"           \"Max.CD3\"            #> [13] \"Mean.DAPI\"          \"Max.DAPI\"           \"sample_id\"          #> [16] \"nCounts\"            \"nGenes\" # Function to plot violin plot for distribution and spatial at once plot_violin_spatial <- function(sfe, feature) {     violin <- plotColData(sfe, feature, point_fun = function(...) list())     spatial <- plotSpatialFeature(sfe, feature, colGeometryName = \"centroids\",                                   scattermore = TRUE)     violin + spatial +         plot_layout(widths = c(1, 2)) } plot_violin_spatial(sfe, \"nCounts\") summary(sfe$nCounts) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>     0.0   135.0   248.0   302.8   409.0  2475.0 n_panel <- 960 colData(sfe)$nCounts_normed <- sfe$nCounts/n_panel colData(sfe)$nGenes_normed <- sfe$nGenes/n_panel plotColDataHistogram(sfe, c(\"nCounts_normed\", \"nGenes_normed\")) plot_violin_spatial(sfe, \"nGenes\") summary(sfe$nGenes) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>     0.0    75.0   119.0   127.1   171.0   500.0 plotColData(sfe, x = \"nCounts\", y = \"nGenes\", bins = 100) colData(sfe)$is_empty <- colData(sfe)$nCounts < 1 plotSpatialFeature(sfe, \"is_empty\", \"cellSeg\") plotColData(sfe, x = \"Area\", y = \"is_empty\") plot_violin_spatial(sfe, \"Area\") plotColData(sfe, x = \"nCounts\", y = \"Area\", bins = 100) + theme_bw() neg_inds <- str_detect(rownames(sfe), \"^NegPrb\") # Number of negative control probes sum(neg_inds) #> [1] 20 colData(sfe)$prop_neg <- colSums(counts(sfe)[neg_inds,])/colData(sfe)$nCounts plot_violin_spatial(sfe, \"prop_neg\") #> Warning: Removed 142 rows containing non-finite outside the scale range #> (`stat_ydensity()`). plotColData(sfe, x = \"nCounts\",y = \"prop_neg\", bins = 100) #> Warning: Removed 142 rows containing non-finite outside the scale range #> (`stat_bin2d()`). # The zeros are removed plotColDataHistogram(sfe, \"prop_neg\") +     scale_x_log10() #> Warning in scale_x_log10(): log-10 transformation introduced #> infinite values. #> Warning: Removed 59213 rows containing non-finite outside the scale range #> (`stat_bin()`). # Remove low quality cells (sfe <- sfe[,!sfe$is_empty & sfe$prop_neg < 0.1]) #> class: SpatialFeatureExperiment  #> dim: 980 100095  #> metadata(0): #> assays(1): counts #> rownames(980): AATK ABL1 ... NegPrb22 NegPrb23 #> rowData names(3): means vars cv2 #> colnames(100095): 1_1 1_2 ... 30_4759 30_4760 #> colData names(21): Area AspectRatio ... is_empty prop_neg #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : CenterX_global_px CenterY_global_px #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01:"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"markers","dir":"Articles","previous_headings":"Quality control (QC) > Cells","what":"Markers","title":"CosMX non-small cell lung cancer data","text":"Nanostring provides cell stain marker intensities cell metadata. plot aspect ratio mean intensity cells stains markers, plotted . PanCK marker epithelial cells. CD45 leukocyte marker. CD3 T cell marker. Since takes quite plot 100,000 cells 6 times, scattermore really helps.","code":"names(colData(sfe)) #>  [1] \"Area\"               \"AspectRatio\"        \"Width\"              #>  [4] \"Height\"             \"Mean.MembraneStain\" \"Max.MembraneStain\"  #>  [7] \"Mean.PanCK\"         \"Max.PanCK\"          \"Mean.CD45\"          #> [10] \"Max.CD45\"           \"Mean.CD3\"           \"Max.CD3\"            #> [13] \"Mean.DAPI\"          \"Max.DAPI\"           \"sample_id\"          #> [16] \"nCounts\"            \"nGenes\"             \"nCounts_normed\"     #> [19] \"nGenes_normed\"      \"is_empty\"           \"prop_neg\" plotSpatialFeature(sfe, c(\"AspectRatio\", \"Mean.DAPI\", \"Mean.MembraneStain\",                            \"Mean.PanCK\", \"Mean.CD45\", \"Mean.CD3\"),                    colGeometryName = \"centroids\", ncol = 2, scattermore = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"genes","dir":"Articles","previous_headings":"Quality control (QC)","what":"Genes","title":"CosMX non-small cell lung cancer data","text":"red line y=xy = x expected Poisson data. Gene expression dataset variance expected Poisson, even gene lower expression. Zoom negative controls  Among â€œhigh qualityâ€ cells, negative controls still higher variance relative mean compared Poisson. Negative controls vs.Â real genes  negative controls lower mean â€œexpressionâ€ vast majority real genes.","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_neg <- neg_inds plotRowData(sfe, x = \"means\", y = \"vars\", bins = 50) +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() as.data.frame(rowData(sfe)[neg_inds,]) |>      ggplot(aes(means, vars)) +     geom_point() +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() plotRowData(sfe, x = \"means\", y = \"is_neg\") +     scale_y_log10() +     annotation_logticks(sides = \"b\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"spatial-autocorrelation-in-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation in QC metrics","title":"CosMX non-small cell lung cancer data","text":"spatial neighborhood graph required spatial dependence analyses spdep. Without benchmark, donâ€™t yet know type neighborhood graph best purpose. Methods find spatial neighborhood graphs spdep knearneigh() (k nearest neighbors), dnearneigh() (find cells within certain distance), poly2nb() (polygon contiguity) recommended larger datasets. cell-cell contact may biologically relevant, cell segmentation imperfect, leading non-contiguous cell segmentation polygons cells appear contiguous H&E, using poly2nb() find polygon contiguity neighbors without supplementing another kind neighborhood problematic. Delaunay triangulation deldir package, used spdep (tri2nb()), takes 4 5 minutes dataset size, run time increases much drastically linearly number cells increases. Sphere Interest (SOI) graph (soi.graph()) prunes edges triangulation long, take long . triangulation SOI graph, slower knearneigh(), dnearneigh(), poly2nb(), somewhat practical considerations. implementation gabrielneigh() relativeneigh() take impracticably long (hour terminated R session impatience) dataset recommended. Methods find approximate nearest neighbors Annoy (AnnoyParam()) HNSW (HnswParam()), supported bluster BiocNeighbors packages might speed finding graphs, havenâ€™t formally benchmarked . See Chapter 14 Spatial Data Science proximity areal data detailed discussion different neighborhood graphs spdep. methods areal data first wrapped Voyager much spatial transcriptomics data analogous areal geospatial data, data several cells aggregated areas, happens Visium spots. Just like geospatial areal data, Visium aggregation areas arbitrary represent underlying spatial process. Although sometimes geographical areal units arbitrary, tissues generally hexagonal grids means Visium spot polygons arbitrary context. Regions interest (ROI) selection spatial transcriptomics methods, laser capture microdissection (LCM) GeoMX DSP obviously analogous geospatial areal data. aggregation also happens analyze smFISH-based data cell level, basic unit observation individual transcript spots. spdep caters areal data, gstat caters geostatistical data, continuous spatial process sampled point locations. ways, spatial transcriptomics data analogous geostatistical data. Visium samples supposed spatial biological process regular hexagonal grid, pretend Visium spots points. smFISH-based single cell resolution data, cells observed can thought sample underlying spatial biological process supervening specific locations cells. sense, cells samples, since smFISH based technologies attempt visualize cells tissue section. However, biological function tissue depend particular spatial arrangement individual cells (.e.Â supervenes particular spatial arrangement), cell types, specific cell locations observed can thought samples process, consider cell basic unit spatial process. Voyager 1.2.0 (Bioconductor release), added semivariograms (gstat package) exploratory tool identify presence spatial autocorrelation, length scale, anisotropy (.e.Â different different directions). Covariates can specified computing variogram account spatial trends adjust another spatial variable. However, unlike Moransâ€™s , semivariogram canâ€™t identify negative spatial autocorrelation, although since spatial neighborhood graph typically encode spatial directions, spdep autocorrelation metrics canâ€™t identify anisotropy. Another problem semivariogram assumes data intrinsically stationary, .e.Â semivariogram holds entire dataset, similarity two cells depends distance , may case spatial autocorrelation varies space evident genes local spatial analyses. Single cell smFISH based data also dissimiliar areal geostatistical data important ways. geospatial areal data, data numerous basic units spatial process (e.g.Â people epidemiology) aggregated areas (e.g.Â cities), whereas histological space, cell arguably sensible basic unit biological spatial process individual mRNA molecules. Unlike geostatistical data, cells seen tissue section often polygons tessellating tissue section rather points. Furthermore, ideally samples underlying spatial process affect spatial process geostatistical data, cells play active roles biological spatial process. However, data analysis methods areal geostatistical data can still relevant EDA descriptive models (causal mechanistic) single cell smFISH data. Different types spatial neighborhood graphs cells may relevant different processes. instance, contiguity cell segmentation polygons relevant contact involved cell signaling, although cell segmentation imperfect. Positive spatial autocorrelation can arise contact activation, negative autocorrelation can arise contact inhibition. However, cells may also influenced longer range factors secreted ligands, morphogens, simpler spatial trends like distance artery vein. case, perhaps semivariogram using Euclidean distance cells spatial weights spatial autocorrelation metrics relevant EDA. interesting compare results different spatial neighborhood graphs spatial weights, spdep gstat. Perhaps one best method, different methods reveal different phenomena. problem choosing spatial neighborhood matrix long history far predating spatial transcriptomics. See (Getis2009-iw?) brief discussion decades work around issue. Spatial autocorrelation metrics seek measure nearby things tend similar dissimilar, neighborhood graph edge weights define mean â€œnearbyâ€ areal data. Note Visium spot can contain several dozens cells, spatial neighborhood graphs Visium spots describe neighborhood relationships much longer length scales spatial neighborhood graphs single cells, spatial autocorrelation metrics using Visium graph different meanings cellular neighborhood graphs. now, just demonstrate software usage, use k nearest neighborhood graph distance based edge weights, commonly done graph based clustering scRNA-seq, although donâ€™t yet know best value k scenario. purpose vignette, say use k=5k = 5, execution time isnâ€™t outrageous. argument style = \"W\" row normalize adjacency matrix spatial neighborhood graph necessary Moran scatter plot. Inverse distance edge weights can take small values matter relative rather absolute values distance arbitrary unit; row normalizing adjacency matrix makes weighted average value neighbors comparable value cell . tissue, many cells appear contiguous, since cell segmentation imperfect, many false singletons, makes polygon contiguity neighbors poly2nb() problematic without modification. based distribution number neighbors based contiguity, k=5k = 5 doesnâ€™t seem bad approximate contiguity. Now compute Moranâ€™s cell QC metrics Positive spatial autocorrelation suggested, stronger nCounts nGenes. length scales spatial autocorrelation QC metrics? nice lagged neighborhood graphs can stored reused features rather recomputed feature spdep::sp.correlogram() called behind scene . takes minutes run, long typical song. Another way find length scale spatial autocorrelation bin cells bins different sizes find spatial autocorrelation bin size, probably faster finding lagged values higher higher neighborhoods since geom_bin2d() geom_hex() ggplot2 run pretty fast even large datasets. use semivariogram; gstat also bins data estimating semivariogram calculating semivariogram long distance much faster correlogram cell-cell neighborhood graphs. Note MulticoreParam() doesnâ€™t work Windows; vignette built Linux. Use SnowParam() DoparParam() Windows. See ?BiocParallelParam available parallel processing backends. notice significant performance differences ShowParam() MulticoreParam() context.  seem similar length scales, aspect ratios tend decay quickly. Moranâ€™s scatter plot nCounts. first panel, density points plot, second, points influential fitting line highlighted red, still 2D histogram avoid overplotting.  obvious clusters plot. Local Moranâ€™s nCounts  Cool, appears epithelial regions tend homogenous nCounts.","code":"system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                   dist_type = \"idw\", k = 5,                                                    style = \"W\")     ) #>    user  system elapsed  #>   4.729   0.000   4.729 features_use <- c(\"nCounts\", \"nGenes\", \"Area\", \"AspectRatio\") sfe <- colDataMoransI(sfe, features_use, colGraphName = \"knn5\") colFeatureData(sfe)[features_use,] #> DataFrame with 4 rows and 2 columns #>             moran_sample01 K_sample01 #>                  <numeric>  <numeric> #> nCounts           0.386661    6.80818 #> nGenes            0.434648    3.19599 #> Area              0.198196    8.96966 #> AspectRatio       0.256223   43.05666 system.time(     sfe <- colDataUnivariate(sfe, \"sp.correlogram\", features = features_use,                          colGraphName = \"knn5\", order = 6, zero.policy = TRUE,                          BPPARAM = MulticoreParam(2)) ) #>    user  system elapsed  #> 187.358   1.196 189.397 plotCorrelogram(sfe, features_use) sfe <- colDataUnivariate(sfe, \"moran.plot\", \"nCounts\", colGraphName = \"knn5\") p1 <- moranPlot(sfe, \"nCounts\", binned = TRUE, plot_influential = FALSE) p2 <- moranPlot(sfe, \"nCounts\", binned = TRUE) p1 / p2 + plot_layout(guides = \"collect\") sfe <- colDataUnivariate(sfe, \"localmoran\", \"nCounts\", colGraphName = \"knn5\") plotLocalResult(sfe, \"localmoran\", \"nCounts\", colGeometryName = \"cellSeg\",                 divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"data-normalization","dir":"Articles","previous_headings":"","what":"Data normalization","title":"CosMX non-small cell lung cancer data","text":"Given may relationship cell size total counts, total counts may biological thus purely treated technical, questions raised data normalization different standard scRNA-seq practices. instance, technical contributions total counts kind data? Furthermore, cell area, since part technical, z-plane cell segmentation polygons intersects cell, cell types, biological? Also, different methods data normalization affect spatial autocorrelation? spatial autocorrelation used ways normalizing data? Besides correcting technical effects making gene expression cells different total counts comparable, data normalization stabilizes variance tries make data normally distributed since many statistical methods assume normally distributed data. donâ€™t know best practice normalize kind data, still normalize data downstream analyses.","code":"sfe <- logNormCounts(sfe)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moranâ€™s I","title":"CosMX non-small cell lung cancer data","text":"run global Moranâ€™s log normalized gene expression. real genes tend spatial autocorrelation negative controls?  seems least shorter length scale captured k nearest neighbor graph, genes donâ€™t strong spatial autocorrelation strong positive spatial autocorrelation. contrast, Moranâ€™s negative controls closely packed around 0, indicating lack spatial autocorrelation, good sign, evidence technical artifact manifests spatial trend manifest negative controls. genes highest Moranâ€™s ?  highlight epithelial regions. regions spatially organized, short length scale used Moranâ€™s correlogram shows Moranâ€™s decays first order neighbors. wonder using longer length scale change results.","code":"# Note: on your computer, you can put progressbar = TRUE inside MulticoreParam() # to show progress bar. This applies to any BiocParallParam. sfe <- runMoransI(sfe, features = rownames(sfe),                    BPPARAM = MulticoreParam(2)) plotRowData(sfe, x = \"moran_sample01\", y = \"is_neg\") +     geom_hline(yintercept = 0, linetype = 2) top_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[1:6]] plotSpatialFeature(sfe, top_moran, colGeometryName = \"centroids\",                     scattermore = TRUE, ncol = 2)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"non-spatial-dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Non-spatial dimension reduction and clustering","title":"CosMX non-small cell lung cancer data","text":"first PC highlights epithelium. PC2 highlights T cells. PC4 might highlight leukocytes. Need check genes highest loadings find PCs mean. Non-spatial clustering locating clusters space   analyses can done stage: many cell types neighborhood cell? subject different definitions neighborhood. cell types tend co-localize ? Find spatial regions based cell type colocalization, can done R package spicyR (Canete2022-tz?)","code":"set.seed(29) sfe <- runPCA(sfe, ncomponents = 30, scale = TRUE, BSPARAM = IrlbaParam()) ElbowPlot(sfe, ndims = 30) plotDimLoadings(sfe, dims = 1:6) spatialReducedDim(sfe, \"PCA\", 6, colGeometryName = \"centroids\", divergent = TRUE,                   diverge_center = 0, ncol = 2, scattermore = TRUE) colData(sfe)$cluster <- clusterRows(reducedDim(sfe, \"PCA\")[,1:15],                                     BLUSPARAM = SNNGraphParam(                                         cluster.fun = \"leiden\",                                         cluster.args = list(                                             resolution_parameter = 0.5,                                             objective_function = \"modularity\"))) data(\"ditto_colors\") plotPCA(sfe, ncomponents = 4, colour_by = \"cluster\") +     scale_color_manual(values = ditto_colors) #> Scale for colour is already present. #> Adding another scale for colour, which will replace the existing scale. plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"differential-expression","dir":"Articles","previous_headings":"","what":"Differential expression","title":"CosMX non-small cell lung cancer data","text":"Cluster marker genes found Wilcoxon rank sum test commonly done scRNA-seq. â€™s already sorted p-values. Get significant marker cluster plot. Since â€™re many points, used development version scater plot points, uninformative due overplotting make plot really slow.  Plot top marker genes heatmap","code":"markers <- findMarkers(sfe, groups = colData(sfe)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[6]] #> DataFrame with 980 rows and 12 columns #>         p.value       FDR summary.AUC     AUC.1     AUC.2     AUC.3     AUC.4 #>       <numeric> <numeric>   <numeric> <numeric> <numeric> <numeric> <numeric> #> IGKC          0         0    0.885604  0.915893  0.904629  0.854552  0.918666 #> IGHG1         0         0    0.870454  0.895068  0.885524  0.835836  0.899570 #> IGHG2         0         0    0.853929  0.882327  0.870903  0.819786  0.883491 #> XBP1          0         0    0.817098  0.852054  0.825707  0.839283  0.832057 #> MZB1          0         0    0.772305  0.796577  0.790815  0.762860  0.793176 #> ...         ...       ...         ...       ...       ...       ...       ... #> VEGFA         1         1    0.243000  0.509568  0.451327  0.511081  0.465997 #> VIM           1         1    0.187813  0.605804  0.335836  0.428957  0.388411 #> VWF           1         1    0.182293  0.509990  0.498086  0.502132  0.502652 #> YBX3          1         1    0.315858  0.525875  0.433453  0.476210  0.450204 #> ZFP36         1         1    0.296289  0.547722  0.418010  0.476879  0.391125 #>           AUC.5     AUC.7     AUC.8     AUC.9    AUC.10 #>       <numeric> <numeric> <numeric> <numeric> <numeric> #> IGKC   0.919395  0.922501  0.901215  0.885604  0.937589 #> IGHG1  0.900331  0.900321  0.881680  0.870454  0.918048 #> IGHG2  0.885587  0.883030  0.866623  0.853929  0.897751 #> XBP1   0.835300  0.782563  0.827742  0.817098  0.787078 #> MZB1   0.790505  0.794465  0.780890  0.772305  0.799504 #> ...         ...       ...       ...       ...       ... #> VEGFA  0.498333  0.399060  0.511300  0.465662  0.243000 #> VIM    0.187813  0.526187  0.385290  0.342144  0.651243 #> VWF    0.182293  0.492084  0.500706  0.499263  0.499883 #> YBX3   0.328274  0.323000  0.493746  0.481311  0.315858 #> ZFP36  0.296289  0.418886  0.454782  0.380164  0.365552 genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe, genes_use, x = \"cluster\", point_fun = function(...) list()) genes_use2 <- unique(unlist(lapply(markers, function(x) rownames(x)[1:5]))) plotGroupedHeatmap(sfe, genes_use2, group = \"cluster\", colour = scales::viridis_pal()(100))"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"local-spatial-statistics-of-marker-genes","dir":"Articles","previous_headings":"","what":"Local spatial statistics of marker genes","title":"CosMX non-small cell lung cancer data","text":"Plot genes space  Moranâ€™s marker genes Local Moranâ€™s marker genes  seems histological regions tend spatially homogenous gene expression others. epithelial region tends homogenous. Run local spatial heteroscdasticity (LOSH) marker genes find local heterogeneity  genes heterogeneous also highly expressed, COLA1 IGKC. However case genes. example, MZT2A quite ubiqiutously experssed, heterogeneous regions others, KRT19 seem much heterogeneous â€™s highly expressed. MZT2A, LOSH picked artifact edges FOVs, although apparent genes plotted . donâ€™t information cell belongs FOV, FOV edge effects considered data normalization. interesting systematically see LOSH relates gene expression across genes, differs cell types gene functions.","code":"plotSpatialFeature(sfe, genes_use, colGeometryName = \"centroids\", ncol = 2,                    scattermore = TRUE) rowData(sfe)[genes_use, \"moran_sample01\", drop = FALSE] #> DataFrame with 10 rows and 1 column #>          moran_sample01 #>               <numeric> #> MZT2A          0.199125 #> COL1A1         0.394785 #> IGHM           0.293287 #> HLA-DPA1       0.242438 #> PECAM1         0.119170 #> IGKC           0.425212 #> SERPINA1       0.254077 #> IL7R           0.177659 #> TPSB2          0.206112 #> KRT19          0.770436 sfe <- runUnivariate(sfe, \"localmoran\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, \"localmoran\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 2, divergent = TRUE,                 diverge_center = 0, scattermore = TRUE) sfe <- runUnivariate(sfe, \"LOSH\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, \"LOSH\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 2, scattermore = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig4_cosmx.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"CosMX non-small cell lung cancer data","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] BiocSingular_1.22.0            BiocParallel_1.40.0            #>  [3] spdep_1.3-6                    sf_1.0-19                      #>  [5] spData_2.3.3                   stringr_1.5.1                  #>  [7] patchwork_1.3.0                bluster_1.16.0                 #>  [9] scran_1.34.0                   scater_1.34.0                  #> [11] ggplot2_3.5.1                  scuttle_1.16.0                 #> [13] SpatialExperiment_1.16.0       SingleCellExperiment_1.28.1    #> [15] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [17] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [19] IRanges_2.40.0                 S4Vectors_0.44.0               #> [21] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [23] matrixStats_1.4.1              SFEData_1.8.0                  #> [25] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] edgeR_4.4.0               lattice_0.22-6            #>   [9] MASS_7.3-61               magrittr_2.0.3            #>  [11] limma_3.62.1              sass_0.4.9                #>  [13] rmarkdown_2.29            jquerylib_0.1.4           #>  [15] yaml_2.3.10               metapod_1.14.0            #>  [17] sp_2.1-4                  cowplot_1.1.3             #>  [19] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] purrr_1.0.2               R.utils_2.12.3            #>  [27] RCurl_1.98-1.16           TH.data_1.1-2             #>  [29] rappdirs_0.3.3            sandwich_3.1-1            #>  [31] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [33] irlba_2.3.5.1             terra_1.7-83              #>  [35] pheatmap_1.0.12           units_0.8-5               #>  [37] RSpectra_0.16-2           dqrng_0.4.1               #>  [39] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [41] codetools_0.2-20          DropletUtils_1.26.0       #>  [43] DelayedArray_0.32.0       tidyselect_1.2.1          #>  [45] UCSC.utils_1.2.0          memuse_4.2-3              #>  [47] farver_2.1.2              viridis_0.6.5             #>  [49] ScaledMatrix_1.14.0       BiocFileCache_2.14.0      #>  [51] jsonlite_1.8.9            BiocNeighbors_2.0.0       #>  [53] e1071_1.7-16              survival_3.7-0            #>  [55] systemfonts_1.1.0         tools_4.4.2               #>  [57] ggnewscale_0.5.0          ragg_1.3.3                #>  [59] Rcpp_1.0.13-1             glue_1.8.0                #>  [61] gridExtra_2.3             SparseArray_1.6.0         #>  [63] mgcv_1.9-1                xfun_0.49                 #>  [65] EBImage_4.48.0            dplyr_1.1.4               #>  [67] HDF5Array_1.34.0          withr_3.0.2               #>  [69] BiocManager_1.30.25       fastmap_1.2.0             #>  [71] boot_1.3-31               rhdf5filters_1.18.0       #>  [73] fansi_1.0.6               digest_0.6.37             #>  [75] rsvd_1.0.5                mime_0.12                 #>  [77] R6_2.5.1                  textshaping_0.4.0         #>  [79] colorspace_2.1-1          wk_0.9.4                  #>  [81] scattermore_1.2           LearnBayes_2.15.1         #>  [83] jpeg_0.1-10               RSQLite_2.3.8             #>  [85] R.methodsS3_1.8.2         hexbin_1.28.5             #>  [87] utf8_1.2.4                generics_0.1.3            #>  [89] data.table_1.16.2         class_7.3-22              #>  [91] httr_1.4.7                htmlwidgets_1.6.4         #>  [93] S4Arrays_1.6.0            pkgconfig_2.0.3           #>  [95] scico_1.5.0               gtable_0.3.6              #>  [97] blob_1.2.4                XVector_0.46.0            #>  [99] htmltools_0.5.8.1         fftwtools_0.9-11          #> [101] scales_1.3.0              png_0.1-8                 #> [103] knitr_1.49                rjson_0.2.23              #> [105] coda_0.19-4.1             nlme_3.1-166              #> [107] curl_6.0.1                proxy_0.4-27              #> [109] cachem_1.1.0              zoo_1.8-12                #> [111] rhdf5_2.50.0              BiocVersion_3.20.0        #> [113] KernSmooth_2.23-24        vipor_0.4.7               #> [115] parallel_4.4.2            AnnotationDbi_1.68.0      #> [117] desc_1.4.3                s2_1.1.7                  #> [119] pillar_1.9.0              grid_4.4.2                #> [121] vctrs_0.6.5               dbplyr_2.5.0              #> [123] beachmat_2.22.0           sfheaders_0.4.4           #> [125] cluster_2.1.6             beeswarm_0.4.0            #> [127] evaluate_1.0.1            zeallot_0.1.0             #> [129] magick_2.8.5              mvtnorm_1.3-2             #> [131] cli_3.6.3                 locfit_1.5-9.10           #> [133] compiler_4.4.2            rlang_1.1.4               #> [135] crayon_1.5.3              labeling_0.4.3            #> [137] classInt_0.4-10           ggbeeswarm_0.7.2          #> [139] fs_1.6.5                  stringi_1.8.4             #> [141] viridisLite_0.4.2         deldir_2.0-4              #> [143] munsell_0.5.1             Biostrings_2.74.0         #> [145] tiff_0.1-12               Matrix_1.7-1              #> [147] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [149] bit64_4.5.2               Rhdf5lib_1.28.0           #> [151] KEGGREST_1.46.0           statmod_1.5.0             #> [153] AnnotationHub_3.14.0      igraph_2.1.1              #> [155] memoise_2.0.1             bslib_0.8.0               #> [157] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Xenium breast cancer dataset","text":"vignette introduces plotting functions relevant exploring Xenium data, performs Xenium-specific quality control (QC), performs exploratory spatial data analysis. QC part data validation, part exploratory data analysis. Xenium new technology 10X genomics single cell resolution smFISH based spatial transcriptomics. dataset used adult human pancreatic cancer processed Xenium Onboarding Analysis (XOA) v2. originally downloaded . version data used , large Zarr files removed â€™re used anyway speed download. load packages used vignette. standard XOA v2 output file structure (excluding Zarr files) gene count matrix cell_feature_matrix h5 tar.gz file. cell metadata cells.csv.gz cells.parquet file. cell segmentation polygon vertices cell_boundaries.csv.gz parquet file. nucleus segmentation polygon vertices nucleus_boundaries.csv.gz parquet files. transcript spot coordinates transcripts.csv.gz parquet file. images different histological stains morphology_focus directory. files relevant SFE objects; see 10X documentation files . readXenium() function SpatialFeatureExperiment reads XOA v1 v2 outputs R. 140702 cells dataset, little CosMX dataset.","code":"library(Voyager) library(SFEData)  library(SingleCellExperiment) library(SpatialExperiment) library(SpatialFeatureExperiment) library(ggplot2) library(ggforce) library(stringr) library(scater)  library(scuttle) library(scales) library(BiocParallel) library(BiocSingular) library(bluster) library(scran) library(patchwork) library(RBioFormats) library(fs) library(sf) library(arrow) library(dplyr) library(tidyr) library(BiocNeighbors) theme_set(theme_bw()) options(timeout = Inf) base <- \".\" if (!dir.exists(file.path(base, \"xenium2_pancreas\"))) {     download.file(\"https://caltech.box.com/shared/static/6yvpahb97dgp4y2gx7oqjktom9a7qp3o\",                   destfile = file.path(base, \"xenium2_pancreas.tar.gz\"))     untar(file.path(base, \"xenium2_pancreas.tar.gz\"), exdir = base) } #> Warning in #> download.file(\"https://caltech.box.com/shared/static/6yvpahb97dgp4y2gx7oqjktom9a7qp3o\", #> : NAs introduced by coercion to integer range fn <- file.path(base, \"xenium2_pancreas\") dir_tree(fn) #> ./xenium2_pancreas #> â”œâ”€â”€ analysis.tar.gz #> â”œâ”€â”€ analysis_summary.html #> â”œâ”€â”€ aux_outputs.tar.gz #> â”œâ”€â”€ cell_boundaries.csv.gz #> â”œâ”€â”€ cell_boundaries.parquet #> â”œâ”€â”€ cell_feature_matrix.h5 #> â”œâ”€â”€ cell_feature_matrix.tar.gz #> â”œâ”€â”€ cells.csv.gz #> â”œâ”€â”€ cells.parquet #> â”œâ”€â”€ experiment.xenium #> â”œâ”€â”€ gene_panel.json #> â”œâ”€â”€ metrics_summary.csv #> â”œâ”€â”€ morphology.ome.tif #> â”œâ”€â”€ morphology_focus #> â”‚   â”œâ”€â”€ morphology_focus_0000.ome.tif #> â”‚   â”œâ”€â”€ morphology_focus_0001.ome.tif #> â”‚   â”œâ”€â”€ morphology_focus_0002.ome.tif #> â”‚   â””â”€â”€ morphology_focus_0003.ome.tif #> â”œâ”€â”€ nucleus_boundaries.csv.gz #> â”œâ”€â”€ nucleus_boundaries.parquet #> â”œâ”€â”€ transcripts.csv.gz #> â””â”€â”€ transcripts.parquet # Use gene symbols as row names but Ensembl IDs are still in rowData(sfe) (sfe <- readXenium(fn, row.names = \"symbol\")) #> >>> Cell segmentations are found in `.parquet` file(s) #> >>> Reading cell and nucleus segmentations #> >>> Making MULTIPOLYGON nuclei geometries #> >>> Making POLYGON cell geometries #> Sanity checks on cell segmentation polygons: #> >>> ..found 4705 cells with (nested) polygon lists #> >>> ..applying filtering #> >>> Checking polygon validity #> >>> Saving geometries to parquet files #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 140702 cells with counts > 0 #> >>> filtering nucSeg geometries to match 136531 cells with counts > 0 #> class: SpatialFeatureExperiment  #> dim: 541 140702  #> metadata(1): Samples #> assays(1): counts #> rownames(541): ABCC11 ACE2 ... UnassignedCodeword_0498 #>   UnassignedCodeword_0499 #> rowData names(3): ID Symbol Type #> colnames(140702): aaaadnje-1 aaacalai-1 ... oimaiaae-1 oimajkkk-1 #> colData names(9): transcript_counts control_probe_counts ... #>   nucleus_area sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : x_centroid y_centroid #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: micron #> Geometries: #> colGeometries: centroids (POINT), cellSeg (MULTIPOLYGON), nucSeg (MULTIPOLYGON)  #>  #> Graphs: #> sample01:"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"plot-the-tissue","dir":"Articles","previous_headings":"","what":"Plot the tissue","title":"Xenium breast cancer dataset","text":"tissue, cell outlines, looks like  Plot nuclei  Plot cell density space  clearly two different regions, one high cell density, lower density. also seem different spatial structures. Just like finding study area geography, e.g.Â given metropolitan area, may interesting perform spatial analyses different regions tissue separately use different region annotations covariates. Plot total transcript density  Cool, region higher cell density also higher transcript density, sparse region, regions higher transcript density higher cell density. Plot images; image 4 channels, DAPI, ATP1A1/CD45/E-Cadherin, 18S, AlphaSMA/Vimentin, order. images pyramids multiple resolutions; applications require highest resolution. file channel around 370 MB. metadata read R relevant portion image highest resolution necessary loaded memory needed, say plotting. 4 image files, one channel, though XML metadata files connect together BioFormats treats one file. image can plotted plotImage() Voyager, 3 channels can ploted time. Say plot 18S (red), ATP1A1/CD45/E-Cadherin (green), DAPI (blue). specified channel argument, using channel indices. using 3 channels, default indices correspond R, G, B channels order. normalize_channels argument determines channels normalized individually case different channels different dynamic ranges. recommend setting TRUE fluorescent images channel separated separately using different fluorophores bright field images RGB channels imaged simultaneously.  Zoom smaller regions, one dense region, another sparser region Plot bounding boxes full image    Since â€™re using RGB channels color, colorblind friendly. Plot channels separately colorblind friendly:  can also use different color map single channels, viridis  can also plot cell nuclei geometries top images   Plot cells nuclei together; since â€™re still quite lot cells bounding box plot looks busy, can use even smaller bounding box plus cells nuclei. colGeometryName argument can accept vector names colGeometries order plot multiple geometries together, cells nuclei.","code":"plotGeometry(sfe, colGeometryName = \"cellSeg\") plotGeometry(sfe, colGeometryName = \"nucSeg\") plotCellBin2D(sfe, binwidth = 50, hex = TRUE) plotTxBin2D(data_dir = \"xenium2_pancreas\", tech = \"Xenium\", binwidth = 50,             flip = TRUE, hex = TRUE) getImg(sfe) #> X: 34155, Y: 13770, C: 4, Z: 1, T: 1, BioFormatsImage #> imgSource(): #>   /home/runner/work/voyager/voyager/vignettes/xenium2_pancreas/morphology_focus/morphology_focus_0000.ome.tif dir_tree(dirname(imgSource(getImg(sfe)))) #> /home/runner/work/voyager/voyager/vignettes/xenium2_pancreas/morphology_focus #> â”œâ”€â”€ morphology_focus_0000.ome.tif #> â”œâ”€â”€ morphology_focus_0001.ome.tif #> â”œâ”€â”€ morphology_focus_0002.ome.tif #> â””â”€â”€ morphology_focus_0003.ome.tif plotImage(sfe, image_id = \"morphology_focus\", channel = 3:1, show_axes = TRUE,           dark = TRUE, normalize_channels = TRUE) bbox1 <- c(xmin = 5500, xmax = 6000, ymin = -1250, ymax = -750) bbox2 <- c(xmin = 1500, xmax = 2000, ymin = -2000, ymax = -1500) bboxes_sf <- c(st_as_sfc(st_bbox(bbox1)), st_as_sfc(st_bbox(bbox2))) plotImage(sfe, image_id = \"morphology_focus\", channel = 3:1, show_axes = TRUE,           dark = TRUE, normalize_channels = TRUE) +     geom_sf(data = bboxes_sf, fill = NA, color = \"white\", linewidth = 0.5) plotImage(sfe, image_id = \"morphology_focus\", channel = 3:1,           bbox = bbox1, normalize_channels = TRUE) plotImage(sfe, image_id = \"morphology_focus\", channel = 3:1,           bbox = bbox2, normalize_channels = TRUE) p1 <- plotImage(sfe, image_id = \"morphology_focus\", channel = 1,           bbox = bbox2) +     ggtitle(\"DAPI\") p2 <- plotImage(sfe, image_id = \"morphology_focus\", channel = 2,           bbox = bbox2) +     ggtitle(\"ATP1A1/CD45/E-Cadherin\") p1 + p2 plotImage(sfe, image_id = \"morphology_focus\", channel = 1,           bbox = bbox2, palette = viridis_pal()(255)) plotGeometry(sfe, colGeometryName = \"cellSeg\", fill = FALSE, dark = TRUE,              image_id = \"morphology_focus\",               channel = 3:1, bbox = bbox1, normalize_channels = TRUE) plotGeometry(sfe, colGeometryName = \"nucSeg\", fill = FALSE, dark = TRUE,              image_id = \"morphology_focus\",               channel = 3:1, bbox = bbox1, normalize_channels = TRUE) bbox3 <- c(xmin = 5750, xmax = 6000, ymin = -1100, ymax = -850) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\",               channel = 3:1, bbox = bbox3, normalize_channels = TRUE)"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"negative-controls","dir":"Articles","previous_headings":"Quality control","what":"Negative controls","title":"Xenium breast cancer dataset","text":"features genes negative controls According Xenium paper (Janesick2022-rp?), 3 types controls: probe controls assess non-specific binding RNA, decoding controls assess misassigned genes, genomic DNA (gDNA) controls ensure signal RNA. paper explain detail control probes designed. negative controls give us sense false positive rate. number 1, probe control number 2, decoding control Also make indicator whether feature sort negative control addPerCellQCMetrics() function scuttle package can conveniently add transcript counts, proportion total counts, number features detected subset features SCE object. SFE object, SFE inherits SCE. Next plot proportion transcript counts coming negative control.  histogram dominated bin zero extreme outliers seen evident scale x axis. also plot histogram cells least 1 count negative control. NAâ€™s come cells got segmented transcripts detected.  part cells less 10% spots assigned negative controls. Next plot distribution number negative control counts per cell:  counts low, mostly zero, cells 2 counts types aggregated. outlier 30% counts negative controls must low total real transcript counts begin . negative controls indicate prevalence false positives. 2000 140,000 negative control spots detected. 0.338% negative control spots, false positive rate low. cells higher proportion negative control spots (.e.Â low total counts negative control spots detected, >10% ) located space?  Cells negative control spots appear randomly distributed space, cells higher proportion negative control seem -represented less dense area, proportion higher total transcript counts lower begin . negative control spots located?  Generally negative control spots region higher cell transcript density, especially regions high cell density, surprising. donâ€™t visually seem regions negative control spots accounted cell transcript density. contrast, first Xenium preview data 2022 region top left corner negative control probes detected seems like artifact (see JanesickBreastData()).","code":"names(rowData(sfe)) #> [1] \"ID\"     \"Symbol\" \"Type\" unique(rowData(sfe)$Type) #> [1] \"Gene Expression\"           \"Negative Control Probe\"    #> [3] \"Negative Control Codeword\" \"Unassigned Codeword\" is_blank <- rowData(sfe)$Type == \"Unassigned Codeword\" sum(is_blank) #> [1] 103 is_neg <- rowData(sfe)$Type == \"Negative Control Probe\" sum(is_neg) #> [1] 20 is_neg2 <- rowData(sfe)$Type == \"Negative Control Codeword\" sum(is_neg2) #> [1] 41 is_any_neg <- is_blank | is_neg | is_neg2 sfe <- addPerCellQCMetrics(sfe, subsets = list(unassigned = is_blank,                                                negProbe = is_neg,                                                negCodeword = is_neg2,                                                any_neg = is_any_neg)) names(colData(sfe)) #>  [1] \"transcript_counts\"            \"control_probe_counts\"         #>  [3] \"control_codeword_counts\"      \"unassigned_codeword_counts\"   #>  [5] \"deprecated_codeword_counts\"   \"total_counts\"                 #>  [7] \"cell_area\"                    \"nucleus_area\"                 #>  [9] \"sample_id\"                    \"sum\"                          #> [11] \"detected\"                     \"subsets_unassigned_sum\"       #> [13] \"subsets_unassigned_detected\"  \"subsets_unassigned_percent\"   #> [15] \"subsets_negProbe_sum\"         \"subsets_negProbe_detected\"    #> [17] \"subsets_negProbe_percent\"     \"subsets_negCodeword_sum\"      #> [19] \"subsets_negCodeword_detected\" \"subsets_negCodeword_percent\"  #> [21] \"subsets_any_neg_sum\"          \"subsets_any_neg_detected\"     #> [23] \"subsets_any_neg_percent\"      \"total\" cols_use <- names(colData(sfe))[str_detect(names(colData(sfe)), \"_percent$\")] plotColDataHistogram(sfe, cols_use, bins = 100) #> Warning: Removed 2032 rows containing non-finite outside the scale range #> (`stat_bin()`). plotColDataHistogram(sfe, cols_use, bins = 100) +      scale_x_log10() +     annotation_logticks(sides = \"b\") #> Warning in scale_x_log10(): log-10 transformation introduced #> infinite values. #> Warning: Removed 561200 rows containing non-finite outside the scale range #> (`stat_bin()`). cols_use <- names(colData(sfe))[str_detect(names(colData(sfe)), \"_sum$\")] plotColDataHistogram(sfe, cols_use, bins = 20, ncol = 2) +     # Avoid decimal breaks on x axis unless there're too few breaks     scale_x_continuous(breaks = scales::breaks_extended(Q = c(1,2,5))) +     scale_y_log10() +     annotation_logticks(sides = \"l\") #> Warning in scale_y_log10(): log-10 transformation introduced #> infinite values. #> Warning: Removed 69 rows containing missing values or values outside the scale range #> (`geom_bar()`). names(colData(sfe)) #>  [1] \"transcript_counts\"            \"control_probe_counts\"         #>  [3] \"control_codeword_counts\"      \"unassigned_codeword_counts\"   #>  [5] \"deprecated_codeword_counts\"   \"total_counts\"                 #>  [7] \"cell_area\"                    \"nucleus_area\"                 #>  [9] \"sample_id\"                    \"sum\"                          #> [11] \"detected\"                     \"subsets_unassigned_sum\"       #> [13] \"subsets_unassigned_detected\"  \"subsets_unassigned_percent\"   #> [15] \"subsets_negProbe_sum\"         \"subsets_negProbe_detected\"    #> [17] \"subsets_negProbe_percent\"     \"subsets_negCodeword_sum\"      #> [19] \"subsets_negCodeword_detected\" \"subsets_negCodeword_percent\"  #> [21] \"subsets_any_neg_sum\"          \"subsets_any_neg_detected\"     #> [23] \"subsets_any_neg_percent\"      \"total\" data(\"ditto_colors\") sfe$more_neg <- sfe$subsets_any_neg_percent > 10 plotSpatialFeature(sfe, \"subsets_any_neg_sum\", colGeometryName = \"cellSeg\",                    show_axes = TRUE) +     geom_sf(data = SpatialFeatureExperiment::centroids(sfe)[sfe$more_neg,],             size = 0.5, color = ditto_colors[1]) +     theme(legend.position = \"bottom\") tx |>      filter(feature_name %in% rownames(sfe)[is_any_neg]) |>      ggplot(aes(x_location, -y_location)) +     geom_bin2d(binwidth = 50) +     scale_fill_distiller(palette = \"Blues\", direction = 1) +     labs(x = NULL, y = NULL) rm(tx)"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"cells","dir":"Articles","previous_headings":"Quality control","what":"Cells","title":"Xenium breast cancer dataset","text":"QC metrics precomputed stored colData Since â€™re cells, better plot tissue larger, â€™ll plot histogram QC metrics spatial plots separately, unlike CosMx vignette. divided total number transcript molecules detected genes (nCounts) number genes detected (nGenes) total number genes probed, histogram comparable smFISH-based datasets.  â€™re weirdly discrete values number genes detected, excludes negative controls.  Compared FFPE CosMX non-small cell lung cancer dataset, fewer transcripts per gene average smaller proportion genes detected dataset, also FFPE. However, interpreted caution, since two datasets different tissues different gene panels, may may indicate Xenium better detection efficiency CosMX. See (Wang et al. 2023; Cook et al. 2023; Rademacher et al. 2024) systematic comparisons different imaging based technologies tissue.   plots clearly show nCounts nGenes spatially structured may biologically relevant. standard examination look relationship nCounts nGenes:  plot distribution cell area  â€™s long tail. nuclei much smaller cells. cell area distributed space?  largest cells tend sparse area. may biological artifact cell segmentation algorithm . nuclei segmentations plotted instead cell segmentation.  Zoom smaller regions see nature large cells   cases, large cells donâ€™t immediately look like artifacts segmentation, maybe donâ€™t remove QC purposes. Meanwhile see different morphologies cells nuclei can interesting explore. also cells donâ€™t nuclei may nuclei different z-plane may false positives, maybe false negatives regions fluorescence seemingly nuclei cell segmentation. Next calculate proportion cell z-plane taken nucleus, examine distribution:  NAâ€™s cells donâ€™t nuclei detected. also nearly 2500 cells entirely taken nuclei, may due cell type false negative segmenting rest cell. plot nuclei proportion space:  Cells histological regions larger proportions occupied nuclei. interesting check, controlling cell type, cell area, nucleus area, proportion cell occupied nucleus relate gene expression. However, problem performing analysis cell segmentation available one z-plane areas also relate z-plane intersects cell. cell area relate nCounts, nucleus area, proportion area taken nucleus, ? plot pair variables relate matrix plot using ggforce package.  Cool, , generally, nCounts, nGenes, cell area, nucleus area positively correlate , proportion cell area taken nucleus doesnâ€™t seem correlate variables.  seems cells donâ€™t nuclei detected tend smaller, probably less captured tissue section nuclei section. cells without nuclei distributed space?  seems cells without nuclei regions higher cell density; interesting spatial point process analysis. Zoom smaller region inspect, especially cells outside main piece tissue:    QC looking low quality cells. â€™ve explored far, cells negative control counts exceptionally large cells might suspect, cells far outside tissue suspect. types spatial neighborhood graphs, k nearest neighbor graph, cells also affect spatial analysis. remove cells. compute k nearest neighbor graph k = 5 remove cells neighbors far away.  Also look minimum distance neighbors find outlying single cells may less far tissue  â€™s long tail, must small clusters cells away tissue. Say use cutoff 60 microns, see cells .  fastidious, can also compare max neighbor distance cell neighbors order account cell density different parts tissue, extract data image remove cells lack fluorescent signals. remove cells away main tissue, cells low total gene expression, cells small make sense, genes detected.  x axis log transformed better see small values, â€™s obvious outlier. Say use arbitrary cutoff 5 nCounts","code":"names(colData(sfe)) #>  [1] \"transcript_counts\"            \"control_probe_counts\"         #>  [3] \"control_codeword_counts\"      \"unassigned_codeword_counts\"   #>  [5] \"deprecated_codeword_counts\"   \"total_counts\"                 #>  [7] \"cell_area\"                    \"nucleus_area\"                 #>  [9] \"sample_id\"                    \"sum\"                          #> [11] \"detected\"                     \"subsets_unassigned_sum\"       #> [13] \"subsets_unassigned_detected\"  \"subsets_unassigned_percent\"   #> [15] \"subsets_negProbe_sum\"         \"subsets_negProbe_detected\"    #> [17] \"subsets_negProbe_percent\"     \"subsets_negCodeword_sum\"      #> [19] \"subsets_negCodeword_detected\" \"subsets_negCodeword_percent\"  #> [21] \"subsets_any_neg_sum\"          \"subsets_any_neg_detected\"     #> [23] \"subsets_any_neg_percent\"      \"total\"                        #> [25] \"more_neg\" n_panel <- sum(!is_any_neg) sfe$nCounts <- colSums(counts(sfe)[!is_any_neg,]) sfe$nGenes <- colSums(counts(sfe)[!is_any_neg,] > 0) colData(sfe)$nCounts_normed <- sfe$nCounts/n_panel colData(sfe)$nGenes_normed <- sfe$nGenes/n_panel plotColDataHistogram(sfe, c(\"nCounts\", \"nGenes\")) plotColDataHistogram(sfe, c(\"nCounts_normed\", \"nGenes_normed\")) plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"cellSeg\") plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"cellSeg\") plotColData(sfe, x=\"nCounts\", y=\"nGenes\", bins = 70) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. plotColDataHistogram(sfe, c(\"cell_area\", \"nucleus_area\"), scales = \"free_y\") #> Warning: Removed 4171 rows containing non-finite outside the scale range #> (`stat_bin()`). plotSpatialFeature(sfe, \"cell_area\", colGeometryName = \"cellSeg\",                     show_axes = TRUE) plotSpatialFeature(sfe, \"nucleus_area\", colGeometryName = \"nucSeg\",                    show_axes = TRUE) bbox3 <- c(xmin = 1350, xmax = 1550, ymin = -1750, ymax = -1550) bbox4 <- c(xmin = 3400, xmax = 3600, ymin = -2900, ymax = -2700) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\",               channel = 3:1, bbox = bbox3, normalize_channels = TRUE) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\",               channel = 3:1, bbox = bbox4, normalize_channels = TRUE) colData(sfe)$prop_nuc <- sfe$nucleus_area / sfe$cell_area summary(sfe$prop_nuc) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's  #>   0.029   0.318   0.435   0.451   0.564   1.000    4171 plotColDataHistogram(sfe, \"prop_nuc\") #> Warning: Removed 4171 rows containing non-finite outside the scale range #> (`stat_bin()`). plotSpatialFeature(sfe, \"prop_nuc\", colGeometryName = \"cellSeg\") cols_use <- c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\", \"prop_nuc\") df <- colData(sfe)[,cols_use] |> as.data.frame() ggplot(df) +     geom_bin2d(aes(x = .panel_x, y = .panel_y), bins = 30) +     geom_autodensity(fill = \"gray90\", color = \"gray70\", linewidth = 0.2) +     facet_matrix(vars(tidyselect::everything()), layer.diag = 2) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Warning: Removed 58394 rows containing non-finite outside the scale range #> (`stat_bin2d()`). #> Warning: Removed 8342 rows containing non-finite outside the scale range #> (`stat_autodensity()`). sfe$has_nuclei <- !is.na(sfe$nucleus_area) plotColData(sfe, y = \"has_nuclei\", x = \"cell_area\",              point_fun = function(...) list()) plotSpatialFeature(sfe, \"has_nuclei\", colGeometryName = \"cellSeg\",                    show_axes = TRUE) +     # To highlight the cells that don't have nuclei     geom_sf(data = SpatialFeatureExperiment::centroids(sfe)[!sfe$has_nuclei,],              color = ditto_colors[1], size = 0.3) bbox5 <- c(xmin = 6400, xmax = 6800, ymin = -300, ymax = -50) bbox6 <- c(xmin = 600, xmax = 1000, ymin = -600, ymax = -300) bbox7 <- c(xmin = 6800, xmax = 7200, ymin = -2900, ymax = -2500) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\", show_axes = TRUE,              channel = 3:1, bbox = bbox5, normalize_channels = TRUE) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\", show_axes = TRUE,              channel = 3:1, bbox = bbox6, normalize_channels = TRUE) plotGeometry(sfe, colGeometryName = c(\"cellSeg\", \"nucSeg\"), fill = FALSE,               dark = TRUE, image_id = \"morphology_focus\", show_axes = TRUE,              channel = 3:1, bbox = bbox7, normalize_channels = TRUE) g <- findKNN(spatialCoords(sfe)[,1:2], k = 5, BNPARAM = AnnoyParam()) max_dist <- rowMaxs(g$distance) data.frame(max_dist = max_dist) |>      ggplot(aes(max_dist)) +     geom_histogram(bins = 100) +     scale_y_continuous(transform = \"log1p\") +     scale_x_continuous(breaks = breaks_pretty()) +     annotation_logticks(sides = \"l\") min_dist <- rowMins(g$distance) data.frame(min_dist = min_dist) |>      ggplot(aes(min_dist)) +     geom_histogram(bins = 100) +     scale_y_continuous(transform = \"log1p\") +     scale_x_continuous(breaks = breaks_pretty()) +     annotation_logticks(sides = \"l\") sfe$main_tissue <- !(max_dist > 60 | min_dist > 50) plotSpatialFeature(sfe, \"main_tissue\", colGeometryName = \"cellSeg\",                    show_axes = TRUE) +     # To highlight the outliers     geom_sf(data = SpatialFeatureExperiment::centroids(sfe)[!sfe$main_tissue,],              color = ditto_colors[1], size = 0.3) plotColDataHistogram(sfe, c(\"nCounts\", \"cell_area\")) +     scale_x_log10() +     annotation_logticks(sides = \"b\") #> Warning in scale_x_log10(): log-10 transformation introduced #> infinite values. #> Warning: Removed 508 rows containing non-finite outside the scale range #> (`stat_bin()`). sfe <- sfe[,sfe$main_tissue & sfe$nCounts > 5] sfe <- sfe[rowSums(counts(sfe)) > 0,] dim(sfe) #> [1]    505 132203"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"Xenium breast cancer dataset","text":"look mean variance gene Real genes generally higher mean expression across cells negative controls. mean gene across cells.  real genes negative controls plotted different colors  red line y=xy = x expected data follows Poisson distribution. Negative controls real genes form mostly separate clusters. Negative controls stick close line, real genes overdispersed. Unlike CosMX dataset, negative controls donâ€™t seem overdispersed. Overdispersion gene expression can caused transcription bursts cell type heterogeneity, also positive negative spatial autocorrelation (Chun2018-ar?; Griffith2011-lx?).","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_neg <- rowData(sfe)$Type != \"Gene Expression\" plotRowData(sfe, x = \"means\", y = \"is_neg\") +     scale_y_log10() +     annotation_logticks(sides = \"b\") plotRowData(sfe, x=\"means\", y=\"vars\", color_by = \"is_neg\") +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() +     labs(color = \"Negative control\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"spatial-autocorrelation-of-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of QC metrics","title":"Xenium breast cancer dataset","text":"â€™s sparse dense region. poses question type neighborhood graph use, e.g.Â conceivable cells sparse region just singletons. Furthermore, unclear length scale influence might . might depend cell type contact secreted signals used cell type, length scale influence. k nearest neighbors used, neighbors dense region much closer together sparse region. distance based neighbors used, cells dense region neighbors cells sparse region, sparse region can break multiple compartments distance cutoff long enough. purpose demonstration, use k nearest neighbors k=5k = 5, inverse distance weighting. Note using neighbors leads longer computation time spatial autocorrelation metrics. think makes sense replace NA 0 nucleus area though generally 0 appropriate substitute NA. Global Moranâ€™s indicates positive spatial autocorrelation. global spatial autocorrelation QC metrics moderate weak, least level single cells using k nearest neighbor graph k = 5. earlier plots metrics, may stronger spatial autocorrelation longer length scale. strength spatial autocorrelation can vary spatially, also run local Moranâ€™s . pointsize argument adjusts point size scattermore. default 0, meaning single pixels, since cells sparse region hard see way, increase pointsize. still plot polygons larger single panel plots, use scattermore multi-panel plots polygons panel invisible anyway due small size save time.  seems glandular areas tend homogeneous, greatly contributing global Moranâ€™s value, tissue spatially autocorrelated metrics. IiI_i value thing computed local Moranâ€™s . P-values types neighborhoods also computed. â€œType neighborhoodâ€ include cells low values neighbors low values (low-low), low-high, high-high, high-low, â€œlowâ€ â€œhighâ€ relative mean. One can make scatter plot value cell x axis spatially weighted average cellâ€™s neighbors spatial neighborhood graph y axis; Moran scatter plot. neighborhood types quadrants plot. However, value doesnâ€™t deviate much mean, neighborhood type might mean much, seem highlight tissue structure. Another caveat mean entire section, tissue morphology, clearly two different regions within section. cool method better determine areas tissue spatial analysis can best answer questions interest. might make sense analyze sparse dense regions separately point.  â€™s hard see without zooming .    center divergent palette âˆ’log100.05-\\mathrm{log}_{10}0.05 p-values corrected multiple testing (see spdep::p.adjustSP()). Warm color indicates â€œsignificantâ€ cool color indicates â€œsignificantâ€ based conventional threshold. dense region, metrics, local Moranâ€™s generally significant.    sparser region, â€™re areas local Moranâ€™s significant metrics. seems locally can mixture positive negative spatial autocorrelation, though part local Moranâ€™s statistically significant significant parts high-high regions. make ? Moran plot nCounts  obvious clusters based 2D histogram showing point density scatter plot. W style (adjacency matrix edge weights row sums 1), slope least square line fitted scatter plot Moranâ€™s (Anselin1996-mo?).","code":"colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                dist_type = \"idw\", k = 5,                                                style = \"W\") sfe$nucleus_area <- ifelse(is.na(sfe$nucleus_area), 0, sfe$nucleus_area) sfe <- colDataMoransI(sfe, c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                       colGraphName = \"knn5\") colFeatureData(sfe)[c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),] #> DataFrame with 4 rows and 2 columns #>              moran_sample01 K_sample01 #>                   <numeric>  <numeric> #> nCounts            0.267997   11.28612 #> nGenes             0.250060    5.19305 #> cell_area          0.193415   11.54262 #> nucleus_area       0.221477   16.25204 sfe <- colDataUnivariate(sfe, type = \"localmoran\",                           features = c(\"nCounts\", \"nGenes\", \"cell_area\",                                        \"nucleus_area\"),                          colGraphName = \"knn5\", BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, \"localmoran\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"centroids\", scattermore = TRUE,                 divergent = TRUE, diverge_center = 0, pointsize = 1.5,                 ncol = 1) localResultAttrs(sfe, \"localmoran\", \"nCounts\") #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\" plotLocalResult(sfe, \"localmoran\", attribute = \"pysal\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"centroids\", scattermore = TRUE, pointsize = 1.5,                 ncol = 1, size = 3) plotLocalResult(sfe, \"localmoran\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", divergent = TRUE, diverge_center = 0,                 ncol = 2, bbox = bbox1) plotLocalResult(sfe, \"localmoran\", attribute = \"pysal\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", bbox = bbox1, ncol = 2) plotLocalResult(sfe, \"localmoran\", attribute = \"-log10p_adj\",                  features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", divergent = TRUE,                  diverge_center = -log10(0.05),                 ncol = 2, bbox = bbox1) plotLocalResult(sfe, \"localmoran\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", divergent = TRUE, diverge_center = 0,                 ncol = 2, bbox = bbox2) plotLocalResult(sfe, \"localmoran\", attribute = \"pysal\",                 features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", bbox = bbox2, ncol = 2) plotLocalResult(sfe, \"localmoran\", attribute = \"-log10p_adj\",                  features = c(\"nCounts\", \"nGenes\", \"cell_area\", \"nucleus_area\"),                 colGeometryName = \"cellSeg\", divergent = TRUE,                  diverge_center = -log10(0.05),                 ncol = 2, bbox = bbox2) sfe <- colDataUnivariate(sfe, \"moran.plot\", \"nCounts\", colGraphName = \"knn5\") moranPlot(sfe, \"nCounts\", binned = TRUE, plot_influential = FALSE, bins = c(150, 60))"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moranâ€™s I","title":"Xenium breast cancer dataset","text":"default, gene expression, log normalized counts used spatial autocorrelation metrics many statistical methods developed normally distributed data can technical artifacts affecting raw gene counts per cell, running Moranâ€™s , normalize data. single cell tradition, total counts (nCounts) treated like technical artifact normalized away, makes sense given transcript capture PCR amplification steps single cell RNA-seq protocol. However, seen , nCounts clearly biologically relevant spatial structure, imaging based technologies donâ€™t steps. Furthermore, imaging based technologies, typically curated gene panel hundred genes targeting certain cell types interest used, scRNA-seq usually untargeted transcriptome wide. Due skewed gene panel, nCounts biologically skewed well using normalize data can lead false negatives finding spatially variable genes differential expression (Atta2024-tl?). Sometimes cell area used normalizing imaging based data, makes sense larger cells room transcripts seen matrix plot, cell area positively correlate nCounts. However, seen earlier cell level QC plots, cell size also spatially structured seemingly biologically relevant cells types tend larger cells types, though global Moranâ€™s bit weaker nCounts. Often cells larger get captured section cells smaller less section, still technical component. (Atta2024-tl?), normalizing cell area normalizing also examined; SVG DE results comparable using representative gene panel, fewer false positives false negatives compared normalizing nCounts. Due technical effect partial capture cells section, (Atta2024-tl?) recommends normalizing cell area â€™s reliable. cell area XOA v1 cell segmentations look like Voroni tessellation doesnâ€™t seem reliable, multiple fluorescent stains XOA v2, seems much better, â€™ll normalize cell area noting caveat cell area can biologically relevant. Use cores available speed . â€™s slower gene count matrix actually disk thanks DelayedArray loaded memory.  expected, generally negative controls tightly clustered around 0, real genes positive Moranâ€™s , means generally technical artifact spatial trend. genes highest Moranâ€™s ?  AMY2A amylase alpha 2A, involved breaking starch. INS insulin. GCG glucagon. GATM glycine amidinotransferase involved creatine biosynthesis. dense area exocrine acini making digestive enzymes endocrine Langerhanâ€™s islets making insulin glucagon. spatially structured. Zoom smaller area   GPRC5A G protein-coupled receptor class C group 5 member , may play role embryonic development epithelial cell differentiation. SST somatostatin, regulator endocrine system. CFTR encodes chlorine ion channel whose mutation causes cystic fibrosis. DMBT1 stands deleted malignant brain tumors 1. â€œLoss sequences human chromosome 10q associated progression human cancersâ€, according RefSeq. sparse region probably cancerous. Zoom smaller area  Moranâ€™s relate gene expression level?  highly expressed genes higher Moranâ€™s , less expressed genes higher Moranâ€™s well.","code":"sfe <- logNormCounts(sfe, size.factor = sfe$cell_area) system.time(     sfe <- runMoransI(sfe, colGraphName = \"knn5\", BPPARAM = MulticoreParam(2)) ) #>     user   system  elapsed  #> 1109.596    2.593 1125.600 plotRowData(sfe, x = \"moran_sample01\", y = \"is_neg\") top_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[1:4]] plotSpatialFeature(sfe, top_moran, colGeometryName = \"centroids\",                    scattermore = TRUE, pointsize = 1.5, ncol = 1) bbox8 <- c(xmin = 4950, xmax = 5450, ymin = -1000, ymax = -500) plotSpatialFeature(sfe, top_moran, colGeometryName = \"cellSeg\", ncol = 2,                    bbox = bbox8) top_moran2 <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[5:8]] plotSpatialFeature(sfe, top_moran2, colGeometryName = \"centroids\",                    scattermore = TRUE, pointsize = 1.5, ncol = 1) plotSpatialFeature(sfe, top_moran2, colGeometryName = \"cellSeg\", ncol = 2,                    bbox = bbox2) plotRowData(sfe, x = \"means\", y = \"moran_sample01\", color_by = \"is_neg\") +     scale_x_log10() + annotation_logticks(sides = \"b\") sfe <- sfe[rowData(sfe)$Type == \"Gene Expression\",]"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"non-spatial-dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Non-spatial dimension reduction and clustering","title":"Xenium breast cancer dataset","text":"run non-spatial PCA scRNA-seq data     spatial region explicitly used, PCâ€™s highlight spatial regions due spatial autocorrelation gene expression histological regions different cell types. Since PCA finds linear combinations genes maximize variance explained, genes explain variance spatially structured, linear combinations also spatially structured. Non-spatial clustering locating clusters space Now scater can also rasterize plots lots points rasterise argument, different mechanism scattermore requires system dependencies.  Plot location clusters space   Since principal components spatially structured, clusters found PCs spatially structured.","code":"set.seed(29) sfe <- runPCA(sfe, ncomponents = 30, scale = TRUE, BSPARAM = IrlbaParam(), ntop = Inf) ElbowPlot(sfe, ndims = 30) plotDimLoadings(sfe, dims = 1:8) spatialReducedDim(sfe, \"PCA\", 4, colGeometryName = \"centroids\", divergent = TRUE,                   diverge_center = 0, ncol = 1, scattermore = TRUE, pointsize = 1.5) spatialReducedDim(sfe, \"PCA\", components = 5:8, colGeometryName = \"centroids\",                    divergent = TRUE, diverge_center = 0,                    ncol = 1, scattermore = TRUE, pointsize = 1.5) colData(sfe)$cluster <- clusterRows(reducedDim(sfe, \"PCA\")[,1:15],                                     BLUSPARAM = SNNGraphParam(                                         cluster.fun = \"leiden\",                                         cluster.args = list(                                             resolution_parameter = 0.5,                                             objective_function = \"modularity\"))) plotPCA(sfe, ncomponents = 4, colour_by = \"cluster\", scattermore = TRUE) plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"centroids\", scattermore = TRUE,                    pointsize = 1.2, size = 3) plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\", bbox = bbox1) +     plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\", bbox = bbox2) +     plotSpatialFeature(sfe, \"cluster\", colGeometryName = \"cellSeg\", bbox = bbox8) +     plot_layout(guides = \"collect\") &     theme(legend.position = \"bottom\", legend.byrow = TRUE) &      guides(fill = guide_legend(nrow = 2))"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"differential-expression","dir":"Articles","previous_headings":"","what":"Differential expression","title":"Xenium breast cancer dataset","text":"Cluster marker genes found Wilcoxon rank sum test commonly done scRNA-seq. â€™s already sorted p-values: code extracts significant markers cluster:  allows plotting top marker genes heatmap:","code":"markers <- findMarkers(sfe, groups = colData(sfe)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") markers[[6]] #> DataFrame with 377 rows and 14 columns #>             p.value          FDR summary.AUC     AUC.1     AUC.2     AUC.3 #>           <numeric>    <numeric>   <numeric> <numeric> <numeric> <numeric> #> MS4A6A 1.54756e-170 5.83430e-168    0.728480  0.743662  0.725008  0.688186 #> CD163  1.48909e-148 2.80693e-146    0.713027  0.718190  0.703405  0.680758 #> AIF1    6.69728e-96  8.41625e-94    0.637606  0.694124  0.670373  0.640145 #> FCGR3A  2.49289e-70  2.34955e-68    0.645328  0.643317  0.632489  0.617025 #> MS4A4A  7.05597e-60  5.32020e-58    0.633727  0.640578  0.633061  0.609777 #> ...             ...          ...         ...       ...       ...       ... #> TM4SF4            1            1    0.152899  0.489888  0.500690  0.501982 #> TMC5              1            1    0.177768  0.177768  0.490913  0.505456 #> TRAC              1            1    0.312213  0.507782  0.506559  0.312213 #> UBE2C             1            1    0.331111  0.331111  0.498855  0.502251 #> VCAN              1            1    0.351751  0.351751  0.460870  0.536997 #>            AUC.4     AUC.5     AUC.7     AUC.8     AUC.9    AUC.10    AUC.11 #>        <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> #> MS4A6A  0.689521  0.731695  0.728480  0.724667  0.738094  0.730736  0.696289 #> CD163   0.680368  0.710473  0.713027  0.707486  0.713043  0.708168  0.683770 #> AIF1    0.637606  0.681605  0.682232  0.679472  0.692595  0.679824  0.652220 #> FCGR3A  0.624603  0.641296  0.645328  0.636947  0.648485  0.640735  0.626461 #> MS4A4A  0.608129  0.639219  0.633727  0.629561  0.641152  0.636996  0.610286 #> ...          ...       ...       ...       ...       ...       ...       ... #> TM4SF4  0.498836  0.460481  0.152899  0.500159  0.366336  0.494070  0.501890 #> TMC5    0.500076  0.412480  0.138520  0.501989  0.506229  0.497249  0.504688 #> TRAC    0.481514  0.518893  0.512786  0.510173  0.522509  0.519817  0.475692 #> UBE2C   0.501846  0.501722  0.502851  0.502407  0.504580  0.502875  0.503125 #> VCAN    0.515555  0.625376  0.635795  0.577924  0.624523  0.638970  0.498552 #>           AUC.12 #>        <numeric> #> MS4A6A  0.718032 #> CD163   0.696584 #> AIF1    0.669220 #> FCGR3A  0.629885 #> MS4A4A  0.625454 #> ...          ... #> TM4SF4  0.500816 #> TMC5    0.498134 #> TRAC    0.492296 #> UBE2C   0.498117 #> VCAN    0.204336 genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe, genes_use, x = \"cluster\", point_fun = function(...) list()) genes_use2 <- unique(unlist(lapply(markers, function(x) rownames(x)[1:5]))) plotGroupedHeatmap(sfe, genes_use2, group = \"cluster\", colour = scales::viridis_pal()(100))"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"local-spatial-statistics-of-marker-genes","dir":"Articles","previous_headings":"","what":"Local spatial statistics of marker genes","title":"Xenium breast cancer dataset","text":"First plot genes space reference  Global Moranâ€™s marker genes shown : marker genes except CRHBP positive spatial autocorrelation, stronger others. Local Moranâ€™s marker genes shown :  donâ€™t see much local negative spatial autocorrelation compared positive spatial autocorrelation. Also zoom regions    Zooming , â€™s interesting see local negative spatial autocorrelation genes regions donâ€™t seem like spatial outliers seem pattern, VCAN. can also compute plot local Moranâ€™s dimension reduction components PCA NMF. Concordex clustering proportion spatial neighbors non-spatial cluster label, sounds little like local Moranâ€™s labels. interesting clustering local Moranâ€™s select genes NMF components.","code":"plotSpatialFeature(sfe, genes_use, colGeometryName = \"centroids\", ncol = 2,                    pointsize = 0, scattermore = TRUE) setNames(rowData(sfe)[genes_use, \"moran_sample01\"], genes_use) #>        GPRC5A         CRHBP          IL7R          CPA3          CFTR  #>  0.7452986745 -0.0005381635  0.2475148484  0.1978744218  0.6687634585  #>        MS4A6A        TM4SF4        PECAM1           INS         AMY2A  #>  0.1457565362  0.2700427034  0.2082672326  0.7887360003  0.9154877143  #>          MZB1          VCAN  #>  0.1234801686  0.3757000101 sfe <- runUnivariate(sfe, \"localmoran\", features = genes_use, colGraphName = \"knn5\",                      BPPARAM = MulticoreParam(2)) plotLocalResult(sfe, \"localmoran\", features = genes_use,                  colGeometryName = \"centroids\", ncol = 2, divergent = TRUE,                 diverge_center = 0, scattermore = TRUE, pointsize = 0) plotLocalResult(sfe, \"localmoran\", features = genes_use,                  colGeometryName = \"cellSeg\", ncol = 3, divergent = TRUE,                 diverge_center = 0, bbox = bbox1) plotLocalResult(sfe, \"localmoran\", features = genes_use,                  colGeometryName = \"cellSeg\", ncol = 3, divergent = TRUE,                 diverge_center = 0, bbox = bbox2) plotLocalResult(sfe, \"localmoran\", features = genes_use,                  colGeometryName = \"cellSeg\", ncol = 3, divergent = TRUE,                 diverge_center = 0, bbox = bbox8)"},{"path":"https://pachterlab.github.io/voyager/articles/vig5_xenium.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Xenium breast cancer dataset","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8          LC_NUMERIC=C              #>  [3] LC_TIME=C.UTF-8           LC_COLLATE=C.UTF-8        #>  [5] LC_MONETARY=C.UTF-8       LC_MESSAGES=C.UTF-8       #>  [7] LC_PAPER=C.UTF-8          LC_NAME=C.UTF-8           #>  [9] LC_ADDRESS=C.UTF-8        LC_TELEPHONE=C.UTF-8      #> [11] LC_MEASUREMENT=C.UTF-8    LC_IDENTIFICATION=C.UTF-8 #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] BiocNeighbors_2.0.0            tidyr_1.3.1                    #>  [3] dplyr_1.1.4                    arrow_17.0.0.1                 #>  [5] sf_1.0-19                      fs_1.6.5                       #>  [7] RBioFormats_1.6.0              patchwork_1.3.0                #>  [9] scran_1.34.0                   bluster_1.16.0                 #> [11] BiocSingular_1.22.0            BiocParallel_1.40.0            #> [13] scales_1.3.0                   scater_1.34.0                  #> [15] scuttle_1.16.0                 stringr_1.5.1                  #> [17] ggforce_0.4.2                  ggplot2_3.5.1                  #> [19] SpatialExperiment_1.16.0       SingleCellExperiment_1.28.1    #> [21] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [23] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [25] IRanges_2.40.0                 S4Vectors_0.44.0               #> [27] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [29] matrixStats_1.4.1              SFEData_1.8.0                  #> [31] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               polyclip_1.10-7           #>   [7] lifecycle_1.0.4           edgeR_4.4.0               #>   [9] lattice_0.22-6            MASS_7.3-61               #>  [11] magrittr_2.0.3            limma_3.62.1              #>  [13] sass_0.4.9                rmarkdown_2.29            #>  [15] jquerylib_0.1.4           yaml_2.3.10               #>  [17] metapod_1.14.0            sp_2.1-4                  #>  [19] cowplot_1.1.3             RColorBrewer_1.1-3        #>  [21] DBI_1.2.3                 multcomp_1.4-26           #>  [23] abind_1.4-8               spatialreg_1.3-5          #>  [25] zlibbioc_1.52.0           purrr_1.0.2               #>  [27] R.utils_2.12.3            RCurl_1.98-1.16           #>  [29] TH.data_1.1-2             tweenr_2.0.3              #>  [31] rappdirs_0.3.3            sandwich_3.1-1            #>  [33] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [35] irlba_2.3.5.1             terra_1.7-83              #>  [37] pheatmap_1.0.12           units_0.8-5               #>  [39] RSpectra_0.16-2           dqrng_0.4.1               #>  [41] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [43] codetools_0.2-20          DropletUtils_1.26.0       #>  [45] DelayedArray_0.32.0       xml2_1.3.6                #>  [47] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [49] memuse_4.2-3              farver_2.1.2              #>  [51] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [53] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [55] e1071_1.7-16              survival_3.7-0            #>  [57] systemfonts_1.1.0         tools_4.4.2               #>  [59] ggnewscale_0.5.0          ragg_1.3.3                #>  [61] sfarrow_0.4.1             Rcpp_1.0.13-1             #>  [63] glue_1.8.0                gridExtra_2.3             #>  [65] SparseArray_1.6.0         mgcv_1.9-1                #>  [67] xfun_0.49                 EBImage_4.48.0            #>  [69] HDF5Array_1.34.0          withr_3.0.2               #>  [71] BiocManager_1.30.25       fastmap_1.2.0             #>  [73] boot_1.3-31               rhdf5filters_1.18.0       #>  [75] fansi_1.0.6               spData_2.3.3              #>  [77] rsvd_1.0.5                digest_0.6.37             #>  [79] R6_2.5.1                  textshaping_0.4.0         #>  [81] colorspace_2.1-1          wk_0.9.4                  #>  [83] scattermore_1.2           LearnBayes_2.15.1         #>  [85] jpeg_0.1-10               RSQLite_2.3.8             #>  [87] R.methodsS3_1.8.2         hexbin_1.28.5             #>  [89] utf8_1.2.4                generics_0.1.3            #>  [91] data.table_1.16.2         class_7.3-22              #>  [93] httr_1.4.7                htmlwidgets_1.6.4         #>  [95] S4Arrays_1.6.0            spdep_1.3-6               #>  [97] pkgconfig_2.0.3           rJava_1.0-11              #>  [99] scico_1.5.0               gtable_0.3.6              #> [101] blob_1.2.4                XVector_0.46.0            #> [103] htmltools_0.5.8.1         fftwtools_0.9-11          #> [105] png_0.1-8                 knitr_1.49                #> [107] rjson_0.2.23              coda_0.19-4.1             #> [109] nlme_3.1-166              curl_6.0.1                #> [111] proxy_0.4-27              cachem_1.1.0              #> [113] zoo_1.8-12                rhdf5_2.50.0              #> [115] BiocVersion_3.20.0        KernSmooth_2.23-24        #> [117] vipor_0.4.7               parallel_4.4.2            #> [119] AnnotationDbi_1.68.0      desc_1.4.3                #> [121] s2_1.1.7                  pillar_1.9.0              #> [123] grid_4.4.2                vctrs_0.6.5               #> [125] dbplyr_2.5.0              beachmat_2.22.0           #> [127] sfheaders_0.4.4           cluster_2.1.6             #> [129] beeswarm_0.4.0            evaluate_1.0.1            #> [131] zeallot_0.1.0             magick_2.8.5              #> [133] mvtnorm_1.3-2             cli_3.6.3                 #> [135] locfit_1.5-9.10           compiler_4.4.2            #> [137] rlang_1.1.4               crayon_1.5.3              #> [139] labeling_0.4.3            classInt_0.4-10           #> [141] ggbeeswarm_0.7.2          stringi_1.8.4             #> [143] viridisLite_0.4.2         deldir_2.0-4              #> [145] assertthat_0.2.1          munsell_0.5.1             #> [147] Biostrings_2.74.0         tiff_0.1-12               #> [149] Matrix_1.7-1              ExperimentHub_2.14.0      #> [151] sparseMatrixStats_1.18.0  bit64_4.5.2               #> [153] Rhdf5lib_1.28.0           KEGGREST_1.46.0           #> [155] statmod_1.5.0             AnnotationHub_3.14.0      #> [157] igraph_2.1.1              memoise_2.0.1             #> [159] bslib_0.8.0               bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MERFISH mouse liver dataset and considerations of large data","text":"SpatialFeatureExperiment (SFE) Voyager packages originally developed around relatively small Visium dataset proof concept, hence originally optimized large datasets. However, larger smFISH datasets hundreds thousands, sometimes million cells already produced soon produced routinely. Among studies using smFISH-based spatial transcriptomics technologies reported number cells per dataset, number cells per dataset increased past years (Moses2022-xz?). anticipation large datasets, vignette produced using limited GitHub Actions resources (MacOS), 14 GB RAM 3 CPU cores 14 GB disk space, comparable laptops. therefore expect analyses vignette scale reasonably sized datasets. dataset use vignette MERFISH mouse liver dataset downloaded Vizgen website. use discuss issues large datasets upcoming features next release Voyager. gene count matrix cell metadata (including centroid coordinates) downloaded CSV files read R. 7 z-planes imaged, cell segmentation available one z-plane. cell polygons HDF5 files, one HDF5 file per field view (FOV), 1000 FOVs dataset. Converting HDF5 files sf data frame trivial. See vignette creating SpatialFeatureExperiment (SFE) object code used conversion, polygons included SFE object. cell metadata already cell volume. polygons used analyses, polygons canâ€™t seen static plot hundreds thousands cells anyway, conversion optional. transcript spot locations available, yet work large point dataset. load packages used. 395,215 cells dataset. Plotting polygons takes , isnâ€™t bad.  However, wish save plot PDF. avoid problem, can either use scattermore = TRUE argument plotSpatialFeature() plot centroids since polygons hard see anyway. Cell density can vaguely seen plot . count number cells bins better visualize cell density.  Cell density part homogeneous shows structure denser regions seem relate blood vessels.","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(scater)  library(ggplot2) library(patchwork) library(stringr) library(spdep) library(BiocParallel) library(BiocSingular) library(gstat) library(BiocNeighbors) library(sf) library(automap) theme_set(theme_bw()) (sfe <- VizgenLiverData()) #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache #> class: SpatialFeatureExperiment  #> dim: 385 395215  #> metadata(0): #> assays(1): counts #> rownames(385): Comt Ldha ... Blank-36 Blank-37 #> rowData names(3): means vars cv2 #> colnames(395215): 10482024599960584593741782560798328923 #>   111551578131181081835796893618918348842 ... #>   92389687374928708938472537234969690424 #>   96399783859933548456002372694492036651 #> colData names(9): fov volume ... nCounts nGenes #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01: plotGeometry(sfe, colGeometryName = \"cellSeg\") plotCellBin2D(sfe, bins = 300, hex = TRUE)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"quality-control","dir":"Articles","previous_headings":"","what":"Quality control","title":"MERFISH mouse liver dataset and considerations of large data","text":"Plotting almost 400,000 polygons kind slow doable.  nCounts kind looks like salt pepper. Using scattermore package can speed plotting large number points. non-interactive plot, cell polygons small see anyway, plotting cell centroid points fine.  run server, plotting almost 400,000 polygons took around 23 seconds, using geom_scattermore() (scattermore = TRUE) took 2 seconds. Since geom_scattermore() rasterizes plot, plot pixelated zoomed . interactive data visualization useful ESDA, need static figures publications. Voyager 1.2.0 (Bioconductor release), bounding box can specified zoom data.  Much time making plot spent subsetting sf data frame bounding box. , spatial autocorrelation evident upper right region smaller cells, less rest patch. nCounts seems related cell size; larger cells seem total counts. Interactive data visualization currently beyond scope Voyager vignette. existing tools interactive visualization highly multiplexed imaging data, MERmaid (Wang2020-sv?) MERFISH data, TissUUmaps (Behanova2023-gl?), Visinity (Warchol2023-zw?), samui broswer (Sriworarat2023-jl?). Since arenâ€™t many genes, genes negative control probes can displayed: number real genes 347. Next, plot distribution nCounts divided number genes panel, distribution comparable across datasets different numbers genes.  Xenium dataset, mysterious regular notches histogram number genes detected. also plot number genes detected per cell, geom_scattermore().  Similarly nCounts, points look intermingled. Distribution cell volume space:  Next, explore nCounts relates nGenes:  two branches plot. cell size relate nCounts?  lower branch larger cells donâ€™t tend total counts, upper branch larger cells tend total counts. also examine cell size relates number genes detected:  seem clusters possibly related cell type.","code":"names(colData(sfe)) #> [1] \"fov\"       \"volume\"    \"min_x\"     \"max_x\"     \"min_y\"     \"max_y\"     #> [7] \"sample_id\" \"nCounts\"   \"nGenes\" system.time(     print(plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"cellSeg\")) ) #>    user  system elapsed  #>  14.396   0.064  14.460 system.time({     print(plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"centroids\",                              scattermore = TRUE)) }) #>    user  system elapsed  #>   0.735   0.008   0.743 bbox_use <- c(xmin = 3000, xmax = 3500, ymin = 2500, ymax = 3000) plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"cellSeg\", bbox = bbox_use) rownames(sfe) #>   [1] \"Comt\"          \"Ldha\"          \"Pck1\"          \"Akr1a1\"        #>   [5] \"Ugt2b1\"        \"Acsl5\"         \"Ugt2a3\"        \"Igf1\"          #>   [9] \"Errfi1\"        \"Serping1\"      \"Adh4\"          \"Hsd17b2\"       #>  [13] \"Tpi1\"          \"Cyp1a2\"        \"Acsl1\"         \"Akr1d1\"        #>  [17] \"Alas1\"         \"Aldh7a1\"       \"G6pc\"          \"Hsd17b12\"      #>  [21] \"Pdhb\"          \"Gpd1\"          \"Cyp7b1\"        \"Pgam1\"         #>  [25] \"Hc\"            \"Dld\"           \"Cyp2c23\"       \"Proz\"          #>  [29] \"Acss2\"         \"Psap\"          \"Cald1\"         \"Hsd3b3\"        #>  [33] \"Galm\"          \"Cxcl12\"        \"Sardh\"         \"Cebpa\"         #>  [37] \"Aldh3a2\"       \"Gck\"           \"Sdc1\"          \"Pdha1\"         #>  [41] \"Npc2\"          \"Hsd17b6\"       \"Aqp1\"          \"Adh7\"          #>  [45] \"Smpdl3a\"       \"Egfr\"          \"Pgm1\"          \"Fasn\"          #>  [49] \"Ctsc\"          \"Abcb4\"         \"Fyb\"           \"Alas2\"         #>  [53] \"Gpi1\"          \"Fech\"          \"Lsr\"           \"Psmd3\"         #>  [57] \"Gm2a\"          \"Pabpc1\"        \"Cbr4\"          \"Tkt\"           #>  [61] \"Tmem56\"        \"Eif3f\"         \"Cxadr\"         \"Srd5a1\"        #>  [65] \"Cyp2c55\"       \"Gnai2\"         \"Gimap6\"        \"Hsd3b2\"        #>  [69] \"Grn\"           \"Rpp14\"         \"Csnk1a1\"       \"Egr1\"          #>  [73] \"Mpeg1\"         \"Acsl4\"         \"Hmgb1\"         \"Mpp1\"          #>  [77] \"Lcp1\"          \"Plvap\"         \"Aldh1b1\"       \"Oxsm\"          #>  [81] \"Dlat\"          \"Csk\"           \"Mcat\"          \"Hsd17b7\"       #>  [85] \"Epas1\"         \"Eif3a\"         \"Nrp1\"          \"Dek\"           #>  [89] \"H2afy\"         \"Bpgm\"          \"Hsd3b6\"        \"Dnase1l3\"      #>  [93] \"Serpinh1\"      \"Tinagl1\"       \"Aldoc\"         \"Cyp2c38\"       #>  [97] \"Dpt\"           \"Mrc1\"          \"Minpp1\"        \"Fgf1\"          #> [101] \"Alcam\"         \"Gimap4\"        \"Cav2\"          \"Eng\"           #> [105] \"Adgre1\"        \"Shisa5\"        \"Csf1r\"         \"Esam\"          #> [109] \"Unc93b1\"       \"Cnp\"           \"Clec14a\"       \"Kdr\"           #> [113] \"Adpgk\"         \"Gca\"           \"Pkm\"           \"Mkrn1\"         #> [117] \"Sdc3\"          \"Acaca\"         \"Gpr182\"        \"Bmp2\"          #> [121] \"Tfrc\"          \"Timp3\"         \"Calcrl\"        \"Pfkl\"          #> [125] \"Wnt2\"          \"Cybb\"          \"Icam1\"         \"Cdh5\"          #> [129] \"Sgms2\"         \"Cd48\"          \"Stk17b\"        \"Tubb6\"         #> [133] \"Vcam1\"         \"Hgf\"           \"Ramp1\"         \"Arsb\"          #> [137] \"Pld4\"          \"Smarca4\"       \"Fstl1\"         \"Pfkm\"          #> [141] \"Lhfp\"          \"Lmna\"          \"Cd300lg\"       \"Laptm5\"        #> [145] \"Timp2\"         \"Slc25a37\"      \"Fzd7\"          \"Lyve1\"         #> [149] \"Acacb\"         \"Cyp1a1\"        \"Eno3\"          \"Cd83\"          #> [153] \"Epcam\"         \"Ltbp4\"         \"Pgm2\"          \"Mertk\"         #> [157] \"Pth1r\"         \"Itga2b\"        \"Kctd12\"        \"Srd5a3\"        #> [161] \"Bmp5\"          \"Pecam1\"        \"G6pc3\"         \"Cyp17a1\"       #> [165] \"Stab2\"         \"Cygb\"          \"Col1a2\"        \"Nid1\"          #> [169] \"Cd44\"          \"Ctnnal1\"       \"Ephb4\"         \"Elk3\"          #> [173] \"Foxq1\"         \"Cxcl14\"        \"Fzd4\"          \"Itgb2\"         #> [177] \"Tcf7\"          \"Srd5a2\"        \"Aldh3b1\"       \"Flt4\"          #> [181] \"Selp\"          \"Rbpj\"          \"Ep300\"         \"Rhoj\"          #> [185] \"Fzd1\"          \"Tcf7l2\"        \"Ssh2\"          \"Col6a1\"        #> [189] \"Notch2\"        \"Tcf4\"          \"Tek\"           \"Trim47\"        #> [193] \"Tent5c\"        \"Ncf1\"          \"Lepr\"          \"Pck2\"          #> [197] \"Lmnb1\"         \"Selplg\"        \"Myh10\"         \"Aldoart1\"      #> [201] \"Podxl\"         \"Kitl\"          \"Tcf3\"          \"Tspan13\"       #> [205] \"Dll4\"          \"Fzd8\"          \"Lad1\"          \"Procr\"         #> [209] \"Ccr2\"          \"Akr1c18\"       \"Maml1\"         \"Ms4a1\"         #> [213] \"Hk3\"           \"Bcam\"          \"Fzd5\"          \"Dkk3\"          #> [217] \"Bank1\"         \"Itgal\"         \"Pgam2\"         \"Axin2\"         #> [221] \"Pfkp\"          \"Meis2\"         \"Jag1\"          \"Gimap3\"        #> [225] \"Rassf4\"        \"Notch1\"        \"Cd93\"          \"Tet2\"          #> [229] \"Tcf7l1\"        \"Cd34\"          \"Hvcn1\"         \"Mal\"           #> [233] \"Itgb7\"         \"Wnt4\"          \"Kit\"           \"Gapdhs\"        #> [237] \"Kcnj16\"        \"Tnfrsf13c\"     \"Hk1\"           \"Pdgfra\"        #> [241] \"Apobec3\"       \"Slc34a2\"       \"Vav1\"          \"Lamp3\"         #> [245] \"Meis1\"         \"Lck\"           \"Efnb2\"         \"Notch4\"        #> [249] \"Klrb1c\"        \"Angpt2\"        \"Vwf\"           \"E2f2\"          #> [253] \"Ccr1\"          \"Angpt1\"        \"B4galt6\"       \"Cyp21a1\"       #> [257] \"Pdpn\"          \"Dll1\"          \"Ammecr1\"       \"Csf3r\"         #> [261] \"Ndn\"           \"Fgf2\"          \"Runx1\"         \"Mpl\"           #> [265] \"Mecom\"         \"Itgam\"         \"Hoxb4\"         \"Tox\"           #> [269] \"Prickle2\"      \"Acss1\"         \"Cyp2b9\"        \"Aldh3a1\"       #> [273] \"Bmp7\"          \"Gata2\"         \"Il7r\"          \"Satb1\"         #> [277] \"Sfrp1\"         \"Eno2\"          \"Mrvi1\"         \"Mki67\"         #> [281] \"Nes\"           \"Tmod1\"         \"Ace\"           \"Gfap\"          #> [285] \"Tgfb2\"         \"Tomt\"          \"Flt3\"          \"Sult2b1\"       #> [289] \"Hkdc1\"         \"Notch3\"        \"Cdh11\"         \"Il6\"           #> [293] \"Hk2\"           \"Mmrn1\"         \"Vangl2\"        \"Pou2af1\"       #> [297] \"Hoxb5\"         \"Jag2\"          \"Aldh3b2\"       \"Gypa\"          #> [301] \"Lrp2\"          \"Lef1\"          \"Olr1\"          \"Lox\"           #> [305] \"Txlnb\"         \"Slc12a1\"       \"Aldh3b3\"       \"Cxcr2\"         #> [309] \"Nkd2\"          \"Sult1e1\"       \"Acsl6\"         \"Ddx4\"          #> [313] \"Ldhc\"          \"Kcnj1\"         \"Acsbg1\"        \"Fzd3\"          #> [317] \"F13a1\"         \"Hsd11b2\"       \"Dkk2\"          \"Hsd17b1\"       #> [321] \"Fzd2\"          \"Cyp2b23\"       \"Eno4\"          \"Celsr2\"        #> [325] \"Obscn\"         \"Slamf1\"        \"Akap14\"        \"Gnaz\"          #> [329] \"Cd177\"         \"Tet1\"          \"Cspg4\"         \"Aldoart2\"      #> [333] \"Cyp2b19\"       \"Ryr2\"          \"Ldhal6b\"       \"Acsf3\"         #> [337] \"Chodl\"         \"Ivl\"           \"Cyp11b1\"       \"Sfrp2\"         #> [341] \"Dkk1\"          \"Cyp11a1\"       \"1700061G19Rik\" \"Acsbg2\"        #> [345] \"Olah\"          \"Pdha2\"         \"Hsd17b3\"       \"Blank-0\"       #> [349] \"Blank-1\"       \"Blank-2\"       \"Blank-3\"       \"Blank-4\"       #> [353] \"Blank-5\"       \"Blank-6\"       \"Blank-7\"       \"Blank-8\"       #> [357] \"Blank-9\"       \"Blank-10\"      \"Blank-11\"      \"Blank-12\"      #> [361] \"Blank-13\"      \"Blank-14\"      \"Blank-15\"      \"Blank-16\"      #> [365] \"Blank-17\"      \"Blank-18\"      \"Blank-19\"      \"Blank-20\"      #> [369] \"Blank-21\"      \"Blank-22\"      \"Blank-23\"      \"Blank-24\"      #> [373] \"Blank-25\"      \"Blank-26\"      \"Blank-27\"      \"Blank-28\"      #> [377] \"Blank-29\"      \"Blank-30\"      \"Blank-31\"      \"Blank-32\"      #> [381] \"Blank-33\"      \"Blank-34\"      \"Blank-35\"      \"Blank-36\"      #> [385] \"Blank-37\" n_panel <- 347 colData(sfe)$nCounts_normed <- sfe$nCounts / n_panel colData(sfe)$nGenes_normed <- sfe$nGenes / n_panel plotColDataHistogram(sfe, c(\"nCounts_normed\", \"nGenes_normed\")) plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"centroids\", scattermore = TRUE) plotSpatialFeature(sfe, \"volume\", colGeometryName = \"centroids\", scattermore = TRUE) plotColData(sfe, x=\"nCounts\", y=\"nGenes\", bins = 100) plotColData(sfe, x=\"volume\", y=\"nCounts\", bins = 100) plotColData(sfe, x=\"volume\", y=\"nGenes\", bins = 100)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"negative-controls","dir":"Articles","previous_headings":"Quality control","what":"Negative controls","title":"MERFISH mouse liver dataset and considerations of large data","text":"Blank probes used negative controls. Total transcript counts blank probes:  Number blank features detected per cell:  Percentage blank features per cell:  percentage interesting: within tissue, cells high percentage blank counts scattered like salt pepper, cells left edge tissue, edges FOVs, tissue doesnâ€™t end. Also plot histograms:  NAâ€™s cells without transcript detected. Unlike Xenium dataset, cells least one blank count. log transforming, zeroes removed plot.  small percentage blank counts acceptable. remove outlier based distribution percentage â€™s greater zero. blank percentage relate total counts?  outliers percentage blank counts low total counts. seemingly real cells sizable nCounts relatively high percentage blank counts. Since distribution percentage long tail, log transform finding outliers. proportion cells outliers? â€™s cutoff outlier? Remove outliers empty cells: still 390,000 cells left removing outliers.","code":"is_blank <- str_detect(rownames(sfe), \"^Blank-\") sfe <- addPerCellQCMetrics(sfe, subset = list(blank = is_blank)) names(colData(sfe)) #>  [1] \"fov\"                    \"volume\"                 \"min_x\"                  #>  [4] \"max_x\"                  \"min_y\"                  \"max_y\"                  #>  [7] \"sample_id\"              \"nCounts\"                \"nGenes\"                 #> [10] \"nCounts_normed\"         \"nGenes_normed\"          \"sum\"                    #> [13] \"detected\"               \"subsets_blank_sum\"      \"subsets_blank_detected\" #> [16] \"subsets_blank_percent\"  \"total\" plotSpatialFeature(sfe, \"subsets_blank_sum\", colGeometryName = \"centroids\",                    scattermore = TRUE) plotSpatialFeature(sfe, \"subsets_blank_detected\", colGeometryName = \"centroids\",                    scattermore = TRUE) plotSpatialFeature(sfe, \"subsets_blank_percent\", colGeometryName = \"centroids\",                    scattermore = TRUE) plotColDataHistogram(sfe, paste0(\"subsets_blank_\", c(\"sum\", \"detected\", \"percent\"))) #> Warning: Removed 1332 rows containing non-finite outside the scale range #> (`stat_bin()`). mean(sfe$subsets_blank_sum > 0) #> [1] 0.7648799 plotColDataHistogram(sfe, \"subsets_blank_percent\") +     scale_x_log10() +     annotation_logticks() #> Warning in scale_x_log10(): log-10 transformation introduced #> infinite values. #> Warning: Removed 92923 rows containing non-finite outside the scale range #> (`stat_bin()`). plotColData(sfe, x=\"nCounts\", y=\"subsets_blank_percent\", bins = 100) #> Warning: Removed 1332 rows containing non-finite outside the scale range #> (`stat_bin2d()`). get_neg_ctrl_outliers <- function(col, sfe, nmads = 3, log = FALSE) {     inds <- colData(sfe)$nCounts > 0 & colData(sfe)[[col]] > 0     df <- colData(sfe)[inds,]     outlier_inds <- isOutlier(df[[col]], type = \"higher\", nmads = nmads, log = log)     outliers <- rownames(df)[outlier_inds]     col2 <- str_remove(col, \"^subsets_\")     col2 <- str_remove(col2, \"_percent$\")     new_colname <- paste(\"is\", col2, \"outlier\", sep = \"_\")     colData(sfe)[[new_colname]] <- colnames(sfe) %in% outliers     sfe } sfe <- get_neg_ctrl_outliers(\"subsets_blank_percent\", sfe, log = TRUE) mean(sfe$is_blank_outlier) #> [1] 0.008944499 min(sfe$subsets_blank_percent[sfe$is_blank_outlier]) #> [1] 2.303523 (sfe <- sfe[, !sfe$is_blank_outlier & sfe$nCounts > 0]) #> class: SpatialFeatureExperiment  #> dim: 385 390348  #> metadata(0): #> assays(1): counts #> rownames(385): Comt Ldha ... Blank-36 Blank-37 #> rowData names(4): means vars cv2 subsets_blank #> colnames(390348): 10482024599960584593741782560798328923 #>   111551578131181081835796893618918348842 ... #>   92389687374928708938472537234969690424 #>   96399783859933548456002372694492036651 #> colData names(18): fov volume ... total is_blank_outlier #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : center_x center_y #> imgData names(1): sample_id #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT), cellSeg (POLYGON)  #>  #> Graphs: #> sample01:"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"genes","dir":"Articles","previous_headings":"Quality control","what":"Genes","title":"MERFISH mouse liver dataset and considerations of large data","text":"look mean variance gene:  genes display higher mean expression blanks, considerable overlap distribution, probably genes expressed lower levels fewer cells included. â€œrealâ€ genes negative controls plotted different colors:  red line y=xy = x expected data follows Poisson distribution.  zoomed , blanks somewhat overdispersed.","code":"rowData(sfe)$means <- rowMeans(counts(sfe)) rowData(sfe)$vars <- rowVars(counts(sfe)) rowData(sfe)$is_blank <- is_blank plotRowData(sfe, x = \"means\", y = \"is_blank\") +     scale_y_log10() +     annotation_logticks(sides = \"b\") plotRowData(sfe, x = \"means\", y = \"vars\", colour_by = \"is_blank\") +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal() as.data.frame(rowData(sfe)[is_blank,]) |>      ggplot(aes(means, vars)) +     geom_point() +     geom_abline(slope = 1, intercept = 0, color = \"red\") +     scale_x_log10() + scale_y_log10() +     annotation_logticks() +     coord_equal()"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"spatial-autocorrelation-of-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of QC metrics","title":"MERFISH mouse liver dataset and considerations of large data","text":", plot zoomed patch visually inspect cell-cell contiguity:  quite cells contiguous cell, cell segmentation imperfect, purely using poly2nb() problematic. next release, might implement way blend polygon contiguity graph graph case singletons. now, use k nearest neighbors k=5k = 5, seems like reasonable approximation contiguity based visual inspection. Voyager 1.2.0 (Bioconductor release), findSpatialNeighbors() default uses BiocNeighbors k nearest neighbors distance neighbors saving distances neighbors. bypasses time consuming step spdep calculating distance based edge weights, compute distance, hence greatly speeding computation. spatial neighborhood graph, can compute Moranâ€™s QC metrics. Unlike smFISH-based datasets website, nCounts nGenes sizable negative Moranâ€™s â€™s, closer 0 volume. interesting compare metrics across different tissues, add datasets SFEData future releases. Also check local Moranâ€™s , since little patch examined , regions may positive spatial autocorrelation.  niches around smaller blood vessels positive local Moranâ€™s nCounts nGenes. likely due homogeneous endothelial cells compared hepatocytes.","code":"plotGeometry(sfe, colGeometryName = \"cellSeg\", bbox = bbox_use) system.time(     colGraph(sfe, \"knn5\") <- findSpatialNeighbors(sfe, method = \"knearneigh\",                                                    dist_type = \"idw\", k = 5,                                                    style = \"W\") ) #>    user  system elapsed  #>  28.852   0.000  28.853 sfe <- colDataMoransI(sfe, c(\"nCounts\", \"nGenes\", \"volume\"),                        colGraphName = \"knn5\") colFeatureData(sfe)[c(\"nCounts\", \"nGenes\", \"volume\"),] #> DataFrame with 3 rows and 2 columns #>         moran_sample01 K_sample01 #>              <numeric>  <numeric> #> nCounts     -0.1084532    4.22513 #> nGenes      -0.0922130    2.25923 #> volume      -0.0195237    3.89406 sfe <- colDataUnivariate(sfe, type = \"localmoran\",                           features = c(\"nCounts\", \"nGenes\", \"volume\"),                          colGraphName = \"knn5\") plotLocalResult(sfe, \"localmoran\", c(\"nCounts\", \"nGenes\", \"volume\"),                 colGeometryName = \"centroids\", scattermore = TRUE,                 ncol = 2, divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"morans-i","dir":"Articles","previous_headings":"","what":"Moranâ€™s I","title":"MERFISH mouse liver dataset and considerations of large data","text":"â€™s actually slow thought almost 400,000 cells. Moranâ€™s â€™s distributed real genes blank probes?  blanks clustered tightly around 0. vast majority real genes positive spatial autocorrelation, quite strong. genes negative spatial autocorrelation, although may may statistically significant. Plot top genes positive spatial autocorrelation:  Unlike smFISH-based cancer datasets dataset, genes highest Moranâ€™s highlight different histological regions. probably zones hepatic lobule, blood vessels. interesting compare spatial autocorrelation marker genes among different tissues cell types. Negative Moranâ€™s means nearby cells tend dissimilar . hard see plotting whole tissue section, use bounding box . gene negative Moranâ€™s compared one Moranâ€™s closest 0.  expected, feature Moranâ€™s closest 0 blank.","code":"sfe <- logNormCounts(sfe) system.time(     sfe <- runMoransI(sfe, BPPARAM = MulticoreParam(2)) ) #>    user  system elapsed  #>  47.944   2.028  51.689 plotRowData(sfe, x = \"moran_sample01\", y = \"is_blank\") +     geom_hline(yintercept = 0, linetype = 2) top_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01, decreasing = TRUE)[1:6]] plotSpatialFeature(sfe, top_moran, colGeometryName = \"centroids\", scattermore = TRUE,                    ncol = 2) bottom_moran <- rownames(sfe)[order(rowData(sfe)$moran_sample01)[1]] bottom_abs_moran <- rownames(sfe)[order(abs(rowData(sfe)$moran_sample01))[1]] plotSpatialFeature(sfe, c(bottom_moran, bottom_abs_moran),                     colGeometryName = \"cellSeg\", bbox = bbox_use)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"spatial-autocorrelation-at-larger-length-scales","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation at larger length scales","title":"MERFISH mouse liver dataset and considerations of large data","text":"k nearest neighbor graph used concerns 5 cells around cell, small neighborhood, small length scale. current release Voyager, correlogram can computed get sense length scale spatial autocorrelation. However, since finding lag values higher higher orders neighborhoods slow large number cells higher orders, correlogram helpful . section, use methods involving binning explore spatial autocorrelation larger length scales.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"binning","dir":"Articles","previous_headings":"Spatial autocorrelation at larger length scales","what":"Binning","title":"MERFISH mouse liver dataset and considerations of large data","text":"sf package can create polygons grid, can bin cells attributes gene expressions. make 100 100 hexagonal grid bounding box cell centroids. use grid bin QC metrics averaging values cells. Since bins completely covered tissue fewer cells, mean may less susceptible edge effect sum, bins near edge lower sums, may spuriously increase Moranâ€™s . Plot binned values:  â€™s outlier bin evident plotting single cells. â€™s still edge effect around blood vessels. might truly edge effect, endothelial cells tend lower values 3 variables . compute Moranâ€™s binned data, contiguity neighborhoods. zero.policy = TRUE bins neighbors. larger length scale, Moranâ€™s becomes positive. Comparing Moranâ€™s across different sized bins can give sense length scale spatial autocorrelation. However, problems binning watch : Edge effect, especially using sum binning function use aggregate values binning using rectangular grid, whether use rook queen neighbors. Rook means two cells neighbors share edge, queen means neighbors even merely share vertex. binning can greatly speed computation spatial autocorrelation metrics larger datasets, can used smaller datasets find length scales spatial autocorrelation. hand, seen , Moranâ€™s can flip signs different length scales, larger datasets, exploring spatial autocorrelation cell level still interesting.","code":"(bins <- st_make_grid(colGeometry(sfe, \"centroids\"), n = 100, square = FALSE)) #> Geometry set for 11165 features  #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -137.2225 ymin: -158.8407 xmax: 10396.09 ymax: 9708.547 #> CRS:           NA #> First 5 geometries: #> POLYGON ((-85.58866 -69.40817, -137.2225 -39.59... #> POLYGON ((-85.58866 109.4569, -137.2225 139.267... #> POLYGON ((-85.58866 288.3219, -137.2225 318.132... #> POLYGON ((-85.58866 467.1869, -137.2225 496.997... #> POLYGON ((-85.58866 646.052, -137.2225 675.8628... df <- cbind(colGeometry(sfe, \"centroids\"), colData(sfe)[,c(\"nCounts\", \"nGenes\", \"volume\")]) df_binned <- aggregate(df, bins, FUN = mean) # Remove bins not containing cells df_binned <- df_binned[!is.na(df_binned$nCounts),] # Not using facet_wrap to give each panel its own color scale plts <- lapply(c(\"nCounts\", \"nGenes\", \"volume\"), function(f) {     ggplot(df_binned[,f]) + geom_sf(aes(fill = .data[[f]]), linewidth = 0) +         scale_fill_distiller(palette = \"Blues\", direction = 1) + theme_void() }) wrap_plots(plts, nrow = 2) nb <- poly2nb(df_binned) #> Warning in poly2nb(df_binned): some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning in poly2nb(df_binned): neighbour object has 7 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. listw <- nb2listw(nb, zero.policy = TRUE) calculateMoransI(t(as.matrix(st_drop_geometry(df_binned[,c(\"nCounts\", \"nGenes\", \"volume\")]))),                  listw = listw, zero.policy = TRUE) #> DataFrame with 3 rows and 2 columns #>             moran         K #>         <numeric> <numeric> #> nCounts  0.490837   5.21703 #> nGenes   0.422267  16.10323 #> volume   0.352221   4.78100"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"semivariogram","dir":"Articles","previous_headings":"Spatial autocorrelation at larger length scales","what":"Semivariogram","title":"MERFISH mouse liver dataset and considerations of large data","text":"geostatistical data, underlying spatial process sampled known locations. Kriging uses Gaussian process interpolate values sample locations, semivariogram used model spatial dependency locations covariance Gaussian process. kriging, semivariogram can used exploratory data analysis tool find length scale anisotropy spatial autocorrelation. One classic R packages geostatistical tradition gstat, use find semivariograms, defined Î³(t)=12Var(Xtâˆ’X0), \\gamma(t) = \\frac 1 2 \\mathrm{Var}(X_t - X_0), XX value gene expression, tt spatial vector. X0X_0 value location interest, XtX_t value lagged tt. positive spatial autocorrelation, variance smaller among nearby values, variogram increase distance, eventually leveling distance beyond length scale spatial autocorrelation. â€œsemiâ€ comes 1/2. variogram Voyager v1.2.0 higher (Bioconductor release later) can computed runUnivariate() function. See vignette variograms variogram maps. First find empirical variogram assuming â€™s directions. data binned distance intervals, much faster correlogram cell level. width argument controlls bin size. cutoff argument maximum distance consider. use defaults. first argument formula; covariates can specified, done . different widths cutoffs, variogram can estimated different length scales. gstat package can also fit model empirical variogram. See vgm() different types models. automap package can choose model user, used Voyager. Unfortunately, gstat doesnâ€™t scale 400,000 cells, although worked 100,000 cells smFISH-based datasets website. since variogram used explore larger length scales anyway, use binned data , problems binning apply.  numbers plot number pairs distance bin. variogram 0 0 distance; variance within bin size, called nugget. variogram levels greater distance, value variogram levels sill. Range variogram leveling , indicating length scale spatial autocorrelation; range visual inspection appears closer 1000 model somehow indicates 423. variogram map can made see spatial autocorrelation may differ different directions, .e.Â anisotropy  apparently â€™s anisotropy shorter length scales, may artifact hexagonal bins. Going beyond 2000 (whatever unit), variance drops northwest southeast direction directions, perhaps related repetitiveness hepatic lobules general NE/SW direction blood vessels seen previous plots. variogram can also calculated specified angles, selected sides hexagon:  variogram rises going beyond 2000 30 90 degrees drops 150 degrees. consistent variogram map. differences averaged omni-directional variogram. gstat fit anisotropy parameters, fitted curve omni-directional. fits pretty well 2000. nCounts, may differ QC metrics genes. anisotropy varies space? problem variogram â€™s global, giving one result entire dataset, albeit nuanced just number Moranâ€™s , kriging assumes data intrinsically stationary, meaning variogram model applies everywhere, spatial dependence depends lag two observations. Voyager 1.2.0 implements ggplot2 based plotting functions make better looking customizable plots variograms SFE objects. However, binned data SFE object. considering writing method spatially bin cell level data SFE object Bioconductor 3.18. gstat using lattice, predecessor ggplot2 make facetted plots superseded ggplot2. gstat one oldest R packages still CRAN, dating back days S (prequel R), although oldest archive CRAN 2003. spdep also really old; oldest archive CRAN 2002, â€™s still active development. using time honored packages methods (Moranâ€™s Gearyâ€™s C date back 1950s modern form date back 1969 (Cliff1969-wp?; Bivand2013-jx?)) cool new spatial transcriptomics dataset, participating glorious tradition, develop spatial analysis tradition forms around spatial -omics data analysis.","code":"# as_Spatial since automap uses old fashioned sp, the predecessor of sf v <- autofitVariogram(nCounts ~ 1, as_Spatial(df_binned)) plot(v) v2 <- variogram(nCounts ~ 1, data = df_binned, width = 300, cutoff = 4500, map = TRUE) plot(v2) v3 <- variogram(nCounts ~ 1, df_binned, alpha = c(30, 90, 150)) v3_model <- fit.variogram(v3, vgm(\"Ste\")) plot(v3, v3_model)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"pca-for-larger-datasets","dir":"Articles","previous_headings":"","what":"PCA for larger datasets","title":"MERFISH mouse liver dataset and considerations of large data","text":"many ways PCA R, BiocSingular package makes number different methods available consistent user interface, supports memory data DelayedArray. According benchmark, stats::prcomp() shipped R rather slow larger datasets. fastest methods irlba::irlba() RSpectra::svds(), former supported BiocSingular. use IRLBA see long takes. Many PCA algorithms involve repeated matrix multiplications. R come optimized BLAS LAPACK, portability reasons. However, BLAS LAPACK used R can changed optimized one (â€™s ), speed matrix multiplication. â€™s pretty quick almost 400,000 cells, arenâ€™t many genes . Use elbow plot see variance explained PC:  Plot top gene loadings PC  Many genes seem related endothelium. Plot first 4 PCs space  PC1 PC4 highlight major blood vessels, PC2 PC3 less spatial structure. CosMX Xenium datasets website, top PCs clear spatial structures despite absence spatial information non-spatial PCA clear spatial compartments cell types, seem case dataset except blood vessels. seen genes strong spatial structures. methods spatially informed PCA, MULTISPATI PCA (Dray2008-en?) adespatial package, seeks maximize variance (non-spatial PCA) Moranâ€™s PC. Unlike traditional PCs, eigenvalues, signifying variance explained, positive, MULTISPATI PCA can negative eigenvalues, signify negative spatial autocorrelation. PCs MULTISPATI PCA positive eigenvalues also spatially coherent non-spatial PCA. CosMX Xenium datasets website, spatial coherence MULTISPATI might make difference, might make difference dataset non-spatial PCs donâ€™t show much spatial structure, least larger scale entire tissue section. Voyager 1.2.0 (Bioconductor release) faster implementation MULTISPATI PCA adespatial, demonstrated dataset another vignette. PC2 PC3 donâ€™t seem large scale spatial structure, may local spatial structure obvious plotting entire section, zoom bounding box:  â€™s spatial structure PC2 PC3 smaller scale, perhaps negative spatial autocorrelation. Like global Moranâ€™s , PCA MULTISPATI PCA return one result entire dataset. contrast, geographically weighted PCA (GWPCA) (Harris2015-sr?) can account spatial heterogeneity. GWPCA runs PCA spatial location using nearby locations weighed kernel. different locations can different PCs, results can visualized â€œwinning variablesâ€ PC, .e.Â plotting feature highest loading PC space. likely doesnâ€™t scale 400,000 cells, still interesting performed spatially binned data. GWPCA might added Bioconductor 3.18 require changes user interface, GWPCA features rather cell embeddings.","code":"set.seed(29) system.time(     sfe <- runPCA(sfe, ncomponents = 20, subset_row = !is_blank,                   exprs_values = \"logcounts\",                   scale = TRUE, BSPARAM = IrlbaParam()) ) #>    user  system elapsed  #>  10.413   5.368   9.031 gc() #>             used (Mb) gc trigger   (Mb)  max used   (Mb) #> Ncells  17112884  914   27226276 1454.1  27226276 1454.1 #> Vcells 253089555 1931  494258960 3770.9 494205783 3770.5 ElbowPlot(sfe) plotDimLoadings(sfe) spatialReducedDim(sfe, \"PCA\", 4, colGeometryName = \"centroids\", scattermore = TRUE,                   divergent = TRUE, diverge_center = 0) spatialReducedDim(sfe, \"PCA\", ncomponents = 2:3, colGeometryName = \"cellSeg\",                   bbox = bbox_use, divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"more-challenges-from-large-datasets","dir":"Articles","previous_headings":"","what":"More challenges from large datasets","title":"MERFISH mouse liver dataset and considerations of large data","text":", despite numerous cells, data loaded memory. data doesnâ€™t fit memory? might write new vignette DelayedArray demonstrating memory data analysis Bioconductor 3.18. already supported SingleCellExperiment, SFE inherits . However, geometries, graphs, local results can take lot memory well. can possibly stored SQL databases operated SQLDataFrame. geometric operations can handled sedona, although options limited compared GEOS, performs geometric operations behind scene sf. Another question can raised large spatial transcriptomics data: still good idea analyze entire dataset ? must many interesting unique neighborhoods might get attention deserve whole dataset analyzed . , geographical space, national level data usually analyzed block resolution, although reason privacy subjects. County resolution often used, arenâ€™t hundreds thousands counties. Many analyses done cities counties neighborhood resolution; using largest geographical unit isnâ€™t always relevant. Back histological space: aggregate cells larger spatial units? decide scale spatial units (analogous nation vs state vs county etc) relevant? traditional anatomical ontologies, Allen Brain Atlas, isnâ€™t available tissues. Also, single cell -omics data, traditional ontologies can improved. Furthermore, 3D thick section single cell resolution spatial transcriptomics data, STARmap (Wang2018-cv?) EASI-FISH (Wang2021-fv?), although vast majority spatial -omics data thin sections pretty much de facto 2D. mostly live surface Earth, many 2D geospatial resources 3D. However, methods can principle applied 3D existing software primarily made 2D data might work. example, GEOS supports 3D data, principle 3D geometries sf work, although â€™s little documentation . Also, k nearest neighbor, Moranâ€™s , variograms, etc. principle work 3D, gstat officially supports 3D. challenges related 3D data: Even multiple z-planes imaged, resolution much lower z direction x y directions. z-plane treated attribute coordinate? make static plots 3D data publications? complicated plotting z-planes separately, since 3D block can sectioned direction. Also interactive visualization, need somehow see tissue. Finally, geospatial tradition one tradition relevant large spatial data, present Voyager works vector data. uncertain whether raster added later version, existing tools large raster data well, TileDB. traditions can relevant, astronomy image processing, beyond scope package.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/vig6_merfish.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"MERFISH mouse liver dataset and considerations of large data","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] automap_1.1-12                 BiocNeighbors_2.0.0            #>  [3] gstat_2.1-2                    BiocSingular_1.22.0            #>  [5] BiocParallel_1.40.0            spdep_1.3-6                    #>  [7] sf_1.0-19                      spData_2.3.3                   #>  [9] stringr_1.5.1                  patchwork_1.3.0                #> [11] scater_1.34.0                  ggplot2_3.5.1                  #> [13] scuttle_1.16.0                 SpatialExperiment_1.16.0       #> [15] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [17] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [19] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [21] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [23] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [25] SFEData_1.8.0                  Voyager_1.8.1                  #> [27] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               xts_0.14.1                #>   [7] lifecycle_1.0.4           edgeR_4.4.0               #>   [9] lattice_0.22-6            MASS_7.3-61               #>  [11] magrittr_2.0.3            limma_3.62.1              #>  [13] sass_0.4.9                rmarkdown_2.29            #>  [15] jquerylib_0.1.4           yaml_2.3.10               #>  [17] sp_2.1-4                  cowplot_1.1.3             #>  [19] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] purrr_1.0.2               R.utils_2.12.3            #>  [27] RCurl_1.98-1.16           TH.data_1.1-2             #>  [29] rappdirs_0.3.3            sandwich_3.1-1            #>  [31] GenomeInfoDbData_1.2.13   ggrepel_0.9.6             #>  [33] irlba_2.3.5.1             terra_1.7-83              #>  [35] units_0.8-5               RSpectra_0.16-2           #>  [37] dqrng_0.4.1               pkgdown_2.1.1             #>  [39] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [41] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [43] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [45] memuse_4.2-3              farver_2.1.2              #>  [47] viridis_0.6.5             ScaledMatrix_1.14.0       #>  [49] BiocFileCache_2.14.0      jsonlite_1.8.9            #>  [51] e1071_1.7-16              survival_3.7-0            #>  [53] systemfonts_1.1.0         tools_4.4.2               #>  [55] ggnewscale_0.5.0          ragg_1.3.3                #>  [57] Rcpp_1.0.13-1             glue_1.8.0                #>  [59] gridExtra_2.3             SparseArray_1.6.0         #>  [61] xfun_0.49                 EBImage_4.48.0            #>  [63] dplyr_1.1.4               HDF5Array_1.34.0          #>  [65] withr_3.0.2               BiocManager_1.30.25       #>  [67] fastmap_1.2.0             boot_1.3-31               #>  [69] rhdf5filters_1.18.0       bluster_1.16.0            #>  [71] fansi_1.0.6               digest_0.6.37             #>  [73] rsvd_1.0.5                mime_0.12                 #>  [75] R6_2.5.1                  textshaping_0.4.0         #>  [77] colorspace_2.1-1          wk_0.9.4                  #>  [79] scattermore_1.2           LearnBayes_2.15.1         #>  [81] jpeg_0.1-10               RSQLite_2.3.8             #>  [83] R.methodsS3_1.8.2         hexbin_1.28.5             #>  [85] intervals_0.15.5          utf8_1.2.4                #>  [87] generics_0.1.3            data.table_1.16.2         #>  [89] FNN_1.1.4.1               class_7.3-22              #>  [91] httr_1.4.7                htmlwidgets_1.6.4         #>  [93] S4Arrays_1.6.0            pkgconfig_2.0.3           #>  [95] scico_1.5.0               gtable_0.3.6              #>  [97] blob_1.2.4                XVector_0.46.0            #>  [99] htmltools_0.5.8.1         fftwtools_0.9-11          #> [101] scales_1.3.0              png_0.1-8                 #> [103] knitr_1.49                rjson_0.2.23              #> [105] spacetime_1.3-2           coda_0.19-4.1             #> [107] nlme_3.1-166              curl_6.0.1                #> [109] proxy_0.4-27              cachem_1.1.0              #> [111] zoo_1.8-12                rhdf5_2.50.0              #> [113] BiocVersion_3.20.0        KernSmooth_2.23-24        #> [115] vipor_0.4.7               parallel_4.4.2            #> [117] AnnotationDbi_1.68.0      desc_1.4.3                #> [119] s2_1.1.7                  reshape_0.8.9             #> [121] pillar_1.9.0              grid_4.4.2                #> [123] vctrs_0.6.5               dbplyr_2.5.0              #> [125] beachmat_2.22.0           sfheaders_0.4.4           #> [127] cluster_2.1.6             beeswarm_0.4.0            #> [129] evaluate_1.0.1            zeallot_0.1.0             #> [131] magick_2.8.5              mvtnorm_1.3-2             #> [133] cli_3.6.3                 locfit_1.5-9.10           #> [135] compiler_4.4.2            rlang_1.1.4               #> [137] crayon_1.5.3              labeling_0.4.3            #> [139] classInt_0.4-10           plyr_1.8.9                #> [141] ggbeeswarm_0.7.2          fs_1.6.5                  #> [143] stringi_1.8.4             stars_0.6-7               #> [145] viridisLite_0.4.2         deldir_2.0-4              #> [147] munsell_0.5.1             Biostrings_2.74.0         #> [149] tiff_0.1-12               Matrix_1.7-1              #> [151] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [153] bit64_4.5.2               Rhdf5lib_1.28.0           #> [155] KEGGREST_1.46.0           statmod_1.5.0             #> [157] AnnotationHub_3.14.0      igraph_2.1.1              #> [159] memoise_2.0.1             bslib_0.8.0               #> [161] bit_4.5.0"},{"path":[]},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"seqFISH exploratory data analysis","text":"data used vignette described Integration spatial single-cell transcriptomic data elucidates mouse organogenesis. Briefly, seqFISH use profile 351 genes several mouse embryos 8-12 somite stage (ss). focus single biological replicate, embryo 3. raw processed counts corresponding metadata available download Marioni lab. Expression matrices, segmentation data, segmented cell vertices provided R objects can readily imported R environment. data relevant vignette converted SFE object available download Box. data added SFEData package Bioconductor available release release. begin downloading data loading R. rows count matrix correspond 351 barcoded genes measured seqFISH. Additionally, authors provide metadata, including field view z-slice cell. filter count matrix metadata include cells single z-slice.","code":"library(Voyager) library(SFEData) library(SingleCellExperiment) library(SpatialExperiment) library(SpatialFeatureExperiment) library(batchelor) library(scater) library(scran) library(bluster) library(purrr) library(tidyr) library(dplyr) library(fossil) library(ggplot2) library(patchwork) library(spdep) library(BiocParallel)  theme_set(theme_bw()) # Only Bioc release and above sfe <- LohoffGastrulationData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache names(colData(sfe)) #>  [1] \"uniqueID\"                \"embryo\"                  #>  [3] \"pos\"                     \"z\"                       #>  [5] \"x_global\"                \"y_global\"                #>  [7] \"x_global_affine\"         \"y_global_affine\"         #>  [9] \"embryo_pos\"              \"embryo_pos_z\"            #> [11] \"Area\"                    \"UMAP1\"                   #> [13] \"UMAP2\"                   \"celltype_mapped_refined\" #> [15] \"sample_id\" mask <- colData(sfe)$z == 2 sfe <- sfe[,mask]"},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"quality-control","dir":"Articles","previous_headings":"","what":"Quality control","title":"seqFISH exploratory data analysis","text":"begin quality control (QC) cells computing metrics common single-cell analysis store colData field SFE object. , compute number counts per cell. also compute average display violin plot.  Notably, cells dataset fewer counts expected single-cell sequencing experiment cells higher counts seem dispersed throughout tissue. Fewer counts expected seqFISH experiments probing highly expressed genes may lead optical crowding multiple imaging rounds. Since counts collected several fields view, visualize number cells total counts field separately.  variability total number counts field view. completely apparent accounts low number counts FOVs. example, FOV 22 fewest number cells, comparably counts detected regions cells (e.g.Â FOV 18). Next, compute number genes detected per cell, defined number genes non-zero counts. plot metric FOV done .  Many cells fewer 100 detected genes. part reflects panel 351 probed genes chosen distinguish cell types developmental stages distinct cell types likely express small subset 351 genes. authors also note gene panel consists lowly expressed moderately expressed genes. Taken together, technical details can explain relatively low number counts genes per cell. , plot number genes detected per cell FOV.  plot mirrors plot total counts. single FOV stands obvious outlier. authors provided cell type assignments metadata. can assess whether low quality cells tend located particular FOV. appears FOV 26 31 largest fraction low quality cells. Interestingly, correspond FOVs largest number cells overall. plot nCounts vs.Â nGenes FOV.  scRNA-seq, gene expression variance seqFISH measurements overdispersed compared variance counts Poisson distributed. understand mean-variance relationship, compute mean variance gene among cells tissue. , perform calculation separately FOV  red line represents line y=xy = x, mean-variance relationship expected Poisson distributed data. data deviate expectation FOV. case, variance greater expected.","code":"colData(sfe)$nCounts <- colSums(counts(sfe)) avg <- mean(colData(sfe)$nCounts)  violin <- plotColData(sfe, \"nCounts\") +     geom_hline(yintercept = avg, color='red') +     theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"seg_coords\")  violin + spatial pos <- colData(sfe)$pos counts_spl <- split.data.frame(t(counts(sfe)), pos)  # nCounts per FOV df <- map_dfr(counts_spl, rowSums, .id='pos') |>     pivot_longer(cols=contains('embryo'), values_to = 'nCounts') |>     mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |>      dplyr::filter(!is.na(nCounts))  cells_fov <- colData(sfe) |>      as.data.frame() |>      mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |>      ggplot(aes(pos,)) +     geom_bar() +      theme_minimal() +      labs(         x = \"\",         y = \"Number of cells\") +      theme(axis.text.x = element_text(angle = 90))  counts_fov <- ggplot(df, aes(pos, nCounts)) +     geom_boxplot(outlier.size = 0.5) +      theme_minimal() +      labs(x = \"\", y = 'nCounts') +      theme(axis.text.x = element_text(angle = 90))  cells_fov / counts_fov colData(sfe)$nGenes <- colSums(counts(sfe) > 0)  avg <- mean(colData(sfe)$nGenes)  violin <- plotColData(sfe, \"nGenes\") +     geom_hline(yintercept = avg, color='red') +     theme(legend.position = \"top\")   spatial <- plotSpatialFeature(sfe, \"nGenes\", colGeometryName = \"seg_coords\")  violin + spatial df <- map_dfr(counts_spl, ~ rowSums(.x > 0), .id='pos') |>     pivot_longer(cols = contains('embryo'), values_to = 'nGenes') |>     mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1))) |>      filter(!is.na(nGenes)) |>     merge(df)  genes_fov <- ggplot(df, aes(pos, nGenes)) +     geom_boxplot(outlier.size = 0.5) +      theme_bw() +      labs(x = \"\") +      theme(axis.text.x = element_text(angle = 90))  genes_fov meta <- data.frame(colData(sfe))   meta <- meta |>      group_by(pos) |>      add_tally(name = \"nCells_FOV\") |>      filter(celltype_mapped_refined %in% \"Low quality\") |>      add_tally(name = \"nLQ_FOV\") |>      mutate(prop_lq = nLQ_FOV/nCells_FOV) |>     distinct(pos, prop_lq) |>      ungroup() |>      mutate(pos = factor(pos, levels = paste0(\"Pos\", seq_len(length(unique(pos)))-1)))  prop_lq <- ggplot(meta, aes(pos, prop_lq)) +      geom_bar(stat = 'identity' ) +      theme(axis.text.x = element_text(angle = 90))   prop_lq count_vs_genes_p <- ggplot(df, aes(nCounts, nGenes)) +    geom_point(     alpha = 0.5,     size = 1,     fill = \"white\"   ) +   facet_wrap(~ pos)  count_vs_genes_p gene_meta <- map_dfr(counts_spl, colMeans, .id = 'pos') |>    pivot_longer(cols = -pos, names_to = 'gene', values_to = 'mean')  gene_meta <- map_dfr(counts_spl, ~colVars(.x, useNames = TRUE), .id = 'pos') |>    pivot_longer(-pos, names_to = 'gene', values_to='variance') |>    full_join(gene_meta) #> Joining with `by = join_by(pos, gene)` ggplot(gene_meta, aes(mean, variance)) +    geom_point(     alpha = 0.5,     size = 1,     fill = \"white\"   ) +   facet_wrap(~ pos) +   geom_abline(slope = 1, intercept = 0, color = \"red\") +   scale_x_log10() + scale_y_log10() +   annotation_logticks()"},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"data-normalization-and-dimension-reduction","dir":"Articles","previous_headings":"","what":"Data normalization and dimension reduction","title":"seqFISH exploratory data analysis","text":"exploratory analysis indicates presence batch effects corresponding FOV. use normalization scheme batch aware. SFE object inherits SpatialExperimentand SingleCellExperiment, classes, can take advantage normalization methods implemented scran batchelor R packages. first use multiBatchNorm() function scale data within batch. noted documentation, function uses median-based normalization ratio average counts batches. Batch correction dimension reduction accomplished using fastMNN() performs multi-sample PCA across multiple gene expression matrices project cells common low-dimensional space. function fastMNN returns batch-corrected matrix reducedDims slot SingleCellExperiment object. extract relevant data store SFE ojbject. Now visualize first two PCs space. notice PCs may show spatial structure correlates biological niches cells.  Unfortunately, FOV artifacts can still seen.","code":"sfe <- multiBatchNorm(sfe, batch = pos) sfe_red <- fastMNN(sfe, batch = pos, cos.norm = FALSE, d = 20) reducedDim(sfe, \"PCA\") <- reducedDim(sfe_red, \"corrected\") assay(sfe, \"reconstructed\") <- assay(sfe_red, \"reconstructed\") spatialReducedDim(sfe, \"PCA\", ncomponents = 2, divergent = TRUE, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"clustering","dir":"Articles","previous_headings":"","what":"Clustering","title":"seqFISH exploratory data analysis","text":"Much like single cell analysis, can use batch-corrected data cluster cells. implement graph-based clustering algorithm plot resulting clusters space. plot colored cluster ID cell types provided author.  authors assigned cells types identified clustering step. case, clustering results seem recapitulate major cell niches previous annotations. can compute Rand index using function fossil package assess similarity two clustering results. value 1 suggest clustering results identical, value 0 suggest results agree . relatively large Rand index suggests cells often found cluster cases.","code":"colData(sfe)$cluster <-    clusterRows(reducedDim(sfe, \"PCA\"),                       BLUSPARAM = SNNGraphParam(                         cluster.fun = \"leiden\",                         cluster.args = list(                         resolution_parameter = 0.5,                         objective_function = \"modularity\")                         )               ) plotSpatialFeature(sfe, c(\"cluster\", \"celltype_mapped_refined\"),                     colGeometryName = \"seg_coords\") g1 <- as.numeric(colData(sfe)$cluster) g2 <- as.numeric(colData(sfe)$celltype_mapped_refined)  rand.index(g1, g2) #> [1] 0.8467703"},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"univariate-spatial-statistics","dir":"Articles","previous_headings":"","what":"Univariate Spatial Statistics","title":"seqFISH exploratory data analysis","text":"point, may interested identifying genes exhibit spatial variability, whose expression depends spatial location within tissue. Measures spatial autocorrelation can useful identifyign genes display spatial variablity. Among common measures Moranâ€™s Gearyâ€™s C. latter case, less 1 indicates positive spatial autocorrelation, value larger 1 points negative spatial autocorrelation. former case, positive negative values Moranâ€™s indicate positive negative spatial autocorrelation, respectively. tests require spatial neighborhood graph computation statistic. several ways define spatial neighbors findSpatialNeighbors() function wraps methods implemented spdep package. , compute k-nearest neighborhood graph. dist_type = \"idw\" weights edges graph inverse distance neighbors. also save variable genes use computations . use runUnivariate() function compute spatial autocorrelation metrics save results save SFE object. mc type test implements permutation test statistic relies nsim argument computing p-value statistic. can plot results Monte Carlo simulations:  vertical line represents observed value Moranâ€™s density represents Moranâ€™s computed permuted data. simulations suggest spatial autocorrelation feature significant. function can also used plot geary.mc results. Now, might ask: genes display spatial autocorrelation?  appears genes highest spatial autocorrelation seem obvious expression patterns tissue. interesting see genes also differentially expressed clusters . Non-spatial differential gene expression can interrogated using findMarkers() function implemented scran package complex methods identifying spatially variable genes actively developed. analyses bring interesting considerations. one, unclear whether normalization scheme employed effectively removes FOV batch effects. said, may times FOV differences expected represent biological differences, example context tumor sample. remains seen normalization methods perform best cases, represents area research.","code":"colGraph(sfe, \"knn5\") <- findSpatialNeighbors(   sfe, method = \"knearneigh\", dist_type = \"idw\",    k = 5, style = \"W\") dec <- modelGeneVar(sfe) hvgs <- getTopHVGs(dec, n = 100) sfe <- runUnivariate(   sfe, type = \"geary.mc\", features = hvgs,    colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2)) sfe <- runUnivariate(   sfe, type = \"moran.mc\", features = hvgs,   colGraphName = \"knn5\", nsim = 100, BPPARAM = MulticoreParam(2))  sfe <- colDataUnivariate(   sfe, type = \"moran.mc\", features = c(\"nCounts\", \"nGenes\"),    colGraphName = \"knn5\", nsim = 100) plotMoranMC(sfe, \"Meox1\") top_moran <- rownames(sfe)[order(-rowData(sfe)$moran.mc_statistic_sample01)[1:4]]  plotSpatialFeature(sfe, top_moran, colGeometryName = \"seg_coords\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig7_seqfish.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"seqFISH exploratory data analysis","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] BiocParallel_1.40.0            spdep_1.3-6                    #>  [3] sf_1.0-19                      spData_2.3.3                   #>  [5] patchwork_1.3.0                fossil_0.4.0                   #>  [7] shapefiles_0.7.2               foreign_0.8-87                 #>  [9] maps_3.4.2.1                   sp_2.1-4                       #> [11] dplyr_1.1.4                    tidyr_1.3.1                    #> [13] purrr_1.0.2                    bluster_1.16.0                 #> [15] scran_1.34.0                   scater_1.34.0                  #> [17] ggplot2_3.5.1                  scuttle_1.16.0                 #> [19] batchelor_1.22.0               SpatialExperiment_1.16.0       #> [21] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [23] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [25] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [27] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [29] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [31] SFEData_1.8.0                  Voyager_1.8.1                  #> [33] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] filelock_1.0.3            tibble_3.2.1              #>   [5] R.oo_1.27.0               lifecycle_1.0.4           #>   [7] edgeR_4.4.0               lattice_0.22-6            #>   [9] MASS_7.3-61               magrittr_2.0.3            #>  [11] limma_3.62.1              sass_0.4.9                #>  [13] rmarkdown_2.29            jquerylib_0.1.4           #>  [15] yaml_2.3.10               metapod_1.14.0            #>  [17] RColorBrewer_1.1-3        cowplot_1.1.3             #>  [19] DBI_1.2.3                 ResidualMatrix_1.16.0     #>  [21] multcomp_1.4-26           abind_1.4-8               #>  [23] spatialreg_1.3-5          zlibbioc_1.52.0           #>  [25] R.utils_2.12.3            RCurl_1.98-1.16           #>  [27] TH.data_1.1-2             rappdirs_0.3.3            #>  [29] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [31] ggrepel_0.9.6             irlba_2.3.5.1             #>  [33] terra_1.7-83              units_0.8-5               #>  [35] RSpectra_0.16-2           dqrng_0.4.1               #>  [37] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [39] codetools_0.2-20          DropletUtils_1.26.0       #>  [41] DelayedArray_0.32.0       tidyselect_1.2.1          #>  [43] UCSC.utils_1.2.0          memuse_4.2-3              #>  [45] farver_2.1.2              viridis_0.6.5             #>  [47] ScaledMatrix_1.14.0       BiocFileCache_2.14.0      #>  [49] jsonlite_1.8.9            BiocNeighbors_2.0.0       #>  [51] e1071_1.7-16              survival_3.7-0            #>  [53] systemfonts_1.1.0         tools_4.4.2               #>  [55] ggnewscale_0.5.0          ragg_1.3.3                #>  [57] Rcpp_1.0.13-1             glue_1.8.0                #>  [59] gridExtra_2.3             SparseArray_1.6.0         #>  [61] xfun_0.49                 EBImage_4.48.0            #>  [63] HDF5Array_1.34.0          withr_3.0.2               #>  [65] BiocManager_1.30.25       fastmap_1.2.0             #>  [67] boot_1.3-31               rhdf5filters_1.18.0       #>  [69] fansi_1.0.6               digest_0.6.37             #>  [71] rsvd_1.0.5                mime_0.12                 #>  [73] R6_2.5.1                  textshaping_0.4.0         #>  [75] colorspace_2.1-1          wk_0.9.4                  #>  [77] LearnBayes_2.15.1         jpeg_0.1-10               #>  [79] RSQLite_2.3.8             R.methodsS3_1.8.2         #>  [81] utf8_1.2.4                generics_0.1.3            #>  [83] data.table_1.16.2         class_7.3-22              #>  [85] httr_1.4.7                htmlwidgets_1.6.4         #>  [87] S4Arrays_1.6.0            pkgconfig_2.0.3           #>  [89] scico_1.5.0               gtable_0.3.6              #>  [91] blob_1.2.4                XVector_0.46.0            #>  [93] htmltools_0.5.8.1         fftwtools_0.9-11          #>  [95] scales_1.3.0              png_0.1-8                 #>  [97] knitr_1.49                rjson_0.2.23              #>  [99] coda_0.19-4.1             nlme_3.1-166              #> [101] curl_6.0.1                proxy_0.4-27              #> [103] cachem_1.1.0              zoo_1.8-12                #> [105] rhdf5_2.50.0              BiocVersion_3.20.0        #> [107] KernSmooth_2.23-24        vipor_0.4.7               #> [109] parallel_4.4.2            AnnotationDbi_1.68.0      #> [111] desc_1.4.3                s2_1.1.7                  #> [113] pillar_1.9.0              grid_4.4.2                #> [115] vctrs_0.6.5               BiocSingular_1.22.0       #> [117] dbplyr_2.5.0              beachmat_2.22.0           #> [119] sfheaders_0.4.4           cluster_2.1.6             #> [121] beeswarm_0.4.0            evaluate_1.0.1            #> [123] zeallot_0.1.0             magick_2.8.5              #> [125] mvtnorm_1.3-2             cli_3.6.3                 #> [127] locfit_1.5-9.10           compiler_4.4.2            #> [129] rlang_1.1.4               crayon_1.5.3              #> [131] labeling_0.4.3            classInt_0.4-10           #> [133] ggbeeswarm_0.7.2          fs_1.6.5                  #> [135] viridisLite_0.4.2         deldir_2.0-4              #> [137] munsell_0.5.1             Biostrings_2.74.0         #> [139] tiff_0.1-12               Matrix_1.7-1              #> [141] ExperimentHub_2.14.0      sparseMatrixStats_1.18.0  #> [143] bit64_4.5.2               Rhdf5lib_1.28.0           #> [145] KEGGREST_1.46.0           statmod_1.5.0             #> [147] AnnotationHub_3.14.0      igraph_2.1.1              #> [149] memoise_2.0.1             bslib_0.8.0               #> [151] bit_4.5.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"CODEX exploratory data analysis","text":"","code":"library(Voyager) library(SingleCellExperiment) library(SpatialExperiment) library(SpatialFeatureExperiment) library(batchelor) library(scater) library(scran) library(bluster) library(glue) library(purrr) library(tidyr) library(dplyr) library(ggplot2) library(gghighlight) library(patchwork) library(spdep) library(spatialDE) library(BiocParallel)  theme_set(theme_bw())"},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"CODEX exploratory data analysis","text":"dataset used vignette paper Strategies Accurate Cell Type Identification CODEX Multiplexed Imaging Data(Hickey, et.al 2021). data collected part HuBMap consortium seeks characterize healthy human tissues make data broadly available. specifically, dataset characterizes 4 regions large intestine (colon) single donor. vignette focus data sigmoid colon. intestinal sections interrogated using multiplexed imaging method CO-Detection indEXing (CODEX). CODEX involves cyclical staining tissue DNA-barcoded antibodies. round experimentation, fluoresently labeled probes hybridize tissue bound DNA-conjugated antibodies subsequently imaged stripped tissue. present, technology quantifies 60 markers single experiment. Raw images generated process subjected image stitching, drift compensation, deconvolution, cycle concatenation using publicly avaialable software. result pre-processing matrix contains location individual cells quantified markers cell. Cell types assigned described manuscript linked . Briefly, authors used hand-gating strategy define cell types create standard compare effect normalization methods clustering cell annotation. raw intensity data available download HuBMAP identifier HBM575.THQMM.284 cell type annotations provided supplementary data manuscript. data relevant vignette converted SFE object available download Box. data submitted SFEData package Bioconductor available future release. begin downloading data loading R. rows count matrix correspond 47 barcoded genes measured CODEX. Additionally, authors provide metadata cells, including cell type. turns column names unique cause errors downstream analysis. update column names ","code":"download.file(\"https://caltech.box.com/public/static/zfr8l20450n2z28lnp0ugdj471ph9eyx\",'./codex.Rds', mode='wb', method = 'wget', quiet = TRUE)  sfe <- readRDS(\"./codex.Rds\") sfe #> class: SpatialFeatureExperiment  #> dim: 47 19724  #> metadata(0): #> assays(1): protein #> rownames(47): MUC2 SOX9 ... CD49a CD163 #> rowData names(0): #> colnames(19724): 1 2 ... 182 184 #> colData names(9): cell_id cell_type ... fn sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : X Y #> imgData names(0): #>  #> unit: full_res_image_pixels #> Geometries: #> colGeometries: centroids (POINT)  #>  #> Graphs: #> sample01: cellids <- glue(\"{colData(sfe)$fn}_{colData(sfe)$cell_id}\") colnames(sfe) <- cellids"},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"exploratory-data-analysis","dir":"Articles","previous_headings":"Dataset","what":"Exploratory Data Analysis","title":"CODEX exploratory data analysis","text":"can see figure colonic epithelium enriched cells loose connective tissue muscle layers beneath epithelial layer sparsely populated. line known colon histology. epithelium enriched goblet cells invaginations project inwards towards connective tissue. Smooth muscle cells also prominent colon, bands muscle contract move colonic contents towards rectum. can visualize cell types space using plotSpatialFeature() function. highlight Goblet smooth muscle cells display relative distribution tissue. Since CODEX image processing relies segmentation, dot plot represents single cell. , cell represented centroid, can also visualized cell polygons cases segmentation mask available. goblet cells clearly define epithelial border tissue thick bands smooth muscle cells prominent mucosa. Next, compute gene level metrics 47 barcoded genes. contrast RNA-based methods, fields matrix represent intensities rather counts. appears sigmoid relationship mean variance protein expression. pattern reminiscent might expected intensity values derived Gamma distribution, continuous analog Negative Binomial distribution typically used describe count data scRNA-seq experiments. may implications CODEX data variance stabilized future. CODEX data subject noise several sources including segmentation artifacts, nonspecific staining, imperfect tissue processing. factors can limit accurate quantification signal intensity impede accurate cell annotation. authors dataset tested effects several normalization methods cell type annotation clustering found Z-score normalization marker resulted accurate identification rare common cell types. cell , demonstrate accomplish using standard matrix operations. normalized count matrix typically stored logcounts slot scRNA-seq data, instead store normalized matrix slot called normalizedIntensity.","code":"celldensity <- plotCellBin2D(sfe)  celldensity spatial <- plotSpatialFeature(sfe, features='cell_type', colGeometryName = \"centroids\") +     gghighlight(cell_type %in% c(\"Goblet\", \"SmoothMuscleME\")) #> Warning: Tried to calculate with group_by(), but the calculation failed. #> Falling back to ungrouped filter operation...  spatial rowData(sfe)$mean <- rowMeans(assay(sfe)) rowData(sfe)$var <- rowVars(assay(sfe))  data.frame(rowData(sfe)) |>     ggplot(aes(mean, var)) +      geom_point() mtx <- assay(sfe, 'protein') assay(sfe, 'normalizedIntensity') <- (mtx - rowMeans(mtx))/rowSds(mtx)  assays(sfe) #> List of length 2 #> names(2): protein normalizedIntensity"},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"spatial-eda","dir":"Articles","previous_headings":"","what":"Spatial EDA","title":"CODEX exploratory data analysis","text":"Neighbor definition critical step computation metrics spatial dependency like Moranâ€™s Gearyâ€™s C. definition neighbors complex, even cell polygons available. latter case, poly2nb method might appropriate assign two cells neighbors physically touch share border. may tenable cases cells sparse cells represented centroids, dataset. compute spatial neighborhood graph using knearestneigh function implemented spdep. brief, Euclidean distances computed pair cells k nearest cells considered neighbors. following code cell, consdier k=10 speed purposes, may ideal general. weights neighborhood matrix inverse-distance weighted, weight regions listed neighbors increases distance pairs points decreases. Setting style = \"W\" ensures weights row standardized. plotColGraph() function plots graph space along corresponding colGeometry, since many cells dataset, plotting neighborhood graph may useful many connections obscure overlapping lines. case, demonstrate use function . Next, explore univariate metrics global spatial autocorrelation. Since genes quantified study, compute metrics genes. larger datasets, may useful restrict analysis variable genes. use runUnivariate() function compute spatial autocorrelation metrics save results SFE object. results computations accessible rowData attribute SFE object. Next, plot results genes highest Moranâ€™s statistic. vertical line plot represents observed Moranâ€™s density represents Moranâ€™s statistic random permutations data. plots suggests Moranâ€™s statistic significant. can plot normalized intensity genes space. genes appear spatial distribution, also seems may overlap cell type. cells appear express genes interest seem spatially restricted known boundaries tissue. moranPlot() function plots spatial data spatially lagged values enables users assess similar observed values neighbors. variable centered, plot divided four quadrants defined horizontal line y = 0 vertical line x = 0. Points upper right (high-high) lower left (low-low) quadrants indicate positive spatial association, points lower right (high-low) upper left (low-high) quadrants include observations exhibit negative spatial association.","code":"colGraph(sfe, \"knn10\") <- findSpatialNeighbors(     sfe, method = \"knearneigh\", dist_type = \"idw\",      k = 10, style = \"W\") plotColGraph(sfe, colGraphName = \"knn10\", colGeometryName = 'centroids') sfe <- runUnivariate(     sfe, type = \"moran.mc\", features = rownames(sfe),     exprs_values = \"normalizedIntensity\", colGraphName = \"knn10\", nsim = 100,     BPPARAM = MulticoreParam(2))  sfe <- runUnivariate(     sfe, type = \"moran.plot\", features = rownames(sfe),     exprs_values = \"normalizedIntensity\", colGraphName = \"knn10\") colnames(rowData(sfe)) #> [1] \"mean\"                          \"var\"                           #> [3] \"moran.mc_statistic_sample01\"   \"moran.mc_parameter_sample01\"   #> [5] \"moran.mc_p.value_sample01\"     \"moran.mc_alternative_sample01\" #> [7] \"moran.mc_method_sample01\"      \"moran.mc_res_sample01\" top_moran <- data.frame(rowData(sfe)) |>     arrange(desc(moran.mc_statistic_sample01)) |>     head(6) |>      rownames()  moran <- plotMoranMC(sfe, features = top_moran, facet_by = 'features') moran plotSpatialFeature(     sfe, features=top_moran, colGeometryName = \"centroids\",     exprs_values = \"normalizedIntensity\", scattermore = TRUE, pointsize = 1) moranPlot(sfe, top_moran[1])"},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"differential-expression","dir":"Articles","previous_headings":"","what":"Differential Expression","title":"CODEX exploratory data analysis","text":"Moranâ€™s global spatial autocorrelation metrics provide insight spatial patterns gene expression, necessarily limited structure imposed spatial weights matrix. complimentary task might identify spatially variable (SV) genes. One method described SpatialDE: identification spatially variable genes. method described manuscript relies Gaussian process regression decomposes variability expression spatial non-spatial components. contrast Moranâ€™s , covariance pair cells modeled function distance . Notably, require explicit specification hte neighborhood graph, rather parameter controls decay covariance distance increases. spatialDE package implemented R requires normalized matrix input. spatialDE() function package performs normalization steps running algorithm. data already normalized, use run() function directly run spatialDE. first convert centroid coordinates data frame required function. can plot normalized expression top 5 genes space. Perhaps unsurprisingly, expression top DE genes seems highlight spatial distribution known cell types tissue rather identify spatially restricted gene expression. related experimental design targeted genes chosen differentiate cell types. Perhaps genome-wide technologies, potential discovery neew gene expression patterns plausible. open question whether results offer new information compared inferred typical DE expression methods. analyses represent minority types inferences can made protein expression data. interested investigate protein expression results compare inform data spatail scRNA-sequencing experiments. Already, work done obtain multimodal spatial measurements sample. Importantly however, considerations made types biases individual technology adds measurements. active areas research ripe future exploration.","code":"# Store coordinates in a data frame object coords <- centroids(sfe)$geometry |>     purrr::map_dfr(\\(x) c(x = x[1], y = x[2]))  # de_res <- spatialDE::run(assay(sfe,\"normalizedIntensity\"), coords, verbose=TRUE) # top_genes <- de_res |> #   arrange(pval) |> #   slice_head(n=6) |> #   pull(g) #  # plotSpatialFeature(sfe, top_genes, colGeometryName=\"centroids\", #                    exprs_values = \"normalizedIntensity\")"},{"path":"https://pachterlab.github.io/voyager/articles/vig8_codex.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"CODEX exploratory data analysis","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] BiocParallel_1.40.0            spatialDE_1.12.0               #>  [3] spdep_1.3-6                    sf_1.0-19                      #>  [5] spData_2.3.3                   patchwork_1.3.0                #>  [7] gghighlight_0.4.1              dplyr_1.1.4                    #>  [9] tidyr_1.3.1                    purrr_1.0.2                    #> [11] glue_1.8.0                     bluster_1.16.0                 #> [13] scran_1.34.0                   scater_1.34.0                  #> [15] ggplot2_3.5.1                  scuttle_1.16.0                 #> [17] batchelor_1.22.0               SpatialExperiment_1.16.0       #> [19] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #> [21] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [23] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [25] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [27] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [29] Voyager_1.8.1                  SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             filelock_1.0.3            #>   [3] bitops_1.0-9              tibble_3.2.1              #>   [5] R.oo_1.27.0               basilisk.utils_1.18.0     #>   [7] lifecycle_1.0.4           edgeR_4.4.0               #>   [9] lattice_0.22-6            MASS_7.3-61               #>  [11] backports_1.5.0           magrittr_2.0.3            #>  [13] limma_3.62.1              sass_0.4.9                #>  [15] rmarkdown_2.29            jquerylib_0.1.4           #>  [17] yaml_2.3.10               metapod_1.14.0            #>  [19] sp_2.1-4                  reticulate_1.40.0         #>  [21] RColorBrewer_1.1-3        DBI_1.2.3                 #>  [23] ResidualMatrix_1.16.0     multcomp_1.4-26           #>  [25] abind_1.4-8               spatialreg_1.3-5          #>  [27] zlibbioc_1.52.0           R.utils_2.12.3            #>  [29] RCurl_1.98-1.16           TH.data_1.1-2             #>  [31] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [33] ggrepel_0.9.6             irlba_2.3.5.1             #>  [35] terra_1.7-83              units_0.8-5               #>  [37] RSpectra_0.16-2           dqrng_0.4.1               #>  [39] pkgdown_2.1.1             DelayedMatrixStats_1.28.0 #>  [41] codetools_0.2-20          DropletUtils_1.26.0       #>  [43] DelayedArray_0.32.0       tidyselect_1.2.1          #>  [45] UCSC.utils_1.2.0          memuse_4.2-3              #>  [47] farver_2.1.2              ScaledMatrix_1.14.0       #>  [49] viridis_0.6.5             jsonlite_1.8.9            #>  [51] BiocNeighbors_2.0.0       e1071_1.7-16              #>  [53] survival_3.7-0            systemfonts_1.1.0         #>  [55] tools_4.4.2               ggnewscale_0.5.0          #>  [57] ragg_1.3.3                Rcpp_1.0.13-1             #>  [59] gridExtra_2.3             SparseArray_1.6.0         #>  [61] mgcv_1.9-1                xfun_0.49                 #>  [63] EBImage_4.48.0            HDF5Array_1.34.0          #>  [65] withr_3.0.2               fastmap_1.2.0             #>  [67] basilisk_1.18.0           boot_1.3-31               #>  [69] rhdf5filters_1.18.0       fansi_1.0.6               #>  [71] digest_0.6.37             rsvd_1.0.5                #>  [73] R6_2.5.1                  textshaping_0.4.0         #>  [75] colorspace_2.1-1          wk_0.9.4                  #>  [77] scattermore_1.2           LearnBayes_2.15.1         #>  [79] jpeg_0.1-10               R.methodsS3_1.8.2         #>  [81] utf8_1.2.4                generics_0.1.3            #>  [83] data.table_1.16.2         class_7.3-22              #>  [85] httr_1.4.7                htmlwidgets_1.6.4         #>  [87] S4Arrays_1.6.0            pkgconfig_2.0.3           #>  [89] scico_1.5.0               gtable_0.3.6              #>  [91] XVector_0.46.0            htmltools_0.5.8.1         #>  [93] fftwtools_0.9-11          scales_1.3.0              #>  [95] png_0.1-8                 knitr_1.49                #>  [97] rjson_0.2.23              checkmate_2.3.2           #>  [99] coda_0.19-4.1             nlme_3.1-166              #> [101] proxy_0.4-27              cachem_1.1.0              #> [103] zoo_1.8-12                rhdf5_2.50.0              #> [105] KernSmooth_2.23-24        parallel_4.4.2            #> [107] vipor_0.4.7               desc_1.4.3                #> [109] s2_1.1.7                  pillar_1.9.0              #> [111] grid_4.4.2                vctrs_0.6.5               #> [113] BiocSingular_1.22.0       beachmat_2.22.0           #> [115] sfheaders_0.4.4           cluster_2.1.6             #> [117] beeswarm_0.4.0            evaluate_1.0.1            #> [119] isoband_0.2.7             zeallot_0.1.0             #> [121] magick_2.8.5              mvtnorm_1.3-2             #> [123] cli_3.6.3                 locfit_1.5-9.10           #> [125] compiler_4.4.2            rlang_1.1.4               #> [127] crayon_1.5.3              labeling_0.4.3            #> [129] classInt_0.4-10           fs_1.6.5                  #> [131] ggbeeswarm_0.7.2          viridisLite_0.4.2         #> [133] deldir_2.0-4              munsell_0.5.1             #> [135] tiff_0.1-12               Matrix_1.7-1              #> [137] dir.expiry_1.14.0         sparseMatrixStats_1.18.0  #> [139] Rhdf5lib_1.28.0           statmod_1.5.0             #> [141] igraph_2.1.1              bslib_0.8.0"},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/vig9_splitseq.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"SPLiT-seq basic quality control","text":"data vignette shipped cellatlas repository. count matrix metadata provided cellatlas/examples folder AnnData object. begin loading object converting SpatialFeatureExperiment object.","code":"library(stringr) library(Matrix) library(SpatialExperiment) library(SpatialFeatureExperiment) library(scater) library(scuttle) library(Voyager) if (!file.exists(\"splitseq.rds\"))     download.file(\"https://github.com/pachterlab/voyager/raw/documentation-devel/vignettes/splitseq.rds\", destfile = \"splitseq.rds\") sce <- readRDS(\"splitseq.rds\") is_mito <- str_detect(rowData(sce)$gene_name, regex(\"^mt-\", ignore_case=TRUE)) sum(is_mito) #> [1] 37 sce <- addPerCellQCMetrics(sce, subsets = list(mito = is_mito)) names(colData(sce)) #> [1] \"sum\"                   \"detected\"              \"subsets_mito_sum\"      #> [4] \"subsets_mito_detected\" \"subsets_mito_percent\"  \"total\" plotColData(sce, \"sum\") +     plotColData(sce, \"detected\") +     plotColData(sce, \"subsets_mito_percent\") #> Warning: Removed 7213 rows containing non-finite outside the scale range #> (`stat_ydensity()`). #> Warning: Removed 7213 rows containing missing values or values outside the scale range #> (`position_quasirandom()`). plotColData(sce, x = \"sum\", y = \"detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. plotColData(sce, x = \"sum\", y = \"subsets_mito_detected\", bins = 100) +     scale_fill_distiller(palette = \"Blues\", direction = 1) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. sce <- sce[, which(sce$subsets_mito_percent < 20)] sce <- sce[rowSums(counts(sce)) > 0,]  sce #> class: SingleCellExperiment  #> dim: 18272 102057  #> metadata(0): #> assays(1): counts #> rownames(18272): ENSMUSG00000086053.2 ENSMUSG00000051285.18 ... #>   ENSMUSG00000079808.4 ENSMUSG00000095041.8 #> rowData names(2): gene_name subsets_mito #> colnames(102057): AAACATCGAAACATCGACTTCATC AAACATCGAAACATCGAGTCTTGG ... #>   TTCACGCATTCACGCATCATATTC TTCACGCATTCACGCATTCATCGC #> colData names(6): sum detected ... subsets_mito_percent total #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Voyager_1.8.1                  scater_1.34.0                  #>  [3] ggplot2_3.5.1                  scuttle_1.16.0                 #>  [5] SpatialFeatureExperiment_1.9.4 SpatialExperiment_1.16.0       #>  [7] SingleCellExperiment_1.28.1    SummarizedExperiment_1.36.0    #>  [9] Biobase_2.66.0                 GenomicRanges_1.58.0           #> [11] GenomeInfoDb_1.42.0            IRanges_2.40.0                 #> [13] S4Vectors_0.44.0               BiocGenerics_0.52.0            #> [15] MatrixGenerics_1.18.0          matrixStats_1.4.1              #> [17] Matrix_1.7-1                   stringr_1.5.1                  #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] R6_2.5.1                  fastmap_1.2.0             #>  [41] GenomeInfoDbData_1.2.13   digest_0.6.37             #>  [43] ggnewscale_0.5.0          colorspace_2.1-1          #>  [45] patchwork_1.3.0           RSpectra_0.16-2           #>  [47] irlba_2.3.5.1             dqrng_0.4.1               #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               rappdirs_0.3.3            #>  [67] DelayedArray_0.32.0       bluster_1.16.0            #>  [69] rjson_0.2.23              classInt_0.4-10           #>  [71] tools_4.4.2               units_0.8-5               #>  [73] vipor_0.4.7               beeswarm_0.4.0            #>  [75] R.oo_1.27.0               glue_1.8.0                #>  [77] nlme_3.1-166              EBImage_4.48.0            #>  [79] rhdf5filters_1.18.0       grid_4.4.2                #>  [81] sf_1.0-19                 cluster_2.1.6             #>  [83] memuse_4.2-3              generics_0.1.3            #>  [85] gtable_0.3.6              R.methodsS3_1.8.2         #>  [87] class_7.3-22              data.table_1.16.2         #>  [89] ScaledMatrix_1.14.0       BiocSingular_1.22.0       #>  [91] sp_2.1-4                  utf8_1.2.4                #>  [93] XVector_0.46.0            ggrepel_0.9.6             #>  [95] pillar_1.9.0              limma_3.62.1              #>  [97] splines_4.4.2             dplyr_1.1.4               #>  [99] lattice_0.22-6            survival_3.7-0            #> [101] deldir_2.0-4              tidyselect_1.2.1          #> [103] locfit_1.5-9.10           sfheaders_0.4.4           #> [105] knitr_1.49                gridExtra_2.3             #> [107] edgeR_4.4.0               xfun_0.49                 #> [109] statmod_1.5.0             DropletUtils_1.26.0       #> [111] stringi_1.8.4             UCSC.utils_1.2.0          #> [113] fftwtools_0.9-11          yaml_2.3.10               #> [115] boot_1.3-31               evaluate_1.0.1            #> [117] codetools_0.2-20          tibble_3.2.1              #> [119] cli_3.6.3                 reticulate_1.40.0         #> [121] systemfonts_1.1.0         munsell_0.5.1             #> [123] jquerylib_0.1.4           Rcpp_1.0.13-1             #> [125] zeallot_0.1.0             coda_0.19-4.1             #> [127] png_0.1-8                 parallel_4.4.2            #> [129] pkgdown_2.1.1             jpeg_0.1-10               #> [131] sparseMatrixStats_1.18.0  bitops_1.0-9              #> [133] viridisLite_0.4.2         mvtnorm_1.3-2             #> [135] scales_1.3.0              e1071_1.7-16              #> [137] crayon_1.5.3              scico_1.5.0               #> [139] rlang_1.1.4               cowplot_1.1.3             #> [141] multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Basic analysis of 10X example Visium dataset","text":"introductory vignette SpatialFeatureExperiment data representation Voyager anlaysis package, demonstrate basic exploratory data analysis (EDA) spatial transcriptomics data. Basic knowledge R SingleCellExperiment assumed. vignette showcases packages Visium spatial gene expression system dataset, downloaded 10X website, Space Ranger output format. technology chosen due popularity, therefore availability numerous publicly available datasets analysis (Moses2022-xz?). Voyager developed goal facilitating use geospatial methods spatial genomics, introductory vignette restricted non-spatial scRNA-seq EDA Visium dataset. another Visium introductory vignette using dataset SFEData package 10X website. load packages used vignette. download data 10X website. unfiltered gene count matrix: spatial information: Decompress downloaded content: outs directory Space Ranger output looks like: gene count matrix directory: spatial directory: outputs spatial directory explained 10X website. tissue_hires_image.png relatively high resolution image tissue, full resolution. tissue_lowres_image.png file low resolution image tissue, suitable quick plotting, shown : array dots framing tissue seen image fiducials, used align tissue image positions Visium spots, gene expression can matched spatial locations. alignment fiducials shown aligned_fiducials.jpg. Space Ranger can automatically detect spots tissue, spots highlighted detected_tissue_image.jpg. Inside scalefactors_json.json file: spot_diameter_fullres diameter Visium spot full resolution H&E image pixels. tissue_hires_scalef tissue_lowres_scalef ratio size high resolution (full resolution) low resolution H&E image full resolution image. fiducial_diameter_fullres diameter fiducial spot used align spots H&E image pixels full resolution image. tissue_positions_list.csv file contains information coordinates spots full resolution image whether spot tissue (in_tissue, 1 means yes 0 means ) automatically detected Space Ranger manually annotated Loupe browser. spatial_enrichment.csv file Moranâ€™s (presumably spots tissue) p-value gene detected least 10 spots least 20 UMIs. read Space Ranger output R SFE object:","code":"library(Voyager) library(SpatialExperiment) library(SpatialFeatureExperiment) library(SingleCellExperiment) library(ggplot2) library(scater) library(scuttle) library(scran) library(stringr) library(patchwork) library(bluster) library(rjson) theme_set(theme_bw()) if (!file.exists(\"visium_ob.tar.gz\"))     download.file(\"https://cf.10xgenomics.com/samples/spatial-exp/2.0.0/Visium_Mouse_Olfactory_Bulb/Visium_Mouse_Olfactory_Bulb_raw_feature_bc_matrix.tar.gz\",                    destfile = \"visium_ob.tar.gz\") if (!file.exists(\"visium_ob_spatial.tar.gz\"))     download.file(\"https://cf.10xgenomics.com/samples/spatial-exp/2.0.0/Visium_Mouse_Olfactory_Bulb/Visium_Mouse_Olfactory_Bulb_spatial.tar.gz\",                    destfile = \"visium_ob_spatial.tar.gz\") if (!dir.exists(\"outs\")) {     dir.create(\"outs\")     system(\"tar -xvf visium_ob.tar.gz -C outs\")     system(\"tar -xvf visium_ob_spatial.tar.gz -C outs\") } list.dirs(\"outs\") #> [1] \"outs\"                       \"outs/raw_feature_bc_matrix\" #> [3] \"outs/spatial\" list.files(\"outs/raw_feature_bc_matrix\") #> [1] \"barcodes.tsv.gz\" \"features.tsv.gz\" \"matrix.mtx.gz\" list.files(\"outs/spatial\") #> [1] \"aligned_fiducials.jpg\"     \"detected_tissue_image.jpg\" #> [3] \"scalefactors_json.json\"    \"spatial_enrichment.csv\"    #> [5] \"tissue_hires_image.png\"    \"tissue_lowres_image.png\"   #> [7] \"tissue_positions.csv\" fromJSON(file = \"outs/spatial/scalefactors_json.json\") #> $tissue_hires_scalef #> [1] 0.2 #>  #> $tissue_lowres_scalef #> [1] 0.06 #>  #> $fiducial_diameter_fullres #> [1] 118.9155 #>  #> $spot_diameter_fullres #> [1] 73.61433 head(read.csv(\"outs/spatial/tissue_positions.csv\")) #>              barcode in_tissue array_row array_col pxl_row_in_fullres #> 1 ACGCCTGACACGCGCT-1         0         0         0               8668 #> 2 TACCGATCCAACACTT-1         0         1         1               8611 #> 3 ATTAAAGCGGACGAGC-1         0         0         2               8554 #> 4 GATAAGGGACGATTAG-1         0         1         3               8498 #> 5 GTGCAAATCACCAATA-1         0         0         4               8441 #> 6 TGTTGGCTGGCGGAAG-1         0         1         5               8384 #>   pxl_col_in_fullres #> 1               1102 #> 2               1200 #> 3               1102 #> 4               1200 #> 5               1102 #> 6               1200 head(read.csv(\"outs/spatial/spatial_enrichment.csv\")) #>           Feature.ID Feature.Name    Feature.Type         I P.value #> 1 ENSMUSG00000001023       S100a5 Gene Expression 0.7709048       0 #> 2 ENSMUSG00000019874        Fabp7 Gene Expression 0.6987346       0 #> 3 ENSMUSG00000002985         Apoe Gene Expression 0.6945210       0 #> 4 ENSMUSG00000025739        Gng13 Gene Expression 0.6585750       0 #> 5 ENSMUSG00000090223         Pcp4 Gene Expression 0.6317032       0 #> 6 ENSMUSG00000053310         Nrgn Gene Expression 0.6033600       0 #>   Adjusted.p.value Feature.Counts.in.Spots.Under.Tissue #> 1                0                                 9019 #> 2                0                                13462 #> 3                0                                67509 #> 4                0                                 5260 #> 5                0                                45118 #> 6                0                                10723 #>   Median.Normalized.Average.Counts Barcodes.Detected.per.Feature #> 1                        15.848669                          1021 #> 2                        20.679932                          1170 #> 3                        76.635169                          1184 #> 4                         8.803694                          1050 #> 5                        25.811125                          1133 #> 6                         6.075966                           898 (sfe <- read10xVisiumSFE(samples = \".\", type = \"sparse\", data = \"raw\")) #> >>> 10X Visium data will be loaded: outs #> class: SpatialFeatureExperiment  #> dim: 32285 4992  #> metadata(0): #> assays(1): counts #> rownames(32285): ENSMUSG00000051951 ENSMUSG00000089699 ... #>   ENSMUSG00000095019 ENSMUSG00000095041 #> rowData names(8): symbol Feature.Type ... #>   Median.Normalized.Average.Counts_sample01 #>   Barcodes.Detected.per.Feature_sample01 #> colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... #>   TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 #> colData names(4): in_tissue array_row array_col sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01:"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x.html","id":"quality-control-qc","dir":"Articles","previous_headings":"","what":"Quality control (QC)","title":"Basic analysis of 10X example Visium dataset","text":"mouse olfactory bulb conventionally plotted horizontally. entire SFE object can transposed histologial space make olfactory bulb horizontal.  Percentage mitochondrial counts spots outside tissue higher near tissue, especially left.  3 peaks, apparently histologically relevant. Also obvious outliers.  unlike scRNA-seq data. Spots tissue wide range mitocondrial percentage. Spots tissue fall 3 clusters plot, seemingly related histological regions.","code":"is_mt <- str_detect(rowData(sfe)$symbol, \"^mt-\") sfe <- addPerCellQCMetrics(sfe, subsets = list(mito = is_mt)) names(colData(sfe)) #>  [1] \"in_tissue\"             \"array_row\"             \"array_col\"             #>  [4] \"sample_id\"             \"sum\"                   \"detected\"              #>  [7] \"subsets_mito_sum\"      \"subsets_mito_detected\" \"subsets_mito_percent\"  #> [10] \"total\" sfe <- SpatialFeatureExperiment::transpose(sfe) plotSpatialFeature(sfe, c(\"sum\", \"detected\", \"subsets_mito_percent\"),                     image_id = \"lowres\", maxcell = 5e4, ncol = 2) plotColData(sfe, \"sum\", x = \"in_tissue\", color_by = \"in_tissue\") +     plotColData(sfe, \"detected\", x = \"in_tissue\", color_by = \"in_tissue\") +     plotColData(sfe, \"subsets_mito_percent\", x = \"in_tissue\", color_by = \"in_tissue\") +     plot_layout(guides = \"collect\") plotColData(sfe, x = \"sum\", y = \"subsets_mito_percent\", color_by = \"in_tissue\") +     geom_density_2d() sfe_tissue <- sfe[,sfe$in_tissue] plotColData(sfe_tissue, x = \"sum\", y = \"detected\", bins = 75) #clusters <- quickCluster(sfe_tissue) #sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) #sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) dec <- modelGeneVar(sfe_tissue, lowess = FALSE) hvgs <- getTopHVGs(dec, n = 2000)"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x.html","id":"dimension-reduction-and-clustering","dir":"Articles","previous_headings":"","what":"Dimension reduction and clustering","title":"Basic analysis of 10X example Visium dataset","text":"clustering show dimension reduction plots    Significant markers cluster can obtained follows:  genes interesting view spatial context:  spatial analyses dataset performed â€œadvancedâ€ version vignette.","code":"sfe_tissue <- runPCA(sfe_tissue, ncomponents = 30, subset_row = hvgs,                      scale = TRUE) # scale as in Seurat ElbowPlot(sfe_tissue, ndims = 30) names(rowData(sfe_tissue)) #> [1] \"symbol\"                                        #> [2] \"Feature.Type\"                                  #> [3] \"I_sample01\"                                    #> [4] \"P.value_sample01\"                              #> [5] \"Adjusted.p.value_sample01\"                     #> [6] \"Feature.Counts.in.Spots.Under.Tissue_sample01\" #> [7] \"Median.Normalized.Average.Counts_sample01\"     #> [8] \"Barcodes.Detected.per.Feature_sample01\"        #> [9] \"subsets_mito\" plotDimLoadings(sfe_tissue, dims = 1:5, swap_rownames = \"symbol\", ncol = 3) set.seed(29) colData(sfe_tissue)$cluster <- clusterRows(reducedDim(sfe_tissue, \"PCA\")[,1:3],                                            BLUSPARAM = SNNGraphParam(                                                cluster.fun = \"leiden\",                                                cluster.args = list(                                                    resolution_parameter = 0.5,                                                    objective_function = \"modularity\"))) plotPCA(sfe_tissue, ncomponents = 5, colour_by = \"cluster\") plotSpatialFeature(sfe_tissue, features = \"cluster\",                     colGeometryName = \"spotPoly\", image_id = \"lowres\") spatialReducedDim(sfe_tissue, \"PCA\", ncomponents = 5,                    colGeometryName = \"spotPoly\", divergent = TRUE,                    diverge_center = 0, ncol = 2,                    image_id = \"lowres\", maxcell = 5e4) markers <- findMarkers(sfe_tissue, groups = colData(sfe_tissue)$cluster,                        test.type = \"wilcox\", pval.type = \"all\", direction = \"up\") genes_use <- vapply(markers, function(x) rownames(x)[1], FUN.VALUE = character(1)) plotExpression(sfe_tissue, rowData(sfe_tissue)[genes_use, \"symbol\"], x = \"cluster\",                colour_by = \"cluster\", swap_rownames = \"symbol\") plotSpatialFeature(sfe_tissue, genes_use, colGeometryName = \"spotPoly\", ncol = 2,                    swap_rownames = \"symbol\", image_id = \"lowres\", maxcell = 5e4)"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Basic analysis of 10X example Visium dataset","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] rjson_0.2.23                   bluster_1.16.0                 #>  [3] patchwork_1.3.0                stringr_1.5.1                  #>  [5] scran_1.34.0                   scater_1.34.0                  #>  [7] scuttle_1.16.0                 ggplot2_3.5.1                  #>  [9] SpatialExperiment_1.16.0       SingleCellExperiment_1.28.1    #> [11] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [13] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [15] IRanges_2.40.0                 S4Vectors_0.44.0               #> [17] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [19] matrixStats_1.4.1              Voyager_1.8.1                  #> [21] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3        jsonlite_1.8.9            #>   [3] wk_0.9.4                  magrittr_2.0.3            #>   [5] ggbeeswarm_0.7.2          TH.data_1.1-2             #>   [7] magick_2.8.5              farver_2.1.2              #>   [9] rmarkdown_2.29            fs_1.6.5                  #>  [11] zlibbioc_1.52.0           ragg_1.3.3                #>  [13] vctrs_0.6.5               spdep_1.3-6               #>  [15] DelayedMatrixStats_1.28.0 RCurl_1.98-1.16           #>  [17] terra_1.7-83              htmltools_0.5.8.1         #>  [19] S4Arrays_1.6.0            BiocNeighbors_2.0.0       #>  [21] Rhdf5lib_1.28.0           s2_1.1.7                  #>  [23] SparseArray_1.6.0         rhdf5_2.50.0              #>  [25] LearnBayes_2.15.1         sass_0.4.9                #>  [27] spData_2.3.3              KernSmooth_2.23-24        #>  [29] bslib_0.8.0               htmlwidgets_1.6.4         #>  [31] desc_1.4.3                sandwich_3.1-1            #>  [33] zoo_1.8-12                cachem_1.1.0              #>  [35] igraph_2.1.1              lifecycle_1.0.4           #>  [37] pkgconfig_2.0.3           rsvd_1.0.5                #>  [39] Matrix_1.7-1              R6_2.5.1                  #>  [41] fastmap_1.2.0             GenomeInfoDbData_1.2.13   #>  [43] digest_0.6.37             colorspace_2.1-1          #>  [45] ggnewscale_0.5.0          irlba_2.3.5.1             #>  [47] dqrng_0.4.1               RSpectra_0.16-2           #>  [49] textshaping_0.4.0         beachmat_2.22.0           #>  [51] labeling_0.4.3            fansi_1.0.6               #>  [53] spatialreg_1.3-5          httr_1.4.7                #>  [55] abind_1.4-8               compiler_4.4.2            #>  [57] proxy_0.4-27              withr_3.0.2               #>  [59] tiff_0.1-12               BiocParallel_1.40.0       #>  [61] viridis_0.6.5             DBI_1.2.3                 #>  [63] HDF5Array_1.34.0          R.utils_2.12.3            #>  [65] MASS_7.3-61               DelayedArray_0.32.0       #>  [67] classInt_0.4-10           tools_4.4.2               #>  [69] units_0.8-5               vipor_0.4.7               #>  [71] beeswarm_0.4.0            R.oo_1.27.0               #>  [73] glue_1.8.0                nlme_3.1-166              #>  [75] EBImage_4.48.0            rhdf5filters_1.18.0       #>  [77] grid_4.4.2                sf_1.0-19                 #>  [79] cluster_2.1.6             memuse_4.2-3              #>  [81] generics_0.1.3            isoband_0.2.7             #>  [83] gtable_0.3.6              R.methodsS3_1.8.2         #>  [85] class_7.3-22              data.table_1.16.2         #>  [87] metapod_1.14.0            ScaledMatrix_1.14.0       #>  [89] BiocSingular_1.22.0       sp_2.1-4                  #>  [91] utf8_1.2.4                XVector_0.46.0            #>  [93] ggrepel_0.9.6             pillar_1.9.0              #>  [95] limma_3.62.1              splines_4.4.2             #>  [97] dplyr_1.1.4               lattice_0.22-6            #>  [99] survival_3.7-0            deldir_2.0-4              #> [101] tidyselect_1.2.1          locfit_1.5-9.10           #> [103] sfheaders_0.4.4           knitr_1.49                #> [105] gridExtra_2.3             edgeR_4.4.0               #> [107] xfun_0.49                 statmod_1.5.0             #> [109] DropletUtils_1.26.0       stringi_1.8.4             #> [111] UCSC.utils_1.2.0          fftwtools_0.9-11          #> [113] yaml_2.3.10               boot_1.3-31               #> [115] evaluate_1.0.1            codetools_0.2-20          #> [117] tibble_3.2.1              cli_3.6.3                 #> [119] systemfonts_1.1.0         munsell_0.5.1             #> [121] jquerylib_0.1.4           Rcpp_1.0.13-1             #> [123] zeallot_0.1.0             coda_0.19-4.1             #> [125] png_0.1-8                 parallel_4.4.2            #> [127] pkgdown_2.1.1             jpeg_0.1-10               #> [129] sparseMatrixStats_1.18.0  bitops_1.0-9              #> [131] viridisLite_0.4.2         mvtnorm_1.3-2             #> [133] scales_1.3.0              e1071_1.7-16              #> [135] crayon_1.5.3              scico_1.5.0               #> [137] rlang_1.1.4               cowplot_1.1.3             #> [139] multcomp_1.4-26"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatial analysis of 10X example Visium dataset","text":"introductory vignette, performed basic non-spatial analyses mouse olfactory bulb Visium dataset 10X website. vignette, perform spatial analyses histological space well gene expression space. load packages used vignette: <<<<<<< HEAD download data 10X website. unfiltered gene count matrix: spatial information: Decompress downloaded content: Contents outs directory Space Ranger explained introductory vignette. read data R SFE object. add QC metrics, already plotted introductory vignette.","code":"library(Voyager) library(SpatialFeatureExperiment) library(SingleCellExperiment) library(ggplot2) library(scater) library(scuttle) library(scran) library(stringr) library(patchwork) library(bluster) library(rjson) library(EBImage) library(terra) library(rlang) library(sf) library(rmapshaper) library(dplyr) library(BiocParallel) library(BiocNeighbors) library(reticulate) theme_set(theme_bw()) # Specify Python version to use gget PY_PATH <- system(\"which python\", intern = TRUE) use_python(PY_PATH) py_config() ======= >>>>>>> documentation gget <- import(\"gget\") if (!file.exists(\"visium_ob.tar.gz\"))     download.file(\"https://cf.10xgenomics.com/samples/spatial-exp/2.0.0/Visium_Mouse_Olfactory_Bulb/Visium_Mouse_Olfactory_Bulb_raw_feature_bc_matrix.tar.gz\",                    destfile = \"visium_ob.tar.gz\") if (!file.exists(\"visium_ob_spatial.tar.gz\"))     download.file(\"https://cf.10xgenomics.com/samples/spatial-exp/2.0.0/Visium_Mouse_Olfactory_Bulb/Visium_Mouse_Olfactory_Bulb_spatial.tar.gz\",                    destfile = \"visium_ob_spatial.tar.gz\") if (!dir.exists(\"outs\")) {     dir.create(\"outs\")     system(\"tar -xvf visium_ob.tar.gz -C outs\")     system(\"tar -xvf visium_ob_spatial.tar.gz -C outs\") } (sfe <- read10xVisiumSFE(samples = \".\", type = \"sparse\", data = \"raw\")) #> >>> 10X Visium data will be loaded: outs #> class: SpatialFeatureExperiment  #> dim: 32285 4992  #> metadata(0): #> assays(1): counts #> rownames(32285): ENSMUSG00000051951 ENSMUSG00000089699 ... #>   ENSMUSG00000095019 ENSMUSG00000095041 #> rowData names(8): symbol Feature.Type ... #>   Median.Normalized.Average.Counts_sample01 #>   Barcodes.Detected.per.Feature_sample01 #> colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... #>   TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 #> colData names(4): in_tissue array_row array_col sample_id #> reducedDimNames(0): #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor #>  #> unit: full_res_image_pixel #> Geometries: #> colGeometries: spotPoly (POLYGON)  #>  #> Graphs: #> sample01: is_mt <- str_detect(rowData(sfe)$symbol, \"^mt-\") sfe <- addPerCellQCMetrics(sfe, subsets = list(mito = is_mt))"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"tissue-segmentation","dir":"Articles","previous_headings":"","what":"Tissue segmentation","title":"Spatial analysis of 10X example Visium dataset","text":"Space Ranger can automatically detect spots tissue Loupe browser can used manually annotate spots tissue, may interesting get tissue outline polygon, know much spot overlaps tissue plot outline. tissue boundary polygon can manually annotated QuPath, saves polygon GeoJSON can directly read R st_read(). can segment tissue computationally. R generally isnâ€™t great image processing, packages can perform segmentation, EBImage, based house C C++ code, imager, based CImg. donâ€™t full resolution image. perform tissue segmentation high resolution downsampled image scale make coordinates tissue boundary match spots. EBImage package used . Compared OpenCV, EBImage slow full resolution image, fine downsized image.  rendered static webpage, image static, run interactively, image shown interactive widget can zoom pan. show RGB channels separately   tissue can discerned thresholding. tall peak right background. much lower peaks around 0.6 0.85 must tissue. capture faint bluish region, blue channel used thresholding. threshold chosen based histogram experimenting nearby values.  use opening operation (erosion followed dilation) denoise  small holes tissue, can removed closing operation (dilation followed erosion):  larger holes tissue mask, may real holes faint regions nuclei missed thresholding. might large enough affect Visium spots intersect tissue. Now main piece tissue clear. must object largest area. However, two small pieces belong tissue top left. debris fiducials can removed setting pixels mask outside bounding box main piece 0. assign different value contiguous object bwlabel(), use computeFeatures.shape() find area among shape features (e.g.Â perimeter) object.  remove small pieces debris.  Object number 797 piece debris bottom left. pieces area 100 pixels tissue. Since debris really small bits tissue, boundary debris tissue can blurry. two distinguished morphology H&E image proximity main tissue. remove debris mask Since holes mask faint regions tissue missed thresholding, holes filled  segmentation process took lot manual oversight, choosing threshold, choosing kernel size shape opening closing operations, deciding whether fill holes, deciding debris tissue.","code":"img <- readImage(\"outs/spatial/tissue_hires_image.png\") display(img) img2 <- img colorMode(img2) <- Grayscale display(img2, all = TRUE) hist(img) mask <- img2[,,3] < 0.87 display(mask) kern <- makeBrush(3, shape='disc') mask_open <- opening(mask, kern) display(mask_open) mask_close <- closing(mask_open, kern) display(mask_close) mask_label <- bwlabel(mask_close) fts <- computeFeatures.shape(mask_label) head(fts) #>   s.area s.perimeter s.radius.mean s.radius.sd s.radius.min s.radius.max #> 1     39          25      3.428773   1.3542219    1.4176036     5.762777 #> 2     20          14      2.032665   0.3439068    1.5000000     2.500000 #> 3      8           8      1.144123   0.4370160    0.7071068     1.581139 #> 4     14          10      1.689175   0.2160726    1.5811388     2.121320 #> 5     15          12      1.716761   0.4684015    1.0000000     2.236068 #> 6      9           8      1.207107   0.2071068    1.0000000     1.414214 summary(fts[,\"s.area\"]) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #>      8.0     14.0     51.0    595.9    345.0 496326.0 max_ind <- which.max(fts[,\"s.area\"]) inds <- which(as.array(mask_label) == max_ind, arr.ind = TRUE) head(inds) #>       row col #> [1,] 1168 562 #> [2,] 1169 562 #> [3,] 1170 562 #> [4,] 1158 563 #> [5,] 1159 563 #> [6,] 1160 563 row_inds <- c(seq_len(min(inds[,1])-1), seq(max(inds[,1])+1, nrow(mask_label), by = 1)) col_inds <- c(seq_len(min(inds[,2])-1), seq(max(inds[,2])+1, nrow(mask_label), by = 1)) mask_label[row_inds, ] <- 0 mask_label[,col_inds] <- 0 display(mask_label) unique(as.vector(mask_label)) #>  [1]   0 421 425 429 430 438 450 458 461 469 473 483 487 505 523 633 640 642 651 #> [20] 678 739 741 757 762 775 778 789 791 797 805 810 813 820 821 822 826 831 838 #> [39] 839 840 843 845 848 849 861 862 863 fts2 <- fts[unique(as.vector(mask_label))[-1],] fts2 <- fts2[order(fts2[,\"s.area\"], decreasing = TRUE),] plot(fts2[,1][-1], type = \"l\", ylab = \"Area\") head(fts2, 10) #>     s.area s.perimeter s.radius.mean s.radius.sd s.radius.min s.radius.max #> 421 496326        3151    395.118732  68.6493949  234.1605637   485.715835 #> 450    217          55      7.840627   1.2883202    5.0010247    10.458197 #> 849    211          63      7.961248   2.0228566    3.8569142    12.189753 #> 797    182          56      7.547362   2.3368359    3.0772370    11.839919 #> 461    136          54      7.186020   3.2751628    0.9255555    12.479805 #> 741     92          56      6.365661   2.8382829    1.3273276    11.653219 #> 840     69          33      4.503526   1.6417370    1.6026264     7.076974 #> 862     63          37      4.854424   2.4445530    0.6361407     8.837838 #> 839     45          25      3.305562   0.7074306    1.9320455     4.526897 #> 775     32          22      2.887407   1.1755375    0.5300865     4.543636 #display(mask_label == 797) mask_label[mask_label %in% c(797, as.numeric(rownames(fts2)[fts2[,1] < 100]))] <- 0 mask_label <- fillHull(mask_label) display(paintObjects(mask_label, img, col=c(\"red\", \"yellow\"), opac=c(1, 0.3)))"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"convert-tissue-mask-to-polygon","dir":"Articles","previous_headings":"","what":"Convert tissue mask to polygon","title":"Spatial analysis of 10X example Visium dataset","text":"Now tissue mask, convert polygon. OpenCV can directly perform conversion, isnâ€™t comprehensive R wrapper OpenCV, conversion convoluted R. first convert Image object raster implemented terra, core R package geospatial raster data. terra can convert raster polygon. image downsized, polygon look quite pixelated. mitigate pixelation save memory, ms_simplify() function used simplify polygon, keeping small proportion vertices. st_simplify() function sf can also simplify polygons, canâ€™t specify proportion vertices keep. adding geometry SFE object, needs scaled match coordinates spots  mouse olfactory bulb conventionally plotted horizontally. entire SFE object can transposed histologial space make olfactory bulb horizontal.  can use geometric operations find spots intersect tissue, spots covered tissue, much spot intersects tissue. Discrepancies Space Rangerâ€™s annotation annotation based tissue segmentation :  Spots margin can intersect tissue without covered .  can also get geometries intersections tissue Visium spots, calculate percentage spot tissue. However, percentage may useful tissue segmentation subject error. percentage may useful pathologist annotated histological regions objects nuclei myofibers. spots intersect tissue, total counts relate percentage spot tissue?  Spots fully covered tissue lower total UMI counts, can due fully tissue cell types lower total counts histological region near edge, spots fully covered tissue also low UMI counts.","code":"raster2polygon <- function(seg, keep = 0.2) {     r <- rast(as.array(seg), extent = ext(0, nrow(seg), 0, ncol(seg))) |>          trans() |> flip()     r[r < 1] <- NA     contours <- st_as_sf(as.polygons(r, dissolve = TRUE))     simplified <- ms_simplify(contours, keep = keep)     list(full = contours,          simplified = simplified) } tb <- raster2polygon(mask_label) scale_factors <- fromJSON(file = \"outs/spatial/scalefactors_json.json\") tb$simplified$geometry <- tb$simplified$geometry / scale_factors$tissue_hires_scalef tissueBoundary(sfe) <- tb$simplified plotSpatialFeature(sfe, \"sum\", annotGeometryName = \"tissueBoundary\",                     annot_fixed = list(fill = NA, color = \"black\"),                    image_id = \"lowres\") +     theme_void() sfe <- SpatialFeatureExperiment::transpose(sfe) plotSpatialFeature(sfe, \"sum\", annotGeometryName = \"tissueBoundary\",                     annot_fixed = list(fill = NA, color = \"black\"),                    image_id = \"lowres\") # Which spots intersect tissue sfe$int_tissue <- annotPred(sfe, colGeometryName = \"spotPoly\",                              annotGeometryName = \"tissueBoundary\",                             pred = st_intersects) sfe$cov_tissue <- annotPred(sfe, colGeometryName = \"spotPoly\",                              annotGeometryName = \"tissueBoundary\",                             pred = st_covered_by) sfe$diff_sr <- case_when(sfe$in_tissue == sfe$int_tissue ~ \"same\",                          sfe$in_tissue & !sfe$int_tissue ~ \"Space Ranger\",                          sfe$int_tissue & !sfe$in_tissue ~ \"segmentation\") |>      factor(levels = c(\"Space Ranger\", \"same\", \"segmentation\")) plotSpatialFeature(sfe, \"diff_sr\",                     annotGeometryName = \"tissueBoundary\",                     annot_fixed = list(fill = NA, size = 0.5, color = \"black\")) +     scale_fill_brewer(type = \"div\", palette = 4) #> Scale for fill is already present. #> Adding another scale for fill, which will replace the existing scale. sfe$diff_int_cov <- sfe$int_tissue != sfe$cov_tissue plotSpatialFeature(sfe, \"diff_int_cov\",                     annotGeometryName = \"tissueBoundary\",                     annot_fixed = list(fill = NA, size = 0.5, color = \"black\")) spot_ints <- annotOp(sfe, colGeometryName = \"spotPoly\",                       annotGeometryName = \"tissueBoundary\", op = st_intersection) sfe$pct_tissue <- st_area(spot_ints) / st_area(spotPoly(sfe)) * 100 sfe_tissue <- sfe[,sfe$int_tissue] plotColData(sfe_tissue, x = \"pct_tissue\", y = \"sum\", color_by = \"diff_int_cov\")"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"spatial-autocorrelation-of-qc-metrics","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of QC metrics","title":"Spatial analysis of 10X example Visium dataset","text":"","code":"colGraph(sfe_tissue, \"visium\") <- findVisiumGraph(sfe_tissue) qc_features <- c(\"sum\", \"detected\", \"subsets_mito_percent\") sfe_tissue <- colDataUnivariate(sfe_tissue, \"moran.mc\", qc_features, nsim = 200) plotMoranMC(sfe_tissue, qc_features) sfe_tissue <- colDataUnivariate(sfe_tissue, \"sp.correlogram\", qc_features,                                 order = 8) plotCorrelogram(sfe_tissue, qc_features) sfe_tissue <- colDataUnivariate(sfe_tissue, \"localmoran\", qc_features) plotLocalResult(sfe_tissue, \"localmoran\", qc_features, ncol = 2,                 colGeometryName = \"spotPoly\", divergent = TRUE,                  diverge_center = 0, image_id = \"lowres\", maxcell = 5e4) sfe_tissue <- colDataUnivariate(sfe_tissue, \"LOSH\", qc_features) plotLocalResult(sfe_tissue, \"LOSH\", qc_features, ncol = 2,                 colGeometryName = \"spotPoly\", image_id = \"lowres\", maxcell = 5e4) sfe_tissue <- colDataUnivariate(sfe_tissue, \"moran.plot\", qc_features) moranPlot(sfe_tissue, \"subsets_mito_percent\")"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"spatial-autocorrelation-of-gene-expression","dir":"Articles","previous_headings":"","what":"Spatial autocorrelation of gene expression","title":"Spatial analysis of 10X example Visium dataset","text":"Normalize data scran method, find highly variable genes Find Moranâ€™s highly variable genes:  vast majority genes positive Moranâ€™s . â€™ll find genes highest Moranâ€™s : can use gget info module gget package get additional information genes, descriptions, synonyms, transcripts collection reference databases including Ensembl, UniProt NCBI , showing gene descriptions NCBI: <<<<<<< HEAD Plot genes highest Moranâ€™s :  global Moranâ€™s seems tissue structure. genes negative Moranâ€™s might statistically significant: <<<<<<< HEAD   2000 highly variable genes 2000 tests, longer significant correcting multiple testing. global Moranâ€™s relate gene expression level?  Genes highly expressed overall tend higher Moranâ€™s .","code":"#clusters <- quickCluster(sfe_tissue) #sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters) #sfe_tissue <- sfe_tissue[, sizeFactors(sfe_tissue) > 0] sfe_tissue <- logNormCounts(sfe_tissue) dec <- modelGeneVar(sfe_tissue) hvgs <- getTopHVGs(dec, n = 2000) sfe_tissue <- runMoransI(sfe_tissue, features = hvgs, BPPARAM = MulticoreParam(2)) plotRowDataHistogram(sfe_tissue, \"moran_sample01\") #> Warning: Removed 30285 rows containing non-finite outside the scale range #> (`stat_bin()`). top_moran <- rownames(sfe_tissue)[order(rowData(sfe_tissue)$moran_sample01,                                          decreasing = TRUE)[1:9]] ======= >>>>>>> documentation gget_info <- gget$info(top_moran)  rownames(gget_info) <- gget_info$primary_gene_name select(gget_info, ncbi_description) plotSpatialFeature(sfe_tissue, top_moran, ncol = 3, image_id = \"lowres\",                    maxcell = 5e4, swap_rownames = \"symbol\") neg_moran <- rownames(sfe_tissue)[order(rowData(sfe_tissue)$moran_sample01,                                          decreasing = FALSE)[1:9]] ======= >>>>>>> documentation # Display NCBI descriptions for these genes gget_info_neg <- gget$info(neg_moran)  rownames(gget_info_neg) <- gget_info_neg$primary_gene_name select(gget_info_neg, ncbi_description) plotSpatialFeature(sfe_tissue, neg_moran, ncol = 3, swap_rownames = \"symbol\",                    image_id = \"lowres\", maxcell = 5e4) sfe_tissue <- runUnivariate(sfe_tissue, \"moran.mc\", neg_moran,                              colGraphName = \"visium\", nsim = 200, alternative = \"less\") plotMoranMC(sfe_tissue, neg_moran, swap_rownames = \"symbol\") rowData(sfe_tissue)[neg_moran, c(\"moran_sample01\", \"moran.mc_p.value_sample01\")] #> DataFrame with 9 rows and 2 columns #>                    moran_sample01 moran.mc_p.value_sample01 #>                         <numeric>                 <numeric> #> ENSMUSG00000041426     -0.0531915                0.00497512 #> ENSMUSG00000048277     -0.0451179                0.00497512 #> ENSMUSG00000021236     -0.0445148                0.01492537 #> ENSMUSG00000025241     -0.0419121                0.01492537 #> ENSMUSG00000026126     -0.0399917                0.00497512 #> ENSMUSG00000034342     -0.0393964                0.00995025 #> ENSMUSG00000047205     -0.0381599                0.00995025 #> ENSMUSG00000031431     -0.0369456                0.01492537 #> ENSMUSG00000037552     -0.0368969                0.01990050 sfe_tissue <- addPerFeatureQCMetrics(sfe_tissue) names(rowData(sfe_tissue)) #>  [1] \"symbol\"                                        #>  [2] \"Feature.Type\"                                  #>  [3] \"I_sample01\"                                    #>  [4] \"P.value_sample01\"                              #>  [5] \"Adjusted.p.value_sample01\"                     #>  [6] \"Feature.Counts.in.Spots.Under.Tissue_sample01\" #>  [7] \"Median.Normalized.Average.Counts_sample01\"     #>  [8] \"Barcodes.Detected.per.Feature_sample01\"        #>  [9] \"subsets_mito\"                                  #> [10] \"moran_sample01\"                                #> [11] \"K_sample01\"                                    #> [12] \"moran.mc_statistic_sample01\"                   #> [13] \"moran.mc_parameter_sample01\"                   #> [14] \"moran.mc_p.value_sample01\"                     #> [15] \"moran.mc_alternative_sample01\"                 #> [16] \"moran.mc_method_sample01\"                      #> [17] \"moran.mc_res_sample01\"                         #> [18] \"mean\"                                          #> [19] \"detected\" plotRowData(sfe_tissue, x = \"mean\", y = \"moran_sample01\") +     scale_x_log10() +     annotation_logticks(sides = \"b\") +     geom_density2d() #> Warning in scale_x_log10(): log-10 transformation introduced infinite values. #> log-10 transformation introduced infinite values. #> Warning: Removed 30285 rows containing non-finite outside the scale range #> (`stat_density2d()`). #> Warning: Removed 30285 rows containing missing values or values outside the scale range #> (`geom_point()`)."},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"apply-spatial-analysis-methods-to-gene-expression-space","dir":"Articles","previous_headings":"","what":"Apply spatial analysis methods to gene expression space","title":"Spatial analysis of 10X example Visium dataset","text":"Spatial statistics require spatial neighborhood graph can also applied k nearest neighbor graph histological space gene expression space. done depth vignette. store results â€œmoran_nsâ€, confused spatial Moranâ€™s results. genes tend similar neighbors 10 nearest neighbor graph PCA space gene expression rather histological space: <<<<<<< HEAD  Although Moranâ€™s computed histological space, genes highest Moranâ€™s PCA space also show spatial structure, different cell types reside different spatial regions.","code":"sfe_tissue <- runPCA(sfe_tissue, ncomponents = 30, subset_row = hvgs,                      scale = TRUE) # scale as in Seurat foo <- findKNN(reducedDim(sfe_tissue, \"PCA\")[,1:10], k=10, BNPARAM=AnnoyParam()) # Split by row foo_nb <- asplit(foo$index, 1) dmat <- 1/foo$distance # Row normalize the weights dmat <- sweep(dmat, 1, rowSums(dmat), FUN = \"/\") glist <- asplit(dmat, 1) # Sort based on index ord <- lapply(foo_nb, order) foo_nb <- lapply(seq_along(foo_nb), function(i) foo_nb[[i]][ord[[i]]]) class(foo_nb) <- \"nb\" glist <- lapply(seq_along(glist), function(i) glist[[i]][ord[[i]]])  listw <- list(style = \"W\",               neighbours = foo_nb,               weights = glist) class(listw) <- \"listw\" attr(listw, \"region.id\") <- colnames(sfe_tissue) colGraph(sfe_tissue, \"knn10\") <- listw sfe_tissue <- runMoransI(sfe_tissue, features = hvgs, BPPARAM = MulticoreParam(2),                          colGraphName = \"knn10\", name = \"moran_ns\") top_moran2 <- rownames(sfe_tissue)[order(rowData(sfe_tissue)$moran_ns_sample01,                                          decreasing = TRUE)[1:9]] ======= >>>>>>> documentation # Display NCBI descriptions for these genes gget_info2 <- gget$info(top_moran2)  rownames(gget_info2) <- gget_info2$primary_gene_name select(gget_info2, ncbi_description) plotSpatialFeature(sfe_tissue, top_moran2, ncol = 3, swap_rownames = \"symbol\",                    image_id = \"lowres\", maxcell = 5e4)"},{"path":"https://pachterlab.github.io/voyager/articles/visium_10x_spatial.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Spatial analysis of 10X example Visium dataset","text":"","code":"sessionInfo() #> R version 4.4.2 (2024-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] reticulate_1.40.0              BiocNeighbors_2.0.0            #>  [3] BiocParallel_1.40.0            dplyr_1.1.4                    #>  [5] rmapshaper_0.5.0               sf_1.0-19                      #>  [7] rlang_1.1.4                    terra_1.7-83                   #>  [9] EBImage_4.48.0                 rjson_0.2.23                   #> [11] bluster_1.16.0                 patchwork_1.3.0                #> [13] stringr_1.5.1                  scran_1.34.0                   #> [15] scater_1.34.0                  scuttle_1.16.0                 #> [17] ggplot2_3.5.1                  SingleCellExperiment_1.28.1    #> [19] SummarizedExperiment_1.36.0    Biobase_2.66.0                 #> [21] GenomicRanges_1.58.0           GenomeInfoDb_1.42.0            #> [23] IRanges_2.40.0                 S4Vectors_0.44.0               #> [25] BiocGenerics_0.52.0            MatrixGenerics_1.18.0          #> [27] matrixStats_1.4.1              Voyager_1.8.1                  #> [29] SpatialFeatureExperiment_1.9.4 #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.4.2             bitops_1.0-9              #>   [3] tibble_3.2.1              R.oo_1.27.0               #>   [5] lifecycle_1.0.4           edgeR_4.4.0               #>   [7] lattice_0.22-6            MASS_7.3-61               #>   [9] magrittr_2.0.3            limma_3.62.1              #>  [11] sass_0.4.9                rmarkdown_2.29            #>  [13] jquerylib_0.1.4           yaml_2.3.10               #>  [15] metapod_1.14.0            sp_2.1-4                  #>  [17] cowplot_1.1.3             DBI_1.2.3                 #>  [19] RColorBrewer_1.1-3        multcomp_1.4-26           #>  [21] abind_1.4-8               spatialreg_1.3-5          #>  [23] zlibbioc_1.52.0           R.utils_2.12.3            #>  [25] RCurl_1.98-1.16           TH.data_1.1-2             #>  [27] sandwich_3.1-1            GenomeInfoDbData_1.2.13   #>  [29] ggrepel_0.9.6             irlba_2.3.5.1             #>  [31] units_0.8-5               RSpectra_0.16-2           #>  [33] dqrng_0.4.1               pkgdown_2.1.1             #>  [35] DelayedMatrixStats_1.28.0 codetools_0.2-20          #>  [37] DropletUtils_1.26.0       DelayedArray_0.32.0       #>  [39] tidyselect_1.2.1          UCSC.utils_1.2.0          #>  [41] memuse_4.2-3              farver_2.1.2              #>  [43] ScaledMatrix_1.14.0       viridis_0.6.5             #>  [45] jsonlite_1.8.9            geojsonsf_2.0.3           #>  [47] e1071_1.7-16              survival_3.7-0            #>  [49] systemfonts_1.1.0         dbscan_1.2-0              #>  [51] tools_4.4.2               ggnewscale_0.5.0          #>  [53] ragg_1.3.3                Rcpp_1.0.13-1             #>  [55] glue_1.8.0                gridExtra_2.3             #>  [57] SparseArray_1.6.0         mgcv_1.9-1                #>  [59] xfun_0.49                 HDF5Array_1.34.0          #>  [61] withr_3.0.2               fastmap_1.2.0             #>  [63] boot_1.3-31               rhdf5filters_1.18.0       #>  [65] fansi_1.0.6               spData_2.3.3              #>  [67] digest_0.6.37             rsvd_1.0.5                #>  [69] R6_2.5.1                  textshaping_0.4.0         #>  [71] colorspace_2.1-1          wk_0.9.4                  #>  [73] LearnBayes_2.15.1         jpeg_0.1-10               #>  [75] R.methodsS3_1.8.2         utf8_1.2.4                #>  [77] generics_0.1.3            data.table_1.16.2         #>  [79] class_7.3-22              httr_1.4.7                #>  [81] htmlwidgets_1.6.4         S4Arrays_1.6.0            #>  [83] spdep_1.3-6               pkgconfig_2.0.3           #>  [85] scico_1.5.0               gtable_0.3.6              #>  [87] XVector_0.46.0            htmltools_0.5.8.1         #>  [89] fftwtools_0.9-11          scales_1.3.0              #>  [91] png_0.1-8                 SpatialExperiment_1.16.0  #>  [93] knitr_1.49                coda_0.19-4.1             #>  [95] nlme_3.1-166              curl_6.0.1                #>  [97] proxy_0.4-27              cachem_1.1.0              #>  [99] zoo_1.8-12                rhdf5_2.50.0              #> [101] KernSmooth_2.23-24        parallel_4.4.2            #> [103] vipor_0.4.7               desc_1.4.3                #> [105] s2_1.1.7                  pillar_1.9.0              #> [107] grid_4.4.2                vctrs_0.6.5               #> [109] BiocSingular_1.22.0       beachmat_2.22.0           #> [111] sfheaders_0.4.4           cluster_2.1.6             #> [113] beeswarm_0.4.0            evaluate_1.0.1            #> [115] isoband_0.2.7             zeallot_0.1.0             #> [117] magick_2.8.5              mvtnorm_1.3-2             #> [119] cli_3.6.3                 locfit_1.5-9.10           #> [121] compiler_4.4.2            crayon_1.5.3              #> [123] labeling_0.4.3            classInt_0.4-10           #> [125] fs_1.6.5                  ggbeeswarm_0.7.2          #> [127] stringi_1.8.4             viridisLite_0.4.2         #> [129] deldir_2.0-4              munsell_0.5.1             #> [131] tiff_0.1-12               V8_6.0.0                  #> [133] Matrix_1.7-1              sparseMatrixStats_1.18.0  #> [135] Rhdf5lib_1.28.0           statmod_1.5.0             #> [137] igraph_2.1.1              bslib_0.8.0"},{"path":"https://pachterlab.github.io/voyager/articles/visium_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"Visium Processing Workflows with Voyager","text":"Pros: Commercial kit Provided many core facilities widely available spatial transcriptomics technologies Transcriptome wide Formalin fixed, paraffin embedded (FFPE) tissue compatible Can panel proteins addition RNA Accompanied H&E fluorescent images tissue morphology lower resolution, data size manageable larger tissue areas larger number samples Cons: Lower resolution â€“ 55 Î¼\\mum spot diameter 100 Î¼\\mum center center Relatively low detection efficiency transcripts full length, protocol adapted long read sequencing","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/articles/visium_landing.html","id":"dowload-data-and-create-a-spatialfeatureexperiment-object","dir":"Articles","previous_headings":"Getting Started","what":"Dowload Data and Create a SpatialFeatureExperiment object","title":"Visium Processing Workflows with Voyager","text":"Several publicly available Visium datasets available 10X Genomics website. vignettes provide examples processing raw data using workflow includes seqspec, gget, kallisto/bustools generate count matrix demonstrate read output typical Visium experiment SpatialFeatureExperiment object.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/visium_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"Visium Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using variety Visium datasets. analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked available.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/xenium_landing.html","id":"pros-and-cons","dir":"Articles","previous_headings":"","what":"Pros and cons","title":"Xenium Processing Workflows with Voyager","text":"Pros: Commercial kit Single cell resolution High detection efficiency Formalin fixed, paraffin embedded (FFPE) tissue compatible Provides subcellular transcript localization information Compatible H&E immunofluorescence Cons: curated panel usually hundred genes required. However, 10X provides curated gene panels common applications oncology, neuroscience, development, well panel design services. Data size harder manage larger tissue areas number samples. spatial analysis methods can scale hundreds thousands millions cells.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/xenium_landing.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Xenium Processing Workflows with Voyager","text":"10x Genomics publicly released Xenium human breast cancer dataset website. tutorial processing output various spatial transcriptomics technologies SpatialFeatureExperiment(SFE) object use Voyager Getting Started page. output files format Xenium data may change technology developed released.","code":""},{"path":"https://pachterlab.github.io/voyager/articles/xenium_landing.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis Workflows","title":"Xenium Processing Workflows with Voyager","text":"vignettes demonstrate workflows can implemented Voyager using variety Visium datasets. analysis tasks include basic quality control, spatial exploratory data analysis, identification spatially variable genes, computation global local spatial statistics. Accompanying Colab notebooks linked available.","code":""},{"path":"https://pachterlab.github.io/voyager/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lambda Moses. Author, maintainer. Alik Huseynov. Author. Kayla Jackson. Author. Laura Luebbert. Author. Sina Booeshaghi. Author. Lior Pachter. Author, reviewer.","code":""},{"path":"https://pachterlab.github.io/voyager/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Moses L, Einarsson PH, Jackson K, Luebbert L, Booeshaghi S, Antonsson S, Melsted P, Pachter L (2023). â€œVoyager: exploratory single-cell genomics data analysis geospatial statistics.â€ bioRxiv. doi:10.1101/2023.07.20.549945.","code":"@Article{,   title = {Voyager: exploratory single-cell genomics data analysis with geospatial statistics},   author = {Lambda Moses and PÃ©tur Helgi Einarsson and Kayla Jackson and Laura Luebbert and Sina Booeshaghi and Sindri Antonsson and PÃ¡ll Melsted and Lior Pachter},   journal = {bioRxiv},   year = {2023},   doi = {10.1101/2023.07.20.549945}, }"},{"path":"https://pachterlab.github.io/voyager/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"From geospatial to spatial omics","text":"SpatialFeatureExperiment Voyager can installed Bioconductor version 3.16 higher:","code":"if (!requireNamespace(\"BiocManager\")) install.packages(\"BiocManager\") BiocManager::install(version = \"3.17\") # Or a higher version in the future BiocManager::install(\"Voyager\")"},{"path":"https://pachterlab.github.io/voyager/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"From geospatial to spatial omics","text":"Voyager: exploratory single-cell genomics data analysis geospatial statistics Lambda Moses, PÃ©tur Helgi Einarsson, Kayla Jackson, Laura Luebbert, . Sina Booeshaghi, Sindri Antonsson, PÃ¡ll Melsted, Lior Pachter bioRxiv 2023.07.20.549945; doi: https://doi.org/10.1101/2023.07.20.549945  Bioconductor :","code":"BiocManager::install(\"Voyager\", version = \"devel\")"},{"path":"https://pachterlab.github.io/voyager/index.html","id":"for-contributors","dir":"","previous_headings":"","what":"For contributors","title":"From geospatial to spatial omics","text":"whole git repo package huge large number figures Jupyter notebooks documentation website. reduce download time disk space usage, may clone devel branch , documentation branches cloned:","code":"git clone -b devel --single-branch https://github.com/pachterlab/voyager.git"},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","title":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","text":"Apparently, apparent way plot PC elbow plot extracting variance explained attribute dimred slot, even OSCA book makes elbow plot way, find kind cumbersome compared Seurat. writing function make elbow plot SCE less cumbersome.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","text":"","code":"ElbowPlot(   sce,   ndims = 20,   nfnega = 0,   reduction = \"PCA\",   sample_id = \"all\",   facet = FALSE,   ncol = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","text":"sce SingleCellExperiment object, anything inherits SingleCellExperiment. ndims Number components positive eigenvalues, PCs non-spatial PCA. nfnega Number nega eigenvalues eigenvectors compute. indicate negative spatial autocorrelation. reduction Name dimension reduction use. must attribute called either \"percentVar\" \"eig\" eigenvalues. Defaults \"PCA\". sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. facet Logical, whether facet samples multiple samples present. relevant spatial PCA run separately sample, gives different results running jointly samples. ncol Number columns facets facetting.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","text":"ggplot object. y axis eigenvalues percentage variance   explained relevant.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ElbowPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the elbow plot or scree plot for PCA â€” ElbowPlot","text":"","code":"library(SFEData) library(scater) #> Loading required package: SingleCellExperiment #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: â€˜MatrixGenericsâ€™ #> The following objects are masked from â€˜package:matrixStatsâ€™: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: â€˜BiocGenericsâ€™ #> The following object is masked from â€˜package:SpatialFeatureExperimentâ€™: #>  #>     saveRDS #> The following objects are masked from â€˜package:statsâ€™: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from â€˜package:baseâ€™: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, saveRDS, setdiff, table, #>     tapply, union, unique, unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: â€˜S4Vectorsâ€™ #> The following object is masked from â€˜package:utilsâ€™: #>  #>     findMatches #> The following objects are masked from â€˜package:baseâ€™: #>  #>     I, expand.grid, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: â€˜Biobaseâ€™ #> The following object is masked from â€˜package:MatrixGenericsâ€™: #>  #>     rowMedians #> The following objects are masked from â€˜package:matrixStatsâ€™: #>  #>     anyMissing, rowMedians #> Loading required package: scuttle #> Loading required package: ggplot2 #>  #> Attaching package: â€˜ggplot2â€™ #> The following object is masked from â€˜package:SpatialFeatureExperimentâ€™: #>  #>     unit sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache sfe <- runPCA(sfe, ncomponents = 10, exprs_values = \"counts\") ElbowPlot(sfe, ndims = 10)"},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":null,"dir":"Reference","previous_headings":"","what":"SFEMethod class â€” SFEMethod","title":"SFEMethod class â€” SFEMethod","text":"S4 class used wrap spatial analysis methods, taking inspiration caret tidymodels packages.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SFEMethod class â€” SFEMethod","text":"","code":"SFEMethod(   name,   fun,   reorganize_fun,   package,   variate = c(\"uni\", \"bi\", \"multi\"),   scope = c(\"global\", \"local\"),   title = NULL,   default_attr = NA,   args_not_check = NA,   joint = FALSE,   use_graph = TRUE,   use_matrix = FALSE,   dest = c(\"reducedDim\", \"colData\") )  # S4 method for class 'SFEMethod' info(x, type)  # S4 method for class 'SFEMethod' is_local(x)  # S4 method for class 'SFEMethod' fun(x)  # S4 method for class 'SFEMethod' reorganize_fun(x)  # S4 method for class 'SFEMethod' args_not_check(x)  # S4 method for class 'SFEMethod' is_joint(x)  # S4 method for class 'SFEMethod' use_graph(x)  # S4 method for class 'SFEMethod' use_matrix(x)"},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SFEMethod class â€” SFEMethod","text":"name Name method, used user-facing functions specify method use, \"moran\" Moran's . fun Function run method. See Details. reorganize_fun Function reorganize results add SFE object. See Details. package Name package whose implementation method used , used check package installed. variate many variables method works , must one \"uni\" univariate, \"bi\" bivariate, \"multi\" multivariate. scope Either \"global\", returning one result entire dataset, \"local\", returning one result spatial location. multivariate methods, irrelevant. title Descriptive title show plotting results. default_attr local methods return multiple fields, local Moran values p-values, default field use plotting. args_not_check character vector indicating argument checked comparing parameters previous run. joint Logical, whether makes sense run method multiple samples jointly. TRUE, fun must able handle adjacency matrix listw argument straightforward way concatenate listw objects multiple samples. use_graph Logical, indicate whether method uses spatial neighborhood graph unifying user facing functions argument asking graph though methods require graph. use_matrix Logical, whether function slot fun takes matrix input. argument used bivariate methods. dest Whether results appropriate reducedDim colData. used multivariate methods. overrides \"local\" field info. x SFEMethod object type One names info slot, see slot documentation.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SFEMethod class â€” SFEMethod","text":"constructor returns SFEMethod object. getters return   content corresponding slots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SFEMethod class â€” SFEMethod","text":"fun slot specified : methods, must arguments x vector, listw listw object specifying spatial neighborhood graph, zero.policy specifying cells without neighbors (default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA), optionally method specific arguments ... pass underlying imported function. original function implementing method package different argument names orders, write thin wrapper rearrange /rename arguments. univariate methods use spatial neighborhood graph, first two arguments must x listw. univariate methods use spatial neighborhood graph, variogram, first two arguments must x numeric vector coords_df sf data frame cell locations optionally regressors. formula argument optional can defaults specifying regressors use. bivariate methods, first three arguments must x, y, listw. multivariate methods, argument x mandatory, matrix input. arguments must present can optional defaults: listw ncomponents set number dimentions output. reorganize_fun slot specified : Univariate methods meant run separately gene, input reorganize_fun argument list outputs; element list corresponds output gene. univariate global methods, different fields result columns data frame one row results multiple features data frame. arguments , name rename primary field informative name needed, ... arguments specific methods. output reorganize_fun DataFrame whose rows correspond genes columns correspond fields output. univariate local methods, arguments , nb neighborhood list used multiple testing correction, p.adjust.method method correct multiple testing p.adjust, .... output reorganize_fun list reorganized output. element list corresponds gene, reorganized content element can vector, matrix, data frame, must dimensions genes. element vector, row matrix data frame corresponds cell. multivariate methods whose results go reducedDim, reorganize_fun one argument raw output. output reorganize_fun cell embedding matrix ready added reducedDim. relevant information gene loadings eigenvalues added attributes cell embedding matrix. multivariate methods whose results can go colData, arguments , nb, p.adjust.method. Unlike univariate local counterpart, takes raw output instead list outputs. output reorganize_fun vector data frame ready added colData.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"SFEMethod class â€” SFEMethod","text":"info named character vector specifying information method. fun function implementing method. See Details. reorganize_fun Function convert output fun format store SFE object. See Details. misc Miscellaneous information method interacts rest package. named list.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/SFEMethod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SFEMethod class â€” SFEMethod","text":"","code":"moran <- SFEMethod( name = \"moran\", title = \"Moran's I\", package = \"spdep\", variate = \"uni\", scope = \"global\", fun = function(x, listw, zero.policy = NULL)     spdep::moran(x, listw, n = length(listw$neighbours), S0 = spdep::Szero(listw),                  zero.policy = zero.policy), reorganize_fun = Voyager:::.moran2df )"},{"path":"https://pachterlab.github.io/voyager/reference/calculateBivariate.html","id":null,"dir":"Reference","previous_headings":"","what":"Bivariate spatial statistics â€” calculateBivariate","title":"Bivariate spatial statistics â€” calculateBivariate","text":"functions perform bivariate spatial analysis. version, bivariate global method supported lee, lee.mc, lee.test spdep, cross variograms gstat (use cross_variogram cross_variogram_map type argument, see variogram-internal). Global Lee statistic computed implementation much faster spdep. Bivariate local methods supported lee (use locallee type argument) localmoran_bv bivariate version Local Moran spdep.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateBivariate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bivariate spatial statistics â€” calculateBivariate","text":"","code":"# S4 method for class 'ANY' calculateBivariate(   x,   y = NULL,   type,   listw = NULL,   coords_df = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   p.adjust.method = \"BH\",   name = NULL,   ... )  # S4 method for class 'SpatialFeatureExperiment' calculateBivariate(   x,   type,   feature1,   feature2 = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   p.adjust.method = \"BH\",   swap_rownames = NULL,   name = NULL,   ... )  runBivariate(   x,   type,   feature1,   feature2 = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   swap_rownames = NULL,   zero.policy = NULL,   p.adjust.method = \"BH\",   name = NULL,   overwrite = FALSE,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/calculateBivariate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bivariate spatial statistics â€” calculateBivariate","text":"x numeric matrix whose rows features/genes, numeric vector (y must specified), SpatialFeatureExperiment (SFE) object matrix assay. y numeric matrix whose rows features/genes, numeric vector. Bivariate statics computed pairwise combinations row names x row names y, except cross variogram combinations within x y also computed. type SFEMethod object, string matching name SFEMethod object. methods mentioned correspond SFEMethod objects already implemented Voyager package. Use listSFEMethods see methods available. can implement new SFEMethod objects apply Voyager functions spatial analysis methods. part inspired caret, parsnip, BiocSingular packages. listw Weighted neighborhood graph spdep listw object. used method specified type use spatial neighborhood graph, variogram. coords_df sf data frame specifying location cell. used method specified type uses spatial neighborhood graph. Must specified otherwise. BPPARAM BiocParallelParam object specifying whether computing metric numerous genes shall parallelized. zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA returnDF Logical, results added SFE object, whether results formatted DataFrame. p.adjust.method Method correct multiple testing, passed p.adjustSP. Methods allowed p.adjust.methods. name Name use store results, defaults name SFEMethod object passed argument type. Can set distinguish results method different parameters. ... arguments passed S4 method (convenience wrappers like calculateMoransI) method used compute metrics specified argument type (general functions like calculateUnivariate). See documentation functions name specified type spdep package method specific arguments. variograms, see .variogram. feature1 ID symbol first genes SFE object, argument x. feature2 ID symbol second genes SFE object, argument x. Mandatory length feature1 1. colGraphName Name listw graph SFE object corresponds entities represented columns gene count matrix. Use colGraphNames look names available graphs cells/spots. Note multiple sample_ids, assumed graph name. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. SFE method calculateUnivariate, specify location cells methods take spatial neighborhood graph variogram. geometry type POINT, spatialCoords(x) used instead. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. exprs_values Integer scalar string indicating assay x contains expression values. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. overwrite Logical, whether overwrite existing results name. Defaults FALSE.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateBivariate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bivariate spatial statistics â€” calculateBivariate","text":"calculateBivariate function returns correlation matrix   global Lee, results pair genes   methods. Global results stored SFE object. methods   return one result pair genes, return pairwise   results 2 genes jointly. Local results stored   localResults field SFE object, name   concatenation two gene names separated two underscores (__).","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateBivariate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bivariate spatial statistics â€” calculateBivariate","text":"","code":"library(SFEData) library(scater) library(scran) library(SpatialFeatureExperiment) library(SpatialExperiment) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache sfe <- sfe[,sfe$in_tissue] sfe <- logNormCounts(sfe) gs <- modelGeneVar(sfe) hvgs <- getTopHVGs(gs, fdr.threshold = 0.01) g <- colGraph(sfe, \"visium\") <- findVisiumGraph(sfe)  # Matrix method mat <- logcounts(sfe)[hvgs[1:5],] df <- df2sf(spatialCoords(sfe), spatialCoordsNames(sfe)) out <- calculateBivariate(mat, type = \"lee\", listw = g) #> Warning: `listw2sparse()` was deprecated in SpatialFeatureExperiment 1.9.0. #> â„¹ Please use `spatialreg::as_dgRMatrix_listw()` instead. #> â„¹ The deprecated feature was likely used in the Voyager package. #>   Please report the issue at <https://github.com/pachterlab/voyager/issues>. out <- calculateBivariate(mat, type = \"cross_variogram\", coords_df = df)  # SFE method out <- calculateBivariate(sfe, type = \"lee\", feature1 = c(\"Myh1\", \"Myh2\", \"Csrp3\"), swap_rownames = \"symbol\") out2 <- calculateBivariate(sfe, type = \"lee.test\", feature1 = \"Myh1\", feature2 = \"Myh2\", swap_rownames = \"symbol\") sfe <- runBivariate(sfe, type = \"locallee\", feature1 = \"Myh1\", feature2 = \"Myh2\", swap_rownames = \"symbol\")"},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate spatial data analysis â€” calculateMultivariate","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"functions perform multivariate spatial data analysis, usually spatially informed dimension reduction.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"","code":"# S4 method for class 'ANY,SFEMethod' calculateMultivariate(   x,   type,   listw = NULL,   transposed = FALSE,   zero.policy = TRUE,   p.adjust.method = \"BH\",   ... )  # S4 method for class 'ANY,character' calculateMultivariate(x, type, listw = NULL, transposed = FALSE, ...)  # S4 method for class 'SpatialFeatureExperiment,ANY' calculateMultivariate(   x,   type,   colGraphName = 1L,   subset_row = NULL,   exprs_values = \"logcounts\",   sample_action = c(\"joint\", \"separate\"),   BPPARAM = SerialParam(),   ... )  runMultivariate(   x,   type,   colGraphName = 1L,   subset_row = NULL,   exprs_values = \"logcounts\",   sample_action = c(\"joint\", \"separate\"),   BPPARAM = SerialParam(),   name = NULL,   dest = c(\"reducedDim\", \"colData\"),   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"x numeric matrix whose rows features/genes, SpatialFeatureExperiment (SFE) object matrix assay. type SFEMethod object, string matching name SFEMethod object. methods mentioned correspond SFEMethod objects already implemented Voyager package. Use listSFEMethods see methods available. can implement new SFEMethod objects apply Voyager functions spatial analysis methods. part inspired caret, parsnip, BiocSingular packages. listw Weighted neighborhood graph spdep listw object. used method specified type use spatial neighborhood graph, variogram. transposed Logical, whether matrix genes columns cells rows. zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA p.adjust.method Method correct multiple testing, passed p.adjustSP. Methods allowed p.adjust.methods. ... Extra arguments passed specific multivariate method. example, see multispati_rsp arguments MULTISPATI PCA. See localC arguments \"localC_multi\" \"localC_perm_multi\". colGraphName Name listw graph SFE object corresponds entities represented columns gene count matrix. Use colGraphNames look names available graphs cells/spots. Note multiple sample_ids, assumed graph name. subset_row Vector specifying subset features use dimensionality reduction. can character vector row names, integer vector row indices logical vector. exprs_values Integer scalar string indicating assay x contains expression values. sample_action Character, either \"joint\" \"separate\". Spatial methods depend spatial coordinates /spatial neighborhood graph, SpatialExperiment uses sample_id keep coordinates different samples separate. spatial methods can sensibly run jointly multiple samples. case, \"joint\" run method jointly samples, \"separate\" run method separately sample concatenate results. BPPARAM BiocParallelParam object specifying whether computing metric numerous genes shall parallelized. parallelize computation across multiple samples large number samples. cautious using optimized BLAS matrix operations supports multithreading. name Name use store results, defaults name SFEMethod object passed argument type. Can set distinguish results method different parameters. dest Character, either \"reducedDim\" \"colData\". output multivariate method matrix array, spatially informed dimension reduction, option \"reducedDim\", results stored reducedDim SFE object. output vector, multivariate version localC, sotred colData. Data frame output, localC_perm, can stored either reducedDim colData.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"calculateMultivariate, matrix cell embeddings whose   attributes include loadings eigenvalues relevant, ready added   SFE object reducedDim setter. run*,   SpatialFeatureExperiment object results added. See Details   results stored.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"argument type, package supports \"multispati\" MULTISPATI PCA, \"localC_multi\" multivariate generalization Geary's C, \"localC_perm_multi\" multivariate Geary's C permutation testing, \"gwpca\" geographically weighted PCA.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"Dray, S., Said, S. Debias, F. (2008) Spatial ordination vegetation data using generalization Wartenberg's multivariate spatial correlation. Journal vegetation science, 19, 45-56. Anselin, L. (2019), Local Indicator Multivariate Spatial Association: Extending Geary's c. Geogr Anal, 51: 133-150. doi:10.1111/gean.12164","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateMultivariate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate spatial data analysis â€” calculateMultivariate","text":"","code":"# example code library(SFEData) library(scater) library(scran) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) gvs <- modelGeneVar(sfe) hvgs <- getTopHVGs(gvs, fdr.threshold = 0.05) colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) sfe <- runMultivariate(sfe, \"multispati\", subset_row = hvgs)"},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate spatial stiatistics â€” calculateUnivariate","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"functions compute univariate spatial statistics, global local, matrices, data frames, SFE objects. SFE objects, statistics can computed numeric columns colData, colGeometries, annotGeometries, results stored within SFE object. calculateMoransI runMoransI convenience wrappers calculateUnivariate runUnivariate respectively.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"","code":"# S4 method for class 'ANY,SFEMethod' calculateUnivariate(   x,   type,   listw = NULL,   coords_df = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   p.adjust.method = \"BH\",   name = NULL,   ... )  # S4 method for class 'ANY,character' calculateUnivariate(   x,   type,   listw = NULL,   coords_df = NULL,   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   p.adjust.method = \"BH\",   name = NULL,   ... )  # S4 method for class 'SpatialFeatureExperiment,ANY' calculateUnivariate(   x,   type,   features = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   include_self = FALSE,   p.adjust.method = \"BH\",   swap_rownames = NULL,   name = NULL,   ... )  # S4 method for class 'ANY' calculateMoransI(   x,   ...,   BPPARAM = SerialParam(),   zero.policy = NULL,   name = \"moran\" )  # S4 method for class 'SpatialFeatureExperiment' calculateMoransI(   x,   features = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   zero.policy = NULL,   returnDF = TRUE,   include_self = FALSE,   p.adjust.method = \"BH\",   swap_rownames = NULL,   name = NULL,   ... )  colDataUnivariate(   x,   type,   features,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  colDataMoransI(   x,   features,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  colGeometryUnivariate(   x,   type,   features,   colGeometryName = 1L,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  colGeometryMoransI(   x,   features,   colGeometryName = 1L,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  annotGeometryUnivariate(   x,   type,   features,   annotGeometryName = 1L,   annotGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  annotGeometryMoransI(   x,   features,   annotGeometryName = 1L,   annotGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  runUnivariate(   x,   type,   features = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   swap_rownames = NULL,   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   overwrite = FALSE,   ... )  runMoransI(   x,   features = NULL,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   exprs_values = \"logcounts\",   BPPARAM = SerialParam(),   swap_rownames = NULL,   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  reducedDimUnivariate(   x,   type,   dimred = 1L,   components = 1L,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )  reducedDimMoransI(   x,   dimred = 1L,   components = 1L,   colGraphName = 1L,   sample_id = \"all\",   BPPARAM = SerialParam(),   zero.policy = NULL,   include_self = FALSE,   p.adjust.method = \"BH\",   name = NULL,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"x numeric matrix whose rows features/genes, SpatialFeatureExperiment (SFE) object matrix assay. type SFEMethod object, string matching name SFEMethod object. methods mentioned correspond SFEMethod objects already implemented Voyager package. Use listSFEMethods see methods available. can implement new SFEMethod objects apply Voyager functions spatial analysis methods. part inspired caret, parsnip, BiocSingular packages. listw Weighted neighborhood graph spdep listw object. used method specified type use spatial neighborhood graph, variogram. coords_df sf data frame specifying location cell. used method specified type uses spatial neighborhood graph. Must specified otherwise. BPPARAM BiocParallelParam object specifying whether computing metric numerous genes shall parallelized. zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA returnDF Logical, results added SFE object, whether results formatted DataFrame. p.adjust.method Method correct multiple testing, passed p.adjustSP. Methods allowed p.adjust.methods. name Name use store results, defaults name SFEMethod object passed argument type. Can set distinguish results method different parameters. ... arguments passed S4 method (convenience wrappers like calculateMoransI) method used compute metrics specified argument type (general functions like calculateUnivariate). See documentation functions name specified type spdep package method specific arguments. variograms, see .variogram. features Genes (calculate* SFE method run*) numeric columns colData(x) (colData*) colGeometry (colGeometry*) annotGeometry (annotGeometry*) univariate metric computed. Default NULL. NULL, metric computed genes values assay specified argument exprs_values. can parallelized argument BPPARAM. genes, row names SFE object Ensembl IDs, gene symbol can used converted IDs behind scene column rowData can specified swap_rownames. However, one symbol matches multiple IDs, warning given first match used. Internally, results always stored Ensembl ID rather symbol. colGraphName Name listw graph SFE object corresponds entities represented columns gene count matrix. Use colGraphNames look names available graphs cells/spots. Note multiple sample_ids, assumed graph name. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. SFE method calculateUnivariate, specify location cells methods take spatial neighborhood graph variogram. geometry type POINT, spatialCoords(x) used instead. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. exprs_values Integer scalar string indicating assay x contains expression values. include_self Logical, whether spatial neighborhood graph include edges location . Getis-Ord Gi* localG localG_perm, used method. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. annotGeometryName Name annotGeometry sf data frame whose numeric columns interest used compute metric. Use annotGeometryNames look names sf data frames associated annotations. annotGraphName Name listw graph SFE object corresponds annotGeometry interest. Use annotGraphNames look names available annotation graphs. overwrite Logical, whether overwrite existing results name. Defaults FALSE. dimred Name dimension reduction, can seen reducedDimNames. components Numeric vector components dimension reduction compute spatial statistics .","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"calculateUnivariate, returnDF = TRUE,   DataFrame, otherwise list element results   feature. run*, SpatialFeatureExperiment object   results added. See Details results stored.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"univariate methods package spdep supported . methods global, meaning returning one result spatial locations dataset: moran, geary, moran.mc, geary.mc, moran.test, geary.test, globalG.test, sp.correlogram. variogram variogram map gstat package also supported. following methods local, meaning location results: moran.plot, localmoran, localmoran_perm, localC, localC_perm, localG, localG_perm, LOSH, LOSH.mc, LOSH.cs. GWmodel::gwss method supported soon, supported yet. Global results genes stored rowData. colGeometry annotGeometry, results added attribute data frame called featureData, DataFrame analogous rowData gene count matrix, can accessed geometryFeatureData function. New column names featureData follow rules rowData. colData, results can accessed colFeatureData function. Local results stored field localResults field SFE object, can accessed localResults localResult. results p-values, -log10 p adjusted -log10 p added. Note multiple testing correction, p.adjustSP used. results stored SFE object, parameters used compute results well construct spatial neighborhood graph also added. localResults, parameters added metadata field params localResults sorted name, defaults name SFEMethod object specified type argument. global methods, parameters results genes metadata rowData(x), organized name (metadata(rowData(x))$params[[name]]). colData, global method parameters stored metadata colData field params (metadata(colData(x))$params[[name]]). geometries, global method parameters attribute named \"params\" corresponding sf data frame (attr(df, \"params\")[[name]]).","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 17. Anselin, L. (1995), Local Indicators Spatial Association-LISA.   Geographical Analysis, 27: 93-115. doi:10.1111/j.1538-4632.1995.tb00338.x Ord, J. K., & Getis, . 2012. Local spatial heteroscedasticity (LOSH),   Annals Regional Science, 48 (2), 529-539. Ord, J. K. Getis, . 1995 Local spatial autocorrelation statistics:   distributional issues application. Geographical Analysis, 27,   286-306","code":""},{"path":"https://pachterlab.github.io/voyager/reference/calculateUnivariate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate spatial stiatistics â€” calculateUnivariate","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) features_use <- rownames(sfe)[1:5]  # Moran's I moran_results <- calculateMoransI(sfe,     features = features_use,     colGraphName = \"visium\",     exprs_values = \"counts\" )  # This does not advocate for computing Moran's I on raw counts. # Just an example for function usage.  sfe <- runMoransI(sfe,     features = features_use, colGraphName = \"visium\",     exprs_values = \"counts\" ) # Look at the results head(rowData(sfe)) #> DataFrame with 6 rows and 8 columns #>                               Ensembl      symbol            type       means #>                           <character> <character>     <character>   <numeric> #> ENSMUSG00000025902 ENSMUSG00000025902       Sox17 Gene Expression 0.007612179 #> ENSMUSG00000096126 ENSMUSG00000096126     Gm22307 Gene Expression 0.000200321 #> ENSMUSG00000033845 ENSMUSG00000033845      Mrpl15 Gene Expression 0.075921474 #> ENSMUSG00000025903 ENSMUSG00000025903      Lypla1 Gene Expression 0.057491987 #> ENSMUSG00000033813 ENSMUSG00000033813       Tcea1 Gene Expression 0.052283654 #> ENSMUSG00000002459 ENSMUSG00000002459       Rgs20 Gene Expression 0.000200321 #>                           vars       cv2 moran_Vis5A   K_Vis5A #>                      <numeric> <numeric>   <numeric> <numeric> #> ENSMUSG00000025902 0.008757912  151.1411  -0.0424335  13.32749 #> ENSMUSG00000096126 0.000200321 4992.0000         NaN       NaN #> ENSMUSG00000033845 0.114250804   19.8212   0.2485804   5.41594 #> ENSMUSG00000025903 0.080645121   24.3985   0.0070062   9.46309 #> ENSMUSG00000033813 0.073603279   26.9256   0.1592157   8.51384 #> ENSMUSG00000002459 0.000200321 4992.0000          NA        NA  # Local Moran's I sfe <- runUnivariate(sfe,     type = \"localmoran\", features = features_use,     colGraphName = \"visium\", exprs_values = \"counts\" ) head(localResult(sfe, \"localmoran\", features_use[1])) #>                           Ii         E.Ii     Var.Ii       Z.Ii Pr(z != E(Ii)) #> AAATTACCTATCGATG -0.02897069 -0.001345388 0.01609308 -0.2177647     0.82761246 #> AACATATCAACTGGTG -0.29141104 -0.001345388 0.01609308 -2.2865292     0.02222332 #> AAGATTGGCGGAACGT  0.10224949 -0.001345388 0.01958757  0.7401981     0.45917982 #> AAGGGACAGATTCTGT -0.02897069 -0.001345388 0.01609308 -0.2177647     0.82761246 #> AATATCGAGGGTTCTC  0.10224949 -0.001345388 0.01609308  0.8166176     0.41414701 #> AATGATGATACGCTAT  0.10224949 -0.001345388 0.01609308  0.8166176     0.41414701 #>                      mean   median    pysal    -log10p -log10p_adj #> AAATTACCTATCGATG Low-High Low-High Low-High 0.08217298   0.0000000 #> AACATATCAACTGGTG Low-High Low-High Low-High 1.65319110   0.8080931 #> AAGATTGGCGGAACGT  Low-Low  Low-Low  Low-Low 0.33801720   0.0000000 #> AAGGGACAGATTCTGT Low-High Low-High Low-High 0.08217298   0.0000000 #> AATATCGAGGGTTCTC  Low-Low  Low-Low  Low-Low 0.38284547   0.0000000 #> AATGATGATACGCTAT  Low-Low  Low-Low  Low-Low 0.38284547   0.0000000  # For colData sfe <- colDataUnivariate(sfe,     type = \"localmoran\", features = \"nCounts\",     colGraphName = \"visium\" ) head(localResult(sfe, \"localmoran\", \"nCounts\")) #>                           Ii          E.Ii      Var.Ii       Z.Ii #> AAATTACCTATCGATG  0.53682603 -0.0073375879 0.087243111  1.8423152 #> AACATATCAACTGGTG  0.20017125 -0.0008174853 0.009783652  2.0319883 #> AAGATTGGCGGAACGT  0.13533683 -0.0002992400 0.004361215  2.0538630 #> AAGGGACAGATTCTGT  0.67946203 -0.0182482408 0.214584793  1.5061757 #> AATATCGAGGGTTCTC -0.01287299 -0.0009633914 0.011528171 -0.1109218 #> AATGATGATACGCTAT  0.15331553 -0.0306802864 0.356207210  0.3082880 #>                  Pr(z != E(Ii))      mean    median     pysal    -log10p #> AAATTACCTATCGATG     0.06542906 High-High High-High High-High 1.18422931 #> AACATATCAACTGGTG     0.04215484 High-High High-High High-High 1.37515260 #> AAGATTGGCGGAACGT     0.03998896 High-High  Low-High High-High 1.39805992 #> AAGGGACAGATTCTGT     0.13202207 High-High High-High High-High 0.87935347 #> AATATCGAGGGTTCTC     0.91167838  High-Low  High-Low  High-Low 0.04015835 #> AATGATGATACGCTAT     0.75786321 High-High  High-Low High-High 0.12040917 #>                  -log10p_adj #> AAATTACCTATCGATG  0.33913127 #> AACATATCAACTGGTG  0.53005456 #> AAGATTGGCGGAACGT  0.61990867 #> AAGGGACAGATTCTGT  0.03425543 #> AATATCGAGGGTTCTC  0.00000000 #> AATGATGATACGCTAT  0.00000000  # For annotGeometries annotGraph(sfe, \"myofiber_tri2nb\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3L,         method = \"tri2nb\", dist_type = \"idw\",         zero.policy = TRUE     ) sfe <- annotGeometryUnivariate(sfe,     type = \"localG\", features = \"area\",     annotGraphName = \"myofiber_tri2nb\",     annotGeometryName = \"myofiber_simplified\",     zero.policy = TRUE ) head(localResult(sfe, \"localG\", \"area\",     annotGeometryName = \"myofiber_simplified\" )) #>          localG           Gi        E(Gi)        V(Gi)      Z(Gi) #> 1018 -2.3083710 0.0001426229 0.0002238002 1.236681e-09 -2.3083710 #> 1021 -0.8140180 0.0002393084 0.0002665443 1.119477e-09 -0.8140180 #> 1024  0.0508039 0.0002301134 0.0002280492 1.650888e-09  0.0508039 #> 1041 -0.1700897 0.0002715145 0.0002773569 1.179830e-09 -0.1700897 #> 1052  0.1547597 0.0002185310 0.0002133753 1.109810e-09  0.1547597 #> 1058 -0.3688569 0.0002047116 0.0002174315 1.189189e-09 -0.3688569 #>      Pr(z != E(Gi))    -log10p -log10p_adj cluster #> 1018     0.02097851 1.67822538   0.9000741    High #> 1021     0.41563466 0.38128824   0.0000000    High #> 1024     0.95948178 0.01796327   0.0000000    High #> 1041     0.86493956 0.06301424   0.0000000    High #> 1052     0.87701073 0.05699509   0.0000000     Low #> 1058     0.71223439 0.14737706   0.0000000     Low"},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":null,"dir":"Reference","previous_headings":"","what":"Find clusters of correlogram patterns â€” clusterCorrelograms","title":"Find clusters of correlogram patterns â€” clusterCorrelograms","text":"Cluster correlograms find patterns length scales spatial autocorrelation. correlograms clustered must computed method number lags. Correlograms clustered jointly across samples.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find clusters of correlogram patterns â€” clusterCorrelograms","text":"","code":"clusterCorrelograms(   sfe,   features,   BLUSPARAM,   sample_id = \"all\",   method = \"I\",   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   swap_rownames = NULL,   name = \"sp.correlogram\" )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find clusters of correlogram patterns â€” clusterCorrelograms","text":"sfe SpatialFeatureExperiment object correlograms computed features interest. features Features whose correlograms cluster. BLUSPARAM BlusterParam object specifying algorithm use. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. method \"corr\" correlation, \"\" Moran's , \"C\" Geary's C colGeometryName Name colGeometry look features. annotGeometryName Name annotGeometry look features. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name correlogram results stored, default \"sp.correlogram\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find clusters of correlogram patterns â€” clusterCorrelograms","text":"data frame 3 columns: feature features,   cluster factor cluster membership features within   sample, sample_id sample.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterCorrelograms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find clusters of correlogram patterns â€” clusterCorrelograms","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(bluster) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) inds <- c(1, 3, 4, 5) sfe <- runUnivariate(sfe,     type = \"sp.correlogram\",     features = rownames(sfe)[inds],     exprs_values = \"counts\", order = 5 ) clust <- clusterCorrelograms(sfe,     features = rownames(sfe)[inds],     BLUSPARAM = KmeansParam(2) )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Find clusters on the Moran plot â€” clusterMoranPlot","title":"Find clusters on the Moran plot â€” clusterMoranPlot","text":"Moran plot plots value location x axis, average neighbors locations y axis. Sometimes clusters can seen Moran plot, indicating different types neighborhoods.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find clusters on the Moran plot â€” clusterMoranPlot","text":"","code":"clusterMoranPlot(   sfe,   features,   BLUSPARAM,   sample_id = \"all\",   colGeometryName = NULL,   annotGeometryName = NULL,   swap_rownames = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find clusters on the Moran plot â€” clusterMoranPlot","text":"sfe SpatialFeatureExperiment object Moran plot computed feature interest. Moran plot feature computed feature sample_id, calculated stored rowData. See calculateUnivariate. features Features whose Moran plot cluster. Features whose Moran plots computed skipped, warning. BLUSPARAM BlusterParam object specifying algorithm use. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. colGeometryName Name colGeometry look features. annotGeometryName Name annotGeometry look features. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find clusters on the Moran plot â€” clusterMoranPlot","text":"data frame column factor cluster   membership feature. column names features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterMoranPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find clusters on the Moran plot â€” clusterMoranPlot","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) library(bluster) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) # Compute moran plot sfe <- runUnivariate(sfe,     type = \"moran.plot\", features = rownames(sfe)[1],     exprs_values = \"counts\" ) clusts <- clusterMoranPlot(sfe, rownames(sfe)[1],     BLUSPARAM = KmeansParam(2) )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterVariograms.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster variograms of multiple features â€” clusterVariograms","title":"Cluster variograms of multiple features â€” clusterVariograms","text":"function clusters variograms features across samples find patterns decays spatial autocorrelation. fitted variograms clustered different samples can different distance bins.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterVariograms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster variograms of multiple features â€” clusterVariograms","text":"","code":"clusterVariograms(   sfe,   features,   BLUSPARAM,   n = 20,   sample_id = \"all\",   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   swap_rownames = NULL,   name = \"variogram\" )"},{"path":"https://pachterlab.github.io/voyager/reference/clusterVariograms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster variograms of multiple features â€” clusterVariograms","text":"sfe SpatialFeatureExperiment object correlograms computed features interest. features Features whose correlograms cluster. BLUSPARAM BlusterParam object specifying algorithm use. n Number points fitted variogram line. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. colGeometryName Name colGeometry look features. annotGeometryName Name annotGeometry look features. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name correlogram results stored, default \"sp.correlogram\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterVariograms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster variograms of multiple features â€” clusterVariograms","text":"data frame 3 columns: feature features,   cluster factor cluster membership features within   sample, sample_id sample.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/clusterVariograms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster variograms of multiple features â€” clusterVariograms","text":"","code":"library(SFEData) library(scater) library(bluster) library(Matrix) #>  #> Attaching package: â€˜Matrixâ€™ #> The following object is masked from â€˜package:S4Vectorsâ€™: #>  #>     expand sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) # Just the highly expressed genes gs <- order(Matrix::rowSums(counts(sfe)), decreasing = TRUE)[1:10] genes <- rownames(sfe)[gs]  sfe <- runUnivariate(sfe, \"variogram\", features = genes) clusts <- clusterVariograms(sfe, genes, BLUSPARAM = HclustParam(), swap_rownames = \"symbol\")  # Plot the clustering plotVariogram(sfe, genes, color_by = clusts, group = \"feature\", use_lty = FALSE, swap_rownames = \"symbol\", show_np = FALSE)"},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":null,"dir":"Reference","previous_headings":"","what":"Colorblind friendly palette from dittoSeq â€” ditto_colors","title":"Colorblind friendly palette from dittoSeq â€” ditto_colors","text":"Just get palette without install dependencies dittoSeq.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Colorblind friendly palette from dittoSeq â€” ditto_colors","text":"","code":"ditto_colors"},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Colorblind friendly palette from dittoSeq â€” ditto_colors","text":"character vector hex colors palette. 40 colors.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/ditto_colors.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Colorblind friendly palette from dittoSeq â€” ditto_colors","text":"dittoSeq package.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":null,"dir":"Reference","previous_headings":"","what":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","title":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","text":"function longer used internally unnecessary scico divergent palettes. can useful using divergent palettes outside scico one must specify beginning end midpoint, override default palette.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","text":"","code":"getDivergeRange(values, diverge_center = 0)"},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","text":"values Numeric vector colored. diverge_center Value center , defaults 0.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","text":"numeric vector length 2, first element beginning, second end. values 0 1.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/getDivergeRange.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get beginning and end of palette to center a divergent palette â€” getDivergeRange","text":"","code":"v <- rnorm(10) getDivergeRange(v, diverge_center = 0) #> [1] 0.1643015 1.0000000"},{"path":"https://pachterlab.github.io/voyager/reference/listSFEMethods.html","id":null,"dir":"Reference","previous_headings":"","what":"List all spatial methods in Voyager package â€” listSFEMethods","title":"List all spatial methods in Voyager package â€” listSFEMethods","text":"package ships many spatial statistics methods SFEMethod objects. user can adapt uniform user interface package spatial methods creating new SFEMethod objects. function lists names methods within Voyager, use type argument calculateUnivariate, calculateBivariate, calculateMultivariate.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/listSFEMethods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all spatial methods in Voyager package â€” listSFEMethods","text":"","code":"listSFEMethods(variate = c(\"uni\", \"bi\", \"multi\"), scope = c(\"global\", \"local\"))"},{"path":"https://pachterlab.github.io/voyager/reference/listSFEMethods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List all spatial methods in Voyager package â€” listSFEMethods","text":"variate Uni-, bi-, multi-variate. scope whether local global.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/listSFEMethods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all spatial methods in Voyager package â€” listSFEMethods","text":"data frame column name another brief   description.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/listSFEMethods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List all spatial methods in Voyager package â€” listSFEMethods","text":"","code":"listSFEMethods(\"uni\", \"local\") #>               name                                          description #> 1       localmoran                                      Local Moran's I #> 2  localmoran_perm                  Local Moran's I permutation testing #> 3           localC                                      Local Geary's C #> 4      localC_perm                  Local Geary's C permutation testing #> 5           localG                                      Getis-Ord Gi(*) #> 6      localG_perm             Getis-Ord Gi(*) with permutation testing #> 7             LOSH                     Local spatial heteroscedasticity #> 8          LOSH.mc Local spatial heteroscedasticity permutation testing #> 9          LOSH.cs     Local spatial heteroscedasticity Chi-square test #> 10      moran.plot                                   Moran scatter plot"},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"Values Moran's can take depends spatial neighborhood graph. bounds Moran's given graph, C, given minimum maximum eigenvalues double centered â€“ .e. subtracting column means row means â€“ adjacency matrix \\((- \\mathbb{11}^T/n)C(- \\mathbb{11}^T/n)\\), \\(\\mathbb 1\\) vector 1's. implementation follows implementation adespatial uses RSpectra package quickly find minimum maximum eigenvalues without performing unnecessary work find full spectrum done base R's eigen.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"","code":"moranBounds(listw)"},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"listw listw object spatial neighborhood graph.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"numeric vector minimum maximum Moran's given spatial   neighborhood graph.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"double centering, adjacency matrix longer sparse, function can take lot memory larger datasets.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"de Jong, P., Sprenger, C., & van Veen, F. (1984). extreme values Moran's Geary's C. Geographical Analysis, 16(1), 17-24.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranBounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the bounds of Moran's I given spatial neighborhood graph â€” moranBounds","text":"","code":"# example code library(SFEData) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache g <- findVisiumGraph(sfe) moranBounds(g) #>       Imin       Imax  #> -0.5825787  0.9725069"},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Use ggplot to plot the moran.plot results â€” moranPlot","title":"Use ggplot to plot the moran.plot results â€” moranPlot","text":"function uses ggplot2 plot Moran plot. plot aesthetically pleasing base R version implemented spdep. addition, contours plotted show point density plot, points can colored variable, clusters. contours may also filled influential points plotted. filled, viridis E option used.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use ggplot to plot the moran.plot results â€” moranPlot","text":"","code":"moranPlot(   sfe,   feature,   graphName = 1L,   sample_id = \"all\",   contour_color = \"cyan\",   color_by = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   plot_singletons = TRUE,   binned = FALSE,   filled = FALSE,   divergent = FALSE,   diverge_center = NULL,   swap_rownames = NULL,   bins = 100,   binwidth = NULL,   hex = FALSE,   plot_influential = TRUE,   bins_contour = NULL,   name = \"moran.plot\",   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use ggplot to plot the moran.plot results â€” moranPlot","text":"sfe SpatialFeatureExperiment object. feature Name one variable show plot. converted sentence case x axis lower case y axis appended \"Spatially lagged\". One feature time since colors color_by may specific feature (e.g. clusterMoranPlot). graphName Name colGraph annotGraph, spatial neighborhood graph used compute Moran plot. determine points singletons plot differently plot. sample_id One sample_id sample whose graph plot. contour_color Color point density contours, can changed contours stand points. color_by Variable color points . can name column colData, gene, name column colGeometry specified colGeometryName. can vector length number cells/spots sample_id interest. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. plot_singletons Logical, whether plot items spatial neighbors. binned Logical, whether plot 2D histograms. argument precedence filled. filled Logical, whether plot filled contours non-influential points plot influential points points. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. bins binning colGeometry space due large number cells spots, number bins, passed geom_bin2d geom_hex. NULL (default), colGeometry plotted without binning. binning, point geometry recommended. geometry point, centroids used. binwidth Width bins, passed geom_bin2d geom_hex. hex Logical, whether use geom_hex. Note geom_hex broken ggplot2 version 3.4.0. Please update ggplot2 getting horizontal stripes hex = TRUE. plot_influential Logical, whether plot influential points different palette binned = TRUE. bins_contour Number bins point density contour. Use smaller number make sparser contours. name Name Moran plot results stored. default \"moran.plot\". ... arguments pass geom_density2d.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use ggplot to plot the moran.plot results â€” moranPlot","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/moranPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use ggplot to plot the moran.plot results â€” moranPlot","text":"","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(SFEData) library(bluster) library(scater) sfe <- McKellarMuscleData(\"full\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[, colData(sfe)$in_tissue] sfe <- logNormCounts(sfe) colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) sfe <- runUnivariate(sfe, type = \"moran.plot\", features = \"Myh1\",                      swap_rownames = \"symbol\") clust <- clusterMoranPlot(sfe, \"Myh1\", BLUSPARAM = KmeansParam(2),                           swap_rownames = \"symbol\") moranPlot(sfe, \"Myh1\", graphName = \"visium\", color_by = clust[, 1],           swap_rownames = \"symbol\")"},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":null,"dir":"Reference","previous_headings":"","what":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"implementation uses RSpectra package efficiently compute small subset eigenvalues eigenvectors, small subset typically used. Hence much faster memory efficient original implementation adespatial. However, implementation support row column weighting standard ones PCA., adespatial implementation general.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"","code":"multispati_rsp(x, listw, nfposi = 30L, nfnega = 30L, scale = TRUE)"},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"x matrix whose columns features rows cells. listw listw object, spatial neighborhood graph cells x. length must equal number row x. nfposi Number positive eigenvalues eigenvectors compute. nfnega Number nega eigenvalues eigenvectors compute. indicate negative spatial autocorrelation. scale Logical, whether scale data.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"matrix cell embeddings spatial PC, attribute   loading eigenvectors gene loadings, attribute   eig eigenvalues.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"Eigen decomposition fail feature variance zero leading NaN scaled matrix.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"Dray, S., Said, S. Debias, F. (2008) Spatial ordination vegetation data using generalization Wartenberg's multivariate spatial correlation. Journal vegetation science, 19, 45-56.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/multispati_rsp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A faster implementation of MULTISPATI PCA â€” multispati_rsp","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[,sfe$in_tissue] sfe <- logNormCounts(sfe) inds <- order(rowSums(logcounts(sfe)), decreasing = TRUE)[1:50] mat <- logcounts(sfe)[inds,] g <- findVisiumGraph(sfe) out <- multispati_rsp(t(mat), listw = g, nfposi = 10, nfnega = 10)"},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cell density as 2D histogram â€” plotCellBin2D","title":"Plot cell density as 2D histogram â€” plotCellBin2D","text":"function plots cell density histological space 2D histograms, especially helpful larger smFISH-based datasets.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cell density as 2D histogram â€” plotCellBin2D","text":"","code":"plotCellBin2D(   sfe,   sample_id = \"all\",   bins = 200,   binwidth = NULL,   hex = FALSE,   ncol = NULL,   bbox = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cell density as 2D histogram â€” plotCellBin2D","text":"sfe SpatialFeatureExperiment object. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. bins Number bins. Can vector length 2 specify x y axes separately. binwidth Width bins, passed geom_bin2d geom_hex. hex Logical, whether use hexagonal bins. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cell density as 2D histogram â€” plotCellBin2D","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCellBin2D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cell density as 2D histogram â€” plotCellBin2D","text":"","code":"library(SFEData) sfe <- HeNSCLCData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache plotCellBin2D(sfe)"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataFreqpoly.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot frequency polygons for colData and rowData columns â€” plotColDataFreqpoly","title":"Plot frequency polygons for colData and rowData columns â€” plotColDataFreqpoly","text":"function recommended instead plotColDataHistogram coloring multiple categories log transforming y axis, causes problems stacked histograms.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataFreqpoly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot frequency polygons for colData and rowData columns â€” plotColDataFreqpoly","text":"","code":"plotColDataFreqpoly(   sce,   feature,   color_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   linewidth = 1.2,   scales = \"free\",   ncol = 1,   position = \"identity\" )  plotRowDataFreqpoly(   sce,   feature,   color_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   linewidth = 1.2,   scales = \"free\",   ncol = 1,   position = \"identity\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataFreqpoly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot frequency polygons for colData and rowData columns â€” plotColDataFreqpoly","text":"sce SingleCellExperiment object. feature Names columns colData rowData plot. multiple features specified, plotted separate facets. color_by Name categorical column colData rowData color polygons. subset Name logical column plot subset data. bins Number bins. Overridden binwidth. Defaults 30. binwidth width bins. Can specified numeric value function calculates width unscaled x. , \"unscaled x\" refers original x values data, application scale transformation. specifying function along grouping structure, function called per group. default use number bins bins, covering range data. always override value, exploring multiple widths find best illustrate stories data. bin width date variable number days time; bin width time variable number seconds. linewidth Line width polygons, defaults thicker 1.2. scales scales fixed (\"fixed\", default), free (\"free\"), free one dimension (\"free_x\", \"free_y\")? ncol Number columns facetting. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataFreqpoly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot frequency polygons for colData and rowData columns â€” plotColDataFreqpoly","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache plotColDataFreqpoly(sfe, c(\"nCounts\", \"nGenes\"), color_by = \"in_tissue\",                     bins = 50)  plotColDataFreqpoly(sfe, \"nCounts\", subset = \"in_tissue\")  sfe2 <- sfe[, sfe$in_tissue] plotColDataFreqpoly(sfe2, c(\"nCounts\", \"nGenes\"), bins = 50)"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","title":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","text":"Plot histograms colData rowData columns","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","text":"","code":"plotColDataHistogram(   sce,   feature,   fill_by = NULL,   facet_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   scales = \"free\",   ncol = 1,   position = \"stack\",   ... )  plotRowDataHistogram(   sce,   feature,   fill_by = NULL,   facet_by = NULL,   subset = NULL,   bins = 100,   binwidth = NULL,   scales = \"free\",   ncol = 1,   position = \"stack\",   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","text":"sce SingleCellExperiment object. feature Names columns colData rowData plot. multiple features specified, plotted separate facets. fill_by Name categorical column colData rowData fill histogram. facet_by Column colData rowData facet . multiple features plotted, features different facets. case, setting facet_by call facet_grid features rows categories facet_by columns. subset Name logical column plot subset data. bins Numeric vector giving number bins vertical horizontal directions. Set 100 default. binwidth width bins. Can specified numeric value function calculates width unscaled x. , \"unscaled x\" refers original x values data, application scale transformation. specifying function along grouping structure, function called per group. default use number bins bins, covering range data. always override value, exploring multiple widths find best illustrate stories data. bin width date variable number days time; bin width time variable number seconds. scales scales fixed (\"fixed\", default), free (\"free\"), free one dimension (\"free_x\", \"free_y\")? ncol Number columns facetting. position position adjustment use data layer. can used various ways, including prevent overplotting improving display. position argument accepts following: result calling position function, position_jitter(). method allows passing extra arguments position. string naming position adjustment. give position string, strip function name position_ prefix. example, use position_jitter(), give position \"jitter\". information ways specify position, see layer position documentation. ... arguments passed layer()'s params argument. arguments broadly fall one 4 categories . Notably, arguments position argument, aesthetics required can passed .... Unknown arguments part 4 categories ignored. Static aesthetics mapped scale, fixed value apply layer whole. example, colour = \"red\" linewidth = 3. geom's documentation Aesthetics section lists available options. 'required' aesthetics passed params. Please note passing unmapped aesthetics vectors technically possible, order required length guaranteed parallel input data. constructing layer using stat_*() function, ... argument can used pass parameters geom part layer. example stat_density(geom = \"area\", outline.type = \"\"). geom's documentation lists parameters can accept. Inversely, constructing layer using geom_*() function, ... argument can used pass parameters stat part layer. example geom_area(stat = \"density\", adjust = 0.5). stat's documentation lists parameters can accept. key_glyph argument layer() may also passed .... can one functions described key glyphs, change display layer legend.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","text":"ggplot object","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotColDataHistogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot histograms for colData and rowData columns â€” plotColDataHistogram","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache plotColDataHistogram(sfe, c(\"nCounts\", \"nGenes\"), fill_by = \"in_tissue\",                      bins = 50, position = \"stack\")  plotColDataHistogram(sfe, \"nCounts\", subset = \"in_tissue\")  sfe2 <- sfe[, sfe$in_tissue] plotColDataHistogram(sfe2, c(\"nCounts\", \"nGenes\"), bins = 50)"},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot spatial graphs â€” plotColGraph","title":"Plot spatial graphs â€” plotColGraph","text":"ggplot version spdep::plot.nb, reducing boilerplate SFE objects.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot spatial graphs â€” plotColGraph","text":"","code":"plotColGraph(   sfe,   colGraphName = 1L,   colGeometryName = 1L,   sample_id = \"all\",   weights = FALSE,   segment_size = 0.5,   geometry_size = 0.5,   ncol = NULL,   bbox = NULL )  plotAnnotGraph(   sfe,   annotGraphName = 1L,   annotGeometryName = 1L,   sample_id = \"all\",   weights = FALSE,   segment_size = 0.5,   geometry_size = 0.5,   ncol = NULL,   bbox = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot spatial graphs â€” plotColGraph","text":"sfe SpatialFeatureExperiment object. colGraphName Name graph associated columns gene count matrix plotted. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. weights Whether plot weights. TRUE, transparency (alpha) segments represent edge weights. segment_size Thickness segments represent graph edges. geometry_size Point size (POINT geometries) line thickness (LINESTRING POLYGON) plot geometry background. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. annotGraphName Name annotation graph plot. annotGeometryName Name annotGeometry, associated graph specified annotGraphName, spatial coordinates graph nodes context.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot spatial graphs â€” plotColGraph","text":"ggplot2 object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotColGraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot spatial graphs â€” plotColGraph","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) plotColGraph(sfe, colGraphName = \"visium\", colGeometryName = \"spotPoly\")  # Make the myofiber segmentations a valid POLYGON geometry ag <- annotGeometry(sfe, \"myofiber_simplified\") ag <- st_buffer(ag, 0) ag <- ag[!st_is_empty(ag), ] annotGeometry(sfe, \"myofiber_simplified\") <- ag annotGraph(sfe, \"myofibers\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3,         method = \"tri2nb\", dist_type = \"idw\"     ) plotAnnotGraph(sfe,     annotGraphName = \"myofibers\",     annotGeometryName = \"myofiber_simplified\",     weights = TRUE )"},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot correlogram â€” plotCorrelogram","title":"Plot correlogram â€” plotCorrelogram","text":"Use ggplot2 plot correlograms computed runUnivariate, pulling results rowData. Correlograms multiple genes error bars can plotted, can colored numeric categorical column rowData vector length nrow SFE object. coloring useful correlograms clustered show types length scales patterns decay spatial autocorrelation. method = \"\", error bars twice standard deviation estimated Moran's value.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot correlogram â€” plotCorrelogram","text":"","code":"plotCorrelogram(   sfe,   features,   sample_id = \"all\",   method = \"I\",   color_by = NULL,   facet_by = c(\"sample_id\", \"features\"),   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   plot_signif = TRUE,   p_adj_method = \"BH\",   divergent = FALSE,   diverge_center = NULL,   swap_rownames = NULL,   name = \"sp.correlogram\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot correlogram â€” plotCorrelogram","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry, colnames cell embeddings reducedDim, numeric indices dimension reduction components. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. method \"corr\" correlation, \"\" Moran's , \"C\" Geary's C color_by Name column rowData(sfe) featureData colData (see colFeatureData), colGeometry, annotGeometry color correlogram feature. Alternatively, vector length features, data frame clusterCorrelograms. facet_by Whether facet sample_id (default) features. facetting sample_id, different features plotted facet comparison. facetting features, different samples compared feature. Ignored one sample specified. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. plot_signif Logical, whether plot significance symbols: p < 0.001: ***, p < 0.01: **, p < 0.05 *, p < 0.1: ., otherwise symbol. p-values two sided, based assumption estimated Moran's normally distributed mean randomized version data. mean variance come moran.test Moran's geary.test Geary's C. Take results grain salt data normally distributed. p_adj_method Multiple testing correction method p.adjust, correct multiple testing (number lags times number features) Moran's estimates plot_signif = TRUE. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name correlogram results stored, default \"sp.correlogram\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot correlogram â€” plotCorrelogram","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCorrelogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot correlogram â€” plotCorrelogram","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(bluster) library(scater) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) inds <- c(1, 3, 4, 5) features <- rownames(sfe)[inds] sfe <- runUnivariate(sfe,     type = \"sp.correlogram\", features = features,     exprs_values = \"counts\", order = 5 ) clust <- clusterCorrelograms(sfe,     features = features,     BLUSPARAM = KmeansParam(2) ) # Color by features plotCorrelogram(sfe, features)  # Color by something else plotCorrelogram(sfe, features, color_by = clust$cluster)  # Facet by features plotCorrelogram(sfe, features, facet_by = \"features\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cross variogram â€” plotCrossVariogram","title":"Plot cross variogram â€” plotCrossVariogram","text":"Equivalent gstat::plot.gstatVariogram, using ggplot2 customizable.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cross variogram â€” plotCrossVariogram","text":"","code":"plotCrossVariogram(res, show_np = TRUE)"},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cross variogram â€” plotCrossVariogram","text":"res Cross variogram results one sample, calculateBivariate. Global bivariate results stored SFE object. show_np Logical, whether show number pairs cells distance bin.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cross variogram â€” plotCrossVariogram","text":"ggplot object. Unfortunately figured way collect facet labels top entire plot.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cross variogram â€” plotCrossVariogram","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[,sfe$in_tissue] sfe <- logNormCounts(sfe)  res <- calculateBivariate(sfe, type = \"cross_variogram\", feature1 = c(\"Myh1\", \"Myh2\", \"Csrp3\"), swap_rownames = \"symbol\") plotCrossVariogram(res)"},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogramMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cross variogram map â€” plotCrossVariogramMap","title":"Plot cross variogram map â€” plotCrossVariogramMap","text":"Equivalent gstat::plot.gstatVariogram, using ggplot2 customizable.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogramMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cross variogram map â€” plotCrossVariogramMap","text":"","code":"plotCrossVariogramMap(res, plot_np = FALSE)"},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogramMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cross variogram map â€” plotCrossVariogramMap","text":"res Cross variogram results one sample, calculateBivariate. Global bivariate results stored SFE object. plot_np Logical, whether plot number pairs distance bin instead variance.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogramMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cross variogram map â€” plotCrossVariogramMap","text":"ggplot object.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotCrossVariogramMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cross variogram map â€” plotCrossVariogramMap","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[,sfe$in_tissue] sfe <- logNormCounts(sfe)  res <- calculateBivariate(sfe, type = \"cross_variogram_map\", feature1 = c(\"Myh1\", \"Myh2\", \"Csrp3\"), swap_rownames = \"symbol\", width = 500, cutoff = 2000) plotCrossVariogramMap(res)"},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot top PC loadings of genes â€” plotDimLoadings","title":"Plot top PC loadings of genes â€” plotDimLoadings","text":"Just like Seurat's VizDimLoadings function. found equivalent SCE find useful. trying reproduce Seurat function exactly. instance, like Seurat imposes ggplot theme, like cowplot theme. Maybe rewrite base R now using Tidyverse.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot top PC loadings of genes â€” plotDimLoadings","text":"","code":"plotDimLoadings(   sce,   dims = 1:4,   nfeatures = 10,   swap_rownames = NULL,   reduction = \"PCA\",   balanced = TRUE,   ncol = 2,   sample_id = \"all\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot top PC loadings of genes â€” plotDimLoadings","text":"sce SingleCellExperiment object, anything inherits SingleCellExperiment. dims Numeric vector specifying PCs plot. MULTISPATI, PCs negative eigenvalues right columns embedding loading matrices. See ElbowPlot. nfeatures Number genes plot. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. reduction Name dimension reduction use. must attribute called either \"percentVar\" \"eig\" eigenvalues. Defaults \"PCA\". balanced Return equal number genes + - scores. FALSE, returns top genes ranked scores absolute values. ncol Number columns facetted plot. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot top PC loadings of genes â€” plotDimLoadings","text":"ggplot object. Loadings different PCs plotted different   facets one ggplot object returned.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotDimLoadings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot top PC loadings of genes â€” plotDimLoadings","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- runPCA(sfe, ncomponents = 10, exprs_values = \"counts\") plotDimLoadings(sfe, dims = 1:2)"},{"path":"https://pachterlab.github.io/voyager/reference/plotGeometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot geometries without coloring â€” plotGeometry","title":"Plot geometries without coloring â€” plotGeometry","text":"Different samples plotted separate facets. multiple geometries plotted time, differentiated color, default using dittoSeq palette, can overridden scale_color_* functions. Transcript spots different genes differentiated point shape plotted, number genes plotted exceed 6 warning issued.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotGeometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot geometries without coloring â€” plotGeometry","text":"","code":"plotGeometry(   sfe,   type = deprecated(),   MARGIN = deprecated(),   colGeometryName = NULL,   annotGeometryName = NULL,   rowGeometryName = NULL,   gene = \"all\",   sample_id = \"all\",   fill = TRUE,   ncol = NULL,   bbox = NULL,   tx_alpha = 1,   tx_size = 1,   tx_file = NULL,   image_id = NULL,   channel = NULL,   maxcell = 5e+05,   show_axes = FALSE,   dark = FALSE,   palette = colorRampPalette(c(\"black\", \"white\"))(255),   normalize_channels = FALSE )"},{"path":"https://pachterlab.github.io/voyager/reference/plotGeometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot geometries without coloring â€” plotGeometry","text":"sfe SpatialFeatureExperiment object. type Name geometry associated MARGIN interest compute graph. MARGIN Just like apply, 1 stands row, 2 stands column. , addition, 3 stands annotation, query annotGeometries, nuclei segmentation Visium data colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. rowGeometryName Name rowGeometry SFE object plot. gene Character vector names genes plot. \"\" transcript spots genes plotted. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. fill Logical, whether fill polygons. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. tx_alpha Transparency transcript spots, helpful transcript spots overplotting. tx_size Point size transcript spots. tx_file File path GeoParquet file transcript spots wish load transcript spots SFE object. See formatTxSpots generating GeoParquet file. image_id ID image plot behind geometries. NULL, plotting images. Use imgData see image IDs present. plot multiple grayscale images different RGB channels, use named vector , whose names channel names (r, g, b), values image_ids corresponding images. RGB colorization may colorblind friendly. plotting multiple samples, assumed image_id used channel across different samples. channel Numeric vector indicating channels multi-channel image plot. NULL, grayscale plotted 1 channel RGB first 3 channels. numeric vector can named (r, g, b) indicate channel maps color. RGB colorization may colorblind friendly. argument specified image_id named vector plot different grayscale images different channels. maxcell Maximum number pixels plot image. image larger, resampled less number pixels save memory faster plotting. recommend reducing number plotting multiple facets. show_axes Logical, whether show axes. dark Logical, whether use dark theme. using dark theme, palette lighter color represent higher values glowing dark. intended plotting gene expression top fluorescent images. palette Vector colors use color grayscale images. normalize_channels Logical, whether normalize channel image individually. FALSE bright field color images H&E set TRUE fluorescent images.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotGeometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot geometries without coloring â€” plotGeometry","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotGeometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot geometries without coloring â€” plotGeometry","text":"","code":"library(SFEData) sfe1 <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe2 <- McKellarMuscleData(\"small2\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache sfe <- cbind(sfe1, sfe2) sfe <- removeEmptySpace(sfe) plotGeometry(sfe, colGeometryName = \"spotPoly\")  plotGeometry(sfe, annotGeometryName = \"myofiber_simplified\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotImage.html","id":null,"dir":"Reference","previous_headings":"","what":"Show image without plotting geometries â€” plotImage","title":"Show image without plotting geometries â€” plotImage","text":"function plots images SFE objects without plotting geometries. showing axes, numbers coordinates within image units spatial extent, actual spatial extent plotting multiple samples avoid excessive empty space.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotImage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show image without plotting geometries â€” plotImage","text":"","code":"plotImage(   sfe,   sample_id = \"all\",   image_id = NULL,   channel = NULL,   ncol = NULL,   bbox = NULL,   maxcell = 5e+05,   show_axes = FALSE,   dark = FALSE,   palette = colorRampPalette(c(\"black\", \"white\"))(255),   normalize_channels = FALSE )"},{"path":"https://pachterlab.github.io/voyager/reference/plotImage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show image without plotting geometries â€” plotImage","text":"sfe SpatialFeatureExperiment object. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. image_id ID image(s) plot. NULL, first image present plotted. Can vector IDs use different grayscale images different channels. vector can named ('r', 'g', 'b'), assign channels images. vector must named length 2. channel Numeric vector indicating channels multi-channel image plot. NULL, grayscale plotted 1 channel RGB first 3 channels. numeric vector can named (r, g, b) indicate channel maps color. RGB colorization may colorblind friendly. argument specified image_id named vector plot different grayscale images different channels. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. maxcell Maximum number pixels plot image. image larger, resampled less number pixels save memory faster plotting. recommend reducing number plotting multiple facets. show_axes Logical, whether show axes. dark Logical, whether use dark theme. using dark theme, palette lighter color represent higher values glowing dark. intended plotting gene expression top fluorescent images. palette Vector colors use color grayscale images. normalize_channels Logical, whether normalize channel image individually. FALSE bright field color images H&E set TRUE fluorescent images.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotImage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show image without plotting geometries â€” plotImage","text":"ggplot object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotImage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show image without plotting geometries â€” plotImage","text":"","code":"library(SFEData) library(SpatialFeatureExperiment) fn <- XeniumOutput(\"v2\", file_path = \"xenium_example\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> downloading 1 resources #> retrieving 1 resource #> loading from cache #> The downloaded files are in /home/runner/work/voyager/voyager/docs/reference/xenium_example/xenium2  # Weird RBioFormats null pointer error the first time it's run try(sfe <- readXenium(fn)) #> >>> Cell segmentations are found in `.parquet` file(s) #> >>> Reading cell and nucleus segmentations #> >>> Making MULTIPOLYGON nuclei geometries #> >>> Making POLYGON cell geometries #> Sanity checks on cell segmentation polygons: #> >>> ..found 132 cells with (nested) polygon lists #> >>> ..applying filtering #> >>> Checking polygon validity #> >>> Saving geometries to parquet files #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 sfe <- readXenium(fn) #> >>> Preprocessed sf segmentations found #> >>> Reading cell and nucleus segmentations #> >>> Reading cell metadata -> `cells.parquet` #> >>> Reading h5 gene count matrix #> >>> filtering cellSeg geometries to match 6272 cells with counts > 0 #> >>> filtering nucSeg geometries to match 6158 cells with counts > 0 # Plot one channel plotImage(sfe, image_id = \"morphology_focus\", channel = 1L)  plotImage(sfe, image_id = \"morphology_focus\", channel = 1L, show_axes = TRUE, dark = TRUE)  # Colorize based on different channels plotImage(sfe, image_id = \"morphology_focus\", channel = c(2,4,1), show_axes = TRUE, dark = TRUE)  unlink(\"xenium_example\", recursive = TRUE)"},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot local results â€” plotLocalResult","title":"Plot local results â€” plotLocalResult","text":"Plot results local spatial analyses space, local Getis-Ord Gi* values.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot local results â€” plotLocalResult","text":"","code":"plotLocalResult(   sfe,   name,   features,   attribute = NULL,   sample_id = \"all\",   colGeometryName = NULL,   annotGeometryName = NULL,   rowGeometryName = NULL,   rowGeometryFeatures = NULL,   ncol = NULL,   ncol_sample = NULL,   annot_aes = list(),   annot_fixed = list(),   tx_fixed = list(),   bbox = NULL,   tx_file = NULL,   image_id = NULL,   channel = NULL,   maxcell = 5e+05,   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NULL,   annot_divergent = FALSE,   annot_diverge_center = NULL,   size = 0.5,   shape = 16,   linewidth = 0,   linetype = 1,   alpha = 1,   color = \"black\",   fill = \"gray80\",   swap_rownames = NULL,   scattermore = FALSE,   pointsize = 0,   bins = NULL,   summary_fun = sum,   hex = FALSE,   show_axes = FALSE,   dark = FALSE,   palette = colorRampPalette(c(\"black\", \"white\"))(255),   normalize_channels = FALSE,   type = name,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot local results â€” plotLocalResult","text":"sfe SpatialFeatureExperiment object. name local spatial results. Use localResultNames see types results already calculated. features Character vector vectors. see features results given type, see localResultFeatures. attribute field local results type features. result feature vector, argument ignored. result data frame matrix, column name result, \"Ii\" local Moran's . local spatial analysis method, default attribute. See Details. Use localResultAttrs. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. rowGeometryName Name rowGeometry SFE object plot. rowGeometryFeatures features rowGeometry plot. Can small number avoid overplotting. Different features distinguished point shape. default (NULL), rowGeometryName specified, whichever items features also row names SFE object. features specified argument subset argument features, spots features specified plotted, differentiated point shape. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. tx_fixed Similar annot_fixed, specify fixed aesthetic transcript spots. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. tx_file File path GeoParquet file transcript spots wish load transcript spots SFE object. See formatTxSpots generating GeoParquet file. image_id ID image plot behind geometries. NULL, plotting images. Use imgData see image IDs present. plot multiple grayscale images different RGB channels, use named vector , whose names channel names (r, g, b), values image_ids corresponding images. RGB colorization may colorblind friendly. plotting multiple samples, assumed image_id used channel across different samples. channel Numeric vector indicating channels multi-channel image plot. NULL, grayscale plotted 1 channel RGB first 3 channels. numeric vector can named (r, g, b) indicate channel maps color. RGB colorization may colorblind friendly. argument specified image_id named vector plot different grayscale images different channels. maxcell Maximum number pixels plot image. image larger, resampled less number pixels save memory faster plotting. recommend reducing number plotting multiple facets. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points. points defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linewidth Width lines, including outlines polygons. polygons, defaults 0, meaning outlines. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). bins binning colGeometry space due large number cells spots, number bins, passed geom_bin2d geom_hex. NULL (default), colGeometry plotted without binning. binning, point geometry recommended. geometry point, centroids used. summary_fun Function summarize feature value colGeometry binned. hex Logical, whether use geom_hex. Note geom_hex broken ggplot2 version 3.4.0. Please update ggplot2 getting horizontal stripes hex = TRUE. show_axes Logical, whether show axes. dark Logical, whether use dark theme. using dark theme, palette lighter color represent higher values glowing dark. intended plotting gene expression top fluorescent images. palette Vector colors use color grayscale images. normalize_channels Logical, whether normalize channel image individually. FALSE bright field color images H&E set TRUE fluorescent images. type SFEMethod object string corresponding name one objects environment. localResult interest manually added outside runUnivariate runBivariate, method recorded, type argument can used specify method properly get title labels. default, argument set argument name. method parameters recorded, type argument ignored. ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot local results â€” plotLocalResult","text":"ggplot2 object plotting one feature. patchwork   object plotting multiple features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot local results â€” plotLocalResult","text":"Many local spatial analyses return data frame matrix results, whose columns can statistic interest location, variance, expected value permutation, p-value, etc. attribute argument specifies column use multiple columns. defaults local method supported package mean: localmoran localmoran_perm Ii, local Moran's statistic location. localC_perm localC, local Geary C statistic location. localG localG_perm localG, local Getis-Ord Gi Gi* statistic. include_self = TRUE calculateUnivariate runUnivariate called, Gi*. Otherwise Gi. LOSH LOSH.mc Hi, local spatial heteroscedasticity moran.plot wx, average value neighbor location. Moran plot best plotted scatter plot wx vs x. See moranPlot. local methods listed return vectors results. instance, localC returns vector default, local Geary's C statistic.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot local results â€” plotLocalResult","text":"function shares internals   plotSpatialFeature, important differences.   plotSpatialFeature, annotGeometry indeed   used annotation protagonist colGeometry, since   easy directly use ggplot2 plot data   annotGeometry sf data frames overlaying   annotGeometry colGeometry involves complicated code.   contrast, function, local results annotGeometry can   plotted separately without anything related colGeometry. Note   annotGeometry local results plotted without   colGeometry, annot_* arguments ignored. Use   arguments aesthetics colGeometry.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotLocalResult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot local results â€” plotLocalResult","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- sfe[,sfe$in_tissue] colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) feature_use <- rownames(sfe)[1] sfe <- logNormCounts(sfe) sfe <- runUnivariate(sfe, \"localmoran\", feature_use) # Which types of results are available? localResultNames(sfe) #> [1] \"localmoran\" # Which features for localmoran? localResultFeatures(sfe, \"localmoran\") #> [1] \"ENSMUSG00000025902\" # Which columns does the localmoran results have? localResultAttrs(sfe, \"localmoran\", feature_use) #>  [1] \"Ii\"             \"E.Ii\"           \"Var.Ii\"         \"Z.Ii\"           #>  [5] \"Pr(z != E(Ii))\" \"mean\"           \"median\"         \"pysal\"          #>  [9] \"-log10p\"        \"-log10p_adj\"    plotLocalResult(sfe, \"localmoran\", feature_use, \"Ii\",     colGeometryName = \"spotPoly\" )   # For annotGeometry # Make sure it's type POLYGON annotGeometry(sfe, \"myofiber_simplified\") <-     sf::st_buffer(annotGeometry(sfe, \"myofiber_simplified\"), 0) annotGraph(sfe, \"poly2nb_myo\") <-     findSpatialNeighbors(sfe,         type = \"myofiber_simplified\", MARGIN = 3,         method = \"poly2nb\", zero.policy = TRUE     ) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 2 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. sfe <- annotGeometryUnivariate(sfe, \"localmoran\",     features = \"area\",     annotGraphName = \"poly2nb_myo\",     annotGeometryName = \"myofiber_simplified\",     zero.policy = TRUE ) plotLocalResult(sfe, \"localmoran\", \"area\", \"Ii\",     annotGeometryName = \"myofiber_simplified\",     size = 0.3, color = \"cyan\" )  plotLocalResult(sfe, \"localmoran\", \"area\", \"Z.Ii\",     annotGeometryName = \"myofiber_simplified\" )  # don't use annot_* arguments when annotGeometry is plotted without colGeometry"},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","title":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","text":"Plot simulations density plot histogram compared observed Moran's Geary's C, ggplot2 looks nicer. Unlike plotting function spdep, function can also plot feature different samples facets plot different features samples together comparison.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","text":"","code":"plotMoranMC(   sfe,   features,   sample_id = \"all\",   facet_by = c(\"sample_id\", \"features\"),   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   ptype = c(\"density\", \"histogram\", \"freqpoly\"),   swap_rownames = NULL,   name = \"moran.mc\",   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry, colnames cell embeddings reducedDim, numeric indices dimension reduction components. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. facet_by Whether facet sample_id (default) features. facetting sample_id, different features plotted facet comparison. facetting features, different samples compared feature. Ignored one sample specified. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. ptype Plot type, one \"density\", \"histogram\", \"freqpoly\". swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name Monte Carlo results stored, defaults \"moran.mc\". Geary's C Monte Carlo, default \"geary.mc\". ... arguments passed geom_density, geom_histogram, geom_freqpoly, depending ptype.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","text":"ggplot2 object.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotMoranMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Moran/Geary Monte Carlo results â€” plotMoranMC","text":"","code":"library(SpatialFeatureExperiment) library(SFEData) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache colGraph(sfe, \"visium\") <- findVisiumGraph(sfe) sfe <- colDataUnivariate(sfe, type = \"moran.mc\", \"nCounts\", nsim = 100) plotMoranMC(sfe, \"nCounts\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot gene expression in space â€” plotSpatialFeature","title":"Plot gene expression in space â€” plotSpatialFeature","text":"Unlike Seurat ggspavis, plotting functions package uses geom_sf whenever applicable.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot gene expression in space â€” plotSpatialFeature","text":"","code":"plotSpatialFeature(   sfe,   features,   colGeometryName = 1L,   sample_id = \"all\",   ncol = NULL,   ncol_sample = NULL,   annotGeometryName = NULL,   rowGeometryName = NULL,   rowGeometryFeatures = NULL,   annot_aes = list(),   annot_fixed = list(),   tx_fixed = list(),   exprs_values = \"logcounts\",   bbox = NULL,   tx_file = NULL,   image_id = NULL,   channel = NULL,   maxcell = 5e+05,   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NA,   annot_divergent = FALSE,   annot_diverge_center = NA,   size = 0.5,   shape = 16,   linewidth = 0,   linetype = 1,   alpha = 1,   color = \"black\",   fill = \"gray80\",   swap_rownames = NULL,   scattermore = FALSE,   pointsize = 0,   bins = NULL,   summary_fun = sum,   hex = FALSE,   show_axes = FALSE,   dark = FALSE,   palette = colorRampPalette(c(\"black\", \"white\"))(255),   normalize_channels = FALSE,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot gene expression in space â€” plotSpatialFeature","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. rowGeometryName Name rowGeometry SFE object plot. rowGeometryFeatures features rowGeometry plot. Can small number avoid overplotting. Different features distinguished point shape. default (NULL), rowGeometryName specified, whichever items features also row names SFE object. features specified argument subset argument features, spots features specified plotted, differentiated point shape. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. tx_fixed Similar annot_fixed, specify fixed aesthetic transcript spots. exprs_values Integer scalar string indicating assay x contains expression values. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. tx_file File path GeoParquet file transcript spots wish load transcript spots SFE object. See formatTxSpots generating GeoParquet file. image_id ID image plot behind geometries. NULL, plotting images. Use imgData see image IDs present. plot multiple grayscale images different RGB channels, use named vector , whose names channel names (r, g, b), values image_ids corresponding images. RGB colorization may colorblind friendly. plotting multiple samples, assumed image_id used channel across different samples. channel Numeric vector indicating channels multi-channel image plot. NULL, grayscale plotted 1 channel RGB first 3 channels. numeric vector can named (r, g, b) indicate channel maps color. RGB colorization may colorblind friendly. argument specified image_id named vector plot different grayscale images different channels. maxcell Maximum number pixels plot image. image larger, resampled less number pixels save memory faster plotting. recommend reducing number plotting multiple facets. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points. points defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linewidth Width lines, including outlines polygons. polygons, defaults 0, meaning outlines. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). bins binning colGeometry space due large number cells spots, number bins, passed geom_bin2d geom_hex. NULL (default), colGeometry plotted without binning. binning, point geometry recommended. geometry point, centroids used. summary_fun Function summarize feature value colGeometry binned. hex Logical, whether use geom_hex. Note geom_hex broken ggplot2 version 3.4.0. Please update ggplot2 getting horizontal stripes hex = TRUE. show_axes Logical, whether show axes. dark Logical, whether use dark theme. using dark theme, palette lighter color represent higher values glowing dark. intended plotting gene expression top fluorescent images. palette Vector colors use color grayscale images. normalize_channels Logical, whether normalize channel image individually. FALSE bright field color images H&E set TRUE fluorescent images. ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot gene expression in space â€” plotSpatialFeature","text":"ggplot2 object plotting one feature. patchwork   object plotting multiple features.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot gene expression in space â€” plotSpatialFeature","text":"documentation function, \"feature\" can gene (whatever entity corresponds rows gene count matrix), column colData, column colGeometry sf data frame specified colGeometryName argument. light theme, continuous variables, Blues palette colorbrewer used divergent = FALSE, roma palette scico package divergent = TRUE. dark theme, nuuk palette scico used divergent = FALSE, berlin palette scico used divergent = TRUE. discrete variables, dittoSeq palette used. annotation, YlOrRd colorbrewer palette used continuous variables light theme. dark theme, acton palette scico used divergent = FALSE vanimo palette scico used divergent = FALSE. end dittoSeq palette used discrete variables. individual palette colorblind friendly, plotting continuous variables coloring colGeometry annotGeometry simultaneously, combination two palettes guaranteed colorblind friendly. addition, plotting image behind geometries, colors image may distort color perception values geometries. theme_void used spatial plots package, units spatial coordinates often arbitrary. can overriden show axes using different theme normally done ggplot2.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotSpatialFeature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot gene expression in space â€” plotSpatialFeature","text":"","code":"library(SFEData) library(sf) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache # features can be genes or colData or colGeometry columns plotSpatialFeature(sfe, c(\"nCounts\", rownames(sfe)[1]),     exprs_values = \"counts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"tissueBoundary\" )  # Change fixed aesthetics plotSpatialFeature(sfe, \"nCounts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"tissueBoundary\",     annot_fixed = list(color = \"blue\", size = 0.3, fill = NA),     alpha = 0.7 )  # Make the myofiber segmentations a valid POLYGON geometry ag <- annotGeometry(sfe, \"myofiber_simplified\") ag <- st_buffer(ag, 0) ag <- ag[!st_is_empty(ag), ] annotGeometry(sfe, \"myofiber_simplified\") <- ag # Also plot an annotGeometry variable plotSpatialFeature(sfe, \"nCounts\",     colGeometryName = \"spotPoly\",     annotGeometryName = \"myofiber_simplified\",     annot_aes = list(fill = \"area\") )  # Use a bounding box to zoom in bbox <- c(xmin = 5500, ymin = 13500, xmax = 6000, ymax = 14000) plotSpatialFeature(sfe, \"nCounts\", colGeometryName = \"spotPoly\",                   annotGeometry = \"myofiber_simplified\",                   bbox = bbox, annot_fixed = list(linewidth = 0.3))"},{"path":"https://pachterlab.github.io/voyager/reference/plotTxBin2D.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot transcript spot density as 2D histogram â€” plotTxBin2D","title":"Plot transcript spot density as 2D histogram â€” plotTxBin2D","text":"Plot transcript spot density 2D histogram","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotTxBin2D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot transcript spot density as 2D histogram â€” plotTxBin2D","text":"","code":"plotTxBin2D(   sfe = NULL,   data_dir = NULL,   tech = c(\"Vizgen\", \"Xenium\", \"CosMX\"),   file = NULL,   sample_id = \"all\",   bins = 200,   binwidth = NULL,   hex = FALSE,   ncol = NULL,   bbox = NULL,   gene = \"all\",   spatialCoordsNames = c(\"X\", \"Y\"),   gene_col = \"gene\",   rowGeometryName = \"txSpots\",   flip = FALSE,   tx_file = NULL )"},{"path":"https://pachterlab.github.io/voyager/reference/plotTxBin2D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot transcript spot density as 2D histogram â€” plotTxBin2D","text":"sfe SpatialFeatureExperiment object. data_dir Top level directory output files. can specified place sfe directly read transcript spot coordinates file. reading file, transcripts file plotted argument sample_id ignored. tech Name commercial technology, must one Vizgen, Xenium, CosMX. file File (GeoParquet) numeric columns xy coordinates transcript spots. Ignored data_dir specified. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. bins Number bins. Can vector length 2 specify x y axes separately. binwidth Width bins, passed geom_bin2d geom_hex. hex Logical, whether use hexagonal bins. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. gene Character vector names genes plot. \"\" transcript spots genes plotted. spatialCoordsNames Column names x, y, optionally z coordinates spots. defaults Vizgen. gene_col Column name genes. rowGeometryName Name rowGeometry SFE object plot. flip Logical, whether flip y axis plotting data file. tx_file File path GeoParquet file transcript spots wish load transcript spots SFE object. See formatTxSpots generating GeoParquet file.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotTxBin2D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot transcript spot density as 2D histogram â€” plotTxBin2D","text":"ggplot object, facetting sample.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot variogram â€” plotVariogram","title":"Plot variogram â€” plotVariogram","text":"function plots variogram feature fitted variogram models, showing nugget, range, sill model. Unlike plotting functions package automap uses lattice, function uses ggplot2 make prettier customizable plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot variogram â€” plotVariogram","text":"","code":"plotVariogram(   sfe,   features,   sample_id = \"all\",   color_by = NULL,   group = c(\"none\", \"sample_id\", \"features\", \"angles\"),   use_lty = TRUE,   show_np = TRUE,   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   divergent = FALSE,   diverge_center = NULL,   swap_rownames = NULL,   name = \"variogram\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot variogram â€” plotVariogram","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry, colnames cell embeddings reducedDim, numeric indices dimension reduction components. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. color_by Name column rowData(sfe) featureData colData (see colFeatureData), colGeometry, annotGeometry color correlogram feature. Alternatively, vector length features, data frame clusterCorrelograms. group samples, features, angles show facet comparison multiple. Default \"none\", meaning facet contain one variogram. grouping multiple variograms facet, text model, nugget, sill, range variograms shown. use_lty Logical, whether use linetype point shape distinguish different features samples facet. FALSE, different features samples distinguished patterns shown . show_np Logical, whether show number pairs cells distance bin. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name correlogram results stored, default \"sp.correlogram\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot variogram â€” plotVariogram","text":"ggplot object. empirical variogram distance bin   plotted points, fitted variogram model plotted line   feature. number next point number pairs   cells distance bin.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot variogram â€” plotVariogram","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- colDataUnivariate(sfe, \"variogram\", features = \"nCounts\", model = \"Sph\") plotVariogram(sfe, \"nCounts\")  # Anisotropy, will get a message sfe <- colDataUnivariate(sfe, \"variogram\", features = \"nCounts\", model = \"Sph\", alpha = c(30, 90, 150), name = \"variogram_anis\") #> gstat does not fit anisotropic variograms. Variogram model is fitted to the whole dataset. # Facet by angles by default plotVariogram(sfe, \"nCounts\", name = \"variogram_anis\")  # Plot angles with different colors plotVariogram(sfe, \"nCounts\", group = \"angles\", name = \"variogram_anis\")"},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogramMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot variogram maps â€” plotVariogramMap","title":"Plot variogram maps â€” plotVariogramMap","text":"Plot variogram maps show variogram directions grid distances x y coordinates.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogramMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot variogram maps â€” plotVariogramMap","text":"","code":"plotVariogramMap(   sfe,   features,   sample_id = \"all\",   plot_np = FALSE,   ncol = NULL,   colGeometryName = NULL,   annotGeometryName = NULL,   reducedDimName = NULL,   swap_rownames = NULL,   name = \"variogram_map\" )"},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogramMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot variogram maps â€” plotVariogramMap","text":"sfe SpatialFeatureExperiment object. features Features plot, must rownames gene count matrix, colnames colData colGeometry, colnames cell embeddings reducedDim, numeric indices dimension reduction components. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. plot_np Logical, whether plot number pairs distance bin instead variance. ncol Number columns facetting. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. reducedDimName Name dimension reduction, can seen reducedDimNames. colGeometryName annotGeometryName precedence reducedDimName. swap_rownames Column name rowData(object) used identify features instead rownames(object) labeling plot elements. found rowData, rownames gene count matrix used. name Name correlogram results stored, default \"sp.correlogram\".","code":""},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogramMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot variogram maps â€” plotVariogramMap","text":"ggplot object.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/plotVariogramMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot variogram maps â€” plotVariogramMap","text":"","code":"library(SFEData) sfe <- McKellarMuscleData() #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- colDataUnivariate(sfe, \"variogram_map\", features = \"nCounts\", width = 500, cutoff = 5000) plotVariogramMap(sfe, \"nCounts\")"},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dimension reduction components in space â€” spatialReducedDim","title":"Plot dimension reduction components in space â€” spatialReducedDim","text":"plotting value projection gene expression cell principal component space. present, function work 3D array geographically weighted PCA (GWPCA), future version deal GWPCA results.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dimension reduction components in space â€” spatialReducedDim","text":"","code":"spatialReducedDim(   sfe,   dimred,   ncomponents = NULL,   components = ncomponents,   colGeometryName = 1L,   sample_id = \"all\",   ncol = NULL,   ncol_sample = NULL,   annotGeometryName = NULL,   rowGeometryName = NULL,   rowGeometryFeatures = NULL,   annot_aes = list(),   annot_fixed = list(),   tx_fixed = list(),   exprs_values = \"logcounts\",   bbox = NULL,   tx_file = NULL,   image_id = NULL,   channel = NULL,   maxcell = 5e+05,   aes_use = c(\"fill\", \"color\", \"shape\", \"linetype\"),   divergent = FALSE,   diverge_center = NULL,   annot_divergent = FALSE,   annot_diverge_center = NULL,   size = 0,   shape = 16,   linewidth = 0,   linetype = 1,   alpha = 1,   color = NA,   fill = \"gray80\",   scattermore = FALSE,   pointsize = 0,   bins = NULL,   summary_fun = sum,   hex = FALSE,   show_axes = FALSE,   dark = FALSE,   palette = colorRampPalette(c(\"black\", \"white\"))(255),   normalize_channels = FALSE,   ... )"},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dimension reduction components in space â€” spatialReducedDim","text":"sfe SpatialFeatureExperiment object. dimred string integer scalar indicating reduced dimension result reducedDims(sfe) plot. ncomponents numeric scalar indicating number dimensions plot, starting first dimension. Alternatively, numeric vector specifying dimensions plotted. components numeric scalar vector specifying dimensions plotted. Use instead ncomponents plotting one dimension. colGeometryName Name colGeometry sf data frame whose numeric columns interest used compute metric. Use colGeometryNames look names sf data frames associated cells/spots. sample_id Sample(s) SFE object whose cells/spots use. Can \"\" compute metric samples; metric computed separately sample. ncol Number columns plotting multiple features. Defaults NULL, means using logic facet_wrap, used patchwork's wrap_plots default. ncol_sample plotting multiple samples facets, many columns facets. distinct ncols, multiple features. plotting multiple features multiple samples, result multi-panel plot panel plot feature facetted samples. annotGeometryName Name annotGeometry SFE object, annotate gene expression plot. rowGeometryName Name rowGeometry SFE object plot. rowGeometryFeatures features rowGeometry plot. Can small number avoid overplotting. Different features distinguished point shape. default (NULL), rowGeometryName specified, whichever items features also row names SFE object. features specified argument subset argument features, spots features specified plotted, differentiated point shape. annot_aes named list plotting parameters annotation sf data frame. names geom (ggplot2, color fill), values column names annotation sf data frame. Tidyeval supported. annot_fixed Similar annot_aes, fixed aesthetic settings, color = \"gray\". defaults relevant defaults function. tx_fixed Similar annot_fixed, specify fixed aesthetic transcript spots. exprs_values Integer scalar string indicating assay x contains expression values. bbox bounding box specify smaller region plot, useful dataset large. Can named numeric vector names \"xmin\", \"xmax\", \"ymin\", \"ymax\", order. plotting multiple samples, matrix sample IDs column names \"xmin\", \"ymin\", \"xmax\", \"ymax\" row names. multiple samples plotted bbox vector rather matrix, bounding box used samples. may see points edge geometries intersection bounding box geometry happens point . NULL, entire tissue plotted. tx_file File path GeoParquet file transcript spots wish load transcript spots SFE object. See formatTxSpots generating GeoParquet file. image_id ID image plot behind geometries. NULL, plotting images. Use imgData see image IDs present. plot multiple grayscale images different RGB channels, use named vector , whose names channel names (r, g, b), values image_ids corresponding images. RGB colorization may colorblind friendly. plotting multiple samples, assumed image_id used channel across different samples. channel Numeric vector indicating channels multi-channel image plot. NULL, grayscale plotted 1 channel RGB first 3 channels. numeric vector can named (r, g, b) indicate channel maps color. RGB colorization may colorblind friendly. argument specified image_id named vector plot different grayscale images different channels. maxcell Maximum number pixels plot image. image larger, resampled less number pixels save memory faster plotting. recommend reducing number plotting multiple facets. aes_use Aesthetic use discrete variables. continuous variables, always \"fill\" polygons point shapes 21-25. discrete variables, can fill, color, shape, linetype, whenever applicable. specified value changed applicable equivalent. example, geometry point \"linetype\" specified, \"shaped\" used instead. divergent Logical, whether divergent palette used. diverge_center divergent = TRUE, center palette diverge. NULL, centering. annot_divergent Just divergent, annotGeometry case different. annot_diverge_center Just diverge_center, annotGeometry case different. size Fixed size points. points defaults 0.5. Ignored size_by specified. shape Fixed shape points, ignored shape_by specified applicable. linewidth Width lines, including outlines polygons. polygons, defaults 0, meaning outlines. linetype Fixed line type, ignored linetype_by specified applicable. alpha Transparency. color Fixed color colGeometry color_by specified applicable, annotGeometry annot_color_by specified applicable. fill Similar color, fill. scattermore Logical, whether use scattermore package greatly speed plotting numerous points. used POINT colGeometries. geometry POINT, centroids used. Recommended plotting hundreds thousands cells cell polygons seen plotted due large number cells small plot size plotting multiple panels multiple features. pointsize Radius rasterized point scattermore. Default 0 single pixels (fastest). bins binning colGeometry space due large number cells spots, number bins, passed geom_bin2d geom_hex. NULL (default), colGeometry plotted without binning. binning, point geometry recommended. geometry point, centroids used. summary_fun Function summarize feature value colGeometry binned. hex Logical, whether use geom_hex. Note geom_hex broken ggplot2 version 3.4.0. Please update ggplot2 getting horizontal stripes hex = TRUE. show_axes Logical, whether show axes. dark Logical, whether use dark theme. using dark theme, palette lighter color represent higher values glowing dark. intended plotting gene expression top fluorescent images. palette Vector colors use color grayscale images. normalize_channels Logical, whether normalize channel image individually. FALSE bright field color images H&E set TRUE fluorescent images. ... arguments passed wrap_plots.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dimension reduction components in space â€” spatialReducedDim","text":"plotSpatialFeature. ggplot2 object   plotting one component. patchwork object plotting multiple   components.","code":""},{"path":[]},{"path":"https://pachterlab.github.io/voyager/reference/spatialReducedDim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dimension reduction components in space â€” spatialReducedDim","text":"","code":"library(SFEData) library(scater) sfe <- McKellarMuscleData(\"small\") #> see ?SFEData and browseVignettes('SFEData') for documentation #> loading from cache sfe <- logNormCounts(sfe) sfe <- runPCA(sfe, ncomponents = 2) spatialReducedDim(sfe, \"PCA\", ncomponents = 2, \"spotPoly\",     annotGeometryName = \"tissueBoundary\",     divergent = TRUE, diverge_center = 0 )  # Basically PC1 separates spots not on tissue from those on tissue."},{"path":"https://pachterlab.github.io/voyager/reference/variogram-internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute variograms â€” variogram-internal","title":"Compute variograms â€” variogram-internal","text":"Wrapper automap::autofitVariogram facilitate computing variograms multiple genes SFE objects EDA tool. functions written conform uniform format univariate methods called internally. functions exported, documentation written show users extra arguments use alling calculateUnivariate runUnivariate.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/variogram-internal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute variograms â€” variogram-internal","text":"","code":".variogram(x, coords_df, formula = x ~ 1, scale = TRUE, ...)  .variogram_bv(x, y, coords_df, scale = TRUE, map = FALSE, ...)  .cross_variogram(x, y, coords_df, scale = TRUE, ...)  .cross_variogram_map(x, y, coords_df, width, cutoff, scale = TRUE, ...)  .variogram_map(x, coords_df, formula = x ~ 1, width, cutoff, scale = TRUE, ...)"},{"path":"https://pachterlab.github.io/voyager/reference/variogram-internal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute variograms â€” variogram-internal","text":"x numeric vector whose variogram computed. coords_df sf data frame geometry regressors variogram modeling. formula formula defining response vector (possible) regressors, case absence regressors, use x ~ 1. scale Logical, whether scale x. Defaults TRUE variogram easier interpret comparable features different magnitudes length scale spatial autocorrelation interest. ... arguments passed automap::autofitVariogram model variogram alpha anisotropy. Note gstat fit ansotropic models get warning specify alpha. Nevertheless, plotting empirical anisotropic variograms comparing variogram fitted entire dataset can useful EDA tool. y bivariate, another numeric vector whose variogram computed. map logical; TRUE, cutoff width given, variogram map returned. requires package sp. Alternatively, map can passed, class SpatialDataFrameGrid (see sp docs) width width subsequent distance intervals data point pairs grouped semivariance estimates cutoff spatial separation distance point pairs included semivariance estimates; default, length diagonal box spanning data divided three.","code":""},{"path":"https://pachterlab.github.io/voyager/reference/variogram-internal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute variograms â€” variogram-internal","text":"autofitVariogram object.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-172-07302024","dir":"Changelog","previous_headings":"","what":"Version 1.7.2 (07/30/2024)","title":"Version 1.7.2 (07/30/2024)","text":"Fixed bug caused error computing Leeâ€™s L DelayedArray","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-171-07162024","dir":"Changelog","previous_headings":"","what":"Version 1.7.1 (07/16/2024)","title":"Version 1.7.1 (07/16/2024)","text":"Revamped user interface plotGeometry allow plotting multiple col, row, annot geometries Allow plotting transcript spots plotGeometry, plotSpatialFeature, plotLocalResult, spatialReducedDim","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-160-04292024","dir":"Changelog","previous_headings":"","what":"Version 1.6.0 (04/29/2024)","title":"Version 1.6.0 (04/29/2024)","text":"Option plot polygon geometry without fill plotGeometry Option show axes light dark themes Plot images classes BioFormatsImage ExtImage Colorize image plot different channels Assign different grayscale images channels Added plotImage plot image without plotting geometry","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-131-05152023","dir":"Changelog","previous_headings":"","what":"Version 1.3.1 (05/15/2023)","title":"Version 1.3.1 (05/15/2023)","text":"Removed functions arguments deprecated 1.2.0","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-127-09192023","dir":"Changelog","previous_headings":"","what":"Version 1.2.7 (09/19/2023)","title":"Version 1.2.7 (09/19/2023)","text":"Polygon boundaries show despite linewidth = 0 Windows users. Set color = NA polygons linewidth = 0 default work Windows.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-126-09192023","dir":"Changelog","previous_headings":"","what":"Version 1.2.6 (09/19/2023)","title":"Version 1.2.6 (09/19/2023)","text":"Fixed bug plotColGraph one multiple samples plotted. Allow 16 bit images spatial plotting functions. Removed adespatial Suggests â€™s used reference unit tests got removed CRAN.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-125-08182023","dir":"Changelog","previous_headings":"","what":"Version 1.2.5 (08/18/2023)","title":"Version 1.2.5 (08/18/2023)","text":"Use imgRaster getter rather S4 -@image get images plot, latter longer work SFE 1.2.3 wraps SpatRaster images saving RDS. Reading RDS wonâ€™t unwrap images need unwrapped â€™re needed.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-124-07042023","dir":"Changelog","previous_headings":"","what":"Version 1.2.4 (07/04/2023)","title":"Version 1.2.4 (07/04/2023)","text":"Remove useNames = NA warning calling MULTISPATI; warning comes generic colVars. Use algebraic eigenvalues MULTISPATI either nfposi nfnega 0 Added bins_contour argument moranPlot change number bins cell density contours","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-123-05042023","dir":"Changelog","previous_headings":"","what":"Version 1.2.3 (05/04/2023)","title":"Version 1.2.3 (05/04/2023)","text":"Fix bug plotting feature illegal name alongside another feature legal name Make sure runBivariate calculateBivariate use gene symbols results even Ensembl IDs specified swap_rownames set Change secondary sequential palette light theme YlOrRd â€™s distinguishable Blues primary palette low values","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-122-04262023","dir":"Changelog","previous_headings":"","what":"Version 1.2.2 (04/26/2023)","title":"Version 1.2.2 (04/26/2023)","text":"minor bugs: runBivariate gets correct feature names feature1 specified swap_rownames used show gene symbol Correct output cross variogram maps one pair genes Added default_attr localmoran_bvâ€™s SFEMethod Donâ€™t plot attribute localResult vector â€™s default attr plotting multiple features, panels follow order features specified Allow illegal characters names colData reducedDims plots Plot one component spatialReducedDim components argument Deprecate plotColDataBin2D plotRowDataBin2D","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-1112-04222023","dir":"Changelog","previous_headings":"","what":"Version 1.1.12 (04/22/2023)","title":"Version 1.1.12 (04/22/2023)","text":"Plot image behind geometries functions plot geometries Added dark theme support functions plot geometries","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-1111-04052023","dir":"Changelog","previous_headings":"","what":"Version 1.1.11 (04/05/2023)","title":"Version 1.1.11 (04/05/2023)","text":"Added MULTISPATI PCA Added multivariate local Gearyâ€™s C Anselin 2019 Added calculateMultivariate unified user interface multivariate spatial analyses Variogram variogram map gstat related plotting functions Allow non-standard names local results plotLocalResult","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-1110-03072023","dir":"Changelog","previous_headings":"","what":"Version 1.1.10 (03/07/2023)","title":"Version 1.1.10 (03/07/2023)","text":"Record parameters used get spatial results Force users use new name running method different parameters","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-119-02122023","dir":"Changelog","previous_headings":"","what":"Version 1.1.9 (02/12/2023)","title":"Version 1.1.9 (02/12/2023)","text":"Deprecated show_symbol argument, replacing swap_rownames consistent scater","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-117","dir":"Changelog","previous_headings":"","what":"Version 1.1.7","title":"Version 1.1.7","text":"Added bbox argument spatial plotting functions zoom bounding box","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-1010-02232023","dir":"Changelog","previous_headings":"","what":"Version 1.0.10 (02/23/2023)","title":"Version 1.0.10 (02/23/2023)","text":"Added plotColDataFreqpoly y axis needs log transformed. doesnâ€™t work stacked histograms using position = â€œidentityâ€ causes bars covered.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-109-02032023","dir":"Changelog","previous_headings":"","what":"Version 1.0.9 (02/03/2023)","title":"Version 1.0.9 (02/03/2023)","text":"Fixed bug hardcoded ncol plotDimLoadings.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-108-01262023","dir":"Changelog","previous_headings":"","what":"Version 1.0.8 (01/26/2023)","title":"Version 1.0.8 (01/26/2023)","text":"Flipped divergent palettes warm color means high value.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-107-01112023","dir":"Changelog","previous_headings":"","what":"Version 1.0.7 (01/11/2023)","title":"Version 1.0.7 (01/11/2023)","text":"Fixed bug assigning local results sample colData, colGeometry, annotGeometry.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-105-12022022","dir":"Changelog","previous_headings":"","what":"Version 1.0.5 (12/02/2022)","title":"Version 1.0.5 (12/02/2022)","text":"Removed aes_string(), deprecated. Fixed bug show_symbol = TRUE â€œsymbolâ€ column absent rowData.","code":""},{"path":"https://pachterlab.github.io/voyager/news/index.html","id":"version-100-11022022","dir":"Changelog","previous_headings":"","what":"Version 1.0.0 (11/02/2022)","title":"Version 1.0.0 (11/02/2022)","text":"First version Bioconductor Univariate local global spatial statistics based spdep Plotting functions: gene expression metadata space, results local spatial analyses, plot dimension reductions space, plot correlograms Monte Carlo simulation results","code":""}]
