---
title: "From geospatial to spatial transcriptomics based on SpatialFeatureExperiment"
author: "Lambda Moses, Lior Pachter"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
    BiocStyle::html_document:
        toc: true
        number_sections: true
        toc_depth: 3
        toc_float:
            collapsed: true
vignette: >
  %\VignetteIndexEntry{Overview of Voyager functionalities}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Voyager)
library(SpatialFeatureExperiment)
library(scater)
library(scran)
library(SFEData)
library(sf)
library(ggplot2)
library(scales)
library(patchwork)
library(sparseMatrixStats)
library(BiocParallel)
library(bluster)
theme_set(theme_bw(10))
```

# Introduction
In single cell RNA-seq (scRNA-seq), data and metadata can be represented with `SingleCellExperiment` or `Seurat` objects, and basic exploratory data analyses and visualization performed with `scater`, `scran`, and `scuttle`, or `Seurat`. The `SpatialFeatureExperiment` package and S4 class extending `SpatialExperiment` and `SingleCellExperiment` brings EDA methods for vector spatial data to spatial transcriptomics. `Voyager` to `SpatialFeatureExperiment` is just like `scater`, `scran`, and `scuttle` to `SingleCellExperiment`, implementing basic exploratory spatial data analysis (ESDA) and visualization methods. Non-spatial statistical methods often assume that the samples (cells, spots) are independent, which is not the case in spatial data, where nearby samples tend to be more similar (i.e. spatial autocorrelation). Much of ESDA is dedicated to spatial autocorrelation, such as finding whether it is present, and if so what's its length scale. 

This vignette gives an overview of these spatial EDA methods, functionalities of the `Voyager` package, and applications of the `SpatialFeatureExperiment` class with a published Visium dataset.

# Dataset
The dataset used in this vignette comes from [Large-scale integration of single-cell transcriptomic data captures transitional progenitor states in mouse skeletal muscle regeneration](https://doi.org/10.1038/s42003-021-02810-x). Notexin was injected into the tibialis anterior muscle to induce injury, and the healing muscle was collected 2, 5, and 7 days post injury for Visium. The dataset here is from the 2 day timepoint. The dataset is in a `SpatialFeatureExperiment` (SFE) object.

The gene count matrix was directly downloaded from GEO. All 4992 spots, whether in tissue or not, are included. The H&E image was used for nuclei and myofiber segmentation. A subset of nuclei from randomly selected regions from all 3 timepoints were manually annotated to train a StarDist model to segment the rest of the nuclei, and the myofibers were all manually segmented. 

Tissue boundary, nuclei, myofiber, and Visium spot polygons are stored as `sf` data frames in the SFE object. See the vignette of the `SpatialFeatureExperiment` for more details on the structure of the SFE object. The SFE object of this dataset is provided in the `SFEData` package.

```{r}
(sfe <- McKellarMuscleData("full"))
```

The H&E image of this section:
```{r, echo=FALSE, out.width = "100%", fig.cap="Low resolution H&E image of the tissue section"}
knitr::include_graphics("tissue_lowres_5a.jpeg")
```

# Exploratory data analysis
## All spots
```{r}
names(colData(sfe))
```

Total UMI counts (`nCounts`), number of genes detected per spot (`nGenes`), and proportion of mitochondrially encoded counts (`prop_mito`) have been precomputed and are in `colData(sfe)`. The `plotSpatialFeature` function plots any gene, `colData` values, and geometry attributes in `colGeometry` and `annotGeometry` in space. The Visium spots are plotted as polygons reflecting their actual size relative to the tissue, rather than points as in other packages that plot Visium data. Behind the scene, `geom_sf` is used to plot the geometries.

The tissue boundary was found by thresholding the H&E image and removing small polygons that are most likely debris. The `in_tissue` column of `colData(sfe)` indicates which Visium spot polygon intersects the tissue polygon; this can be found with `SpatialFeatureExperiment::annotPred()` but is beyond the scope of this vignette.

```{r}
plotSpatialFeature(sfe, features = "nCounts", colGeometryName = "spotPoly",
                   annotGeometryName = "tissueBoundary")
```

```{r}
plotSpatialFeature(sfe, features = "nGenes", colGeometryName = "spotPoly",
                   annotGeometryName = "tissueBoundary")
```

```{r}
plotSpatialFeature(sfe, features = "prop_mito", colGeometryName = "spotPoly",
                   annotGeometryName = "tissueBoundary")
```

Spots off tissue have higher proportion of mitochondrially encoded counts, as an artifact of tissue permeablization. The notexin injury site is around the middle of the tissue in the y direction. Spots on tissue that also have high mitochondrial proportion are on myofibers, which have more mitochondria.

The different `colData` columns can also be plotted together (using the `patchwork` package), though the panels may become too small to read. Each feature, whether `colData` or gene expression, will have its own color scale so a feature with much larger values than others won't throw off the dynamic range.
```{r, fig.width=8, fig.height=3}
plotSpatialFeature(sfe, features = c("nCounts", "nGenes", "prop_mito"), 
                   colGeometryName = "spotPoly",
                   annotGeometryName = "tissueBoundary")
```

Since SFE inherits from `SingleCellExperiment` (SCE), the plotting functions from `scater` can still be used.
```{r}
plotColData(sfe, x = "nCounts", y = "nGenes", colour_by = "in_tissue")
```

Unlike in the typical scRNA-seq dataset, this plot appears to have two "branches", which might make more sense in the next section when we explore more characteristics of this tissue section.

```{r}
plotColData(sfe, x = "nCounts", y = "prop_mito", colour_by = "in_tissue")
```

```{r}
plotColData(sfe, y = "nCounts", x = "in_tissue", colour_by = "in_tissue") +
  plotColData(sfe, y = "nGenes", x = "in_tissue", colour_by = "in_tissue") +
  plotColData(sfe, y = "prop_mito", x = "in_tissue", colour_by = "in_tissue") &
  theme(legend.position = "none")
```

## Spots in tissue
Only spots that intersect tissue will be used for further analyses. While `scran` is used for data normalization here for demonstration purposes and to make the data more normally distributed, we do not mean that it is the best practice in normalizing spatial transcriptomics data, as we don't know what the best practice really should be. As seen in the `nCounts` plot in space above, spatial autocorrelation is evident. In Visium, reverse transcription occurs in situ on the spots, but PCR amplification occurs after the cDNA is dissociated from the spots. Then artifacts introduced from the amplification step would not be spatial. Spatial artifacts may arise from diffusion of transcripts to adjacent spots and tissue permeablization. However, given how the total counts seem to correspond to histological regions, the total counts may have a biological component and hence should not be treated as a technical artifact to be normalized away as in scRNA-seq data normalization methods. 
```{r}
sfe_tissue <- sfe[,colData(sfe)$in_tissue]
sfe_tissue <- sfe_tissue[rowSums(counts(sfe_tissue)) > 0,]
```

```{r}
clusters <- quickCluster(sfe_tissue)
sfe_tissue <- computeSumFactors(sfe_tissue, clusters=clusters)
sfe_tissue <- logNormCounts(sfe_tissue)
```

Myofiber and nuclei segmentation polygons are available in this dataset, in the field `annotGeometries`. Myofibers were manually segmented, and nuclei were segmented with [`StarDist`](https://github.com/stardist/stardist), trained with a manually segmented subset. 

```{r}
annotGeometryNames(sfe_tissue)
```

### From myofibers and nuclei to Visium spots
The `plotSpatialFeature` function can also be used to plot attributes of geometries, i.e. the non-geometry columns in the `sf` data frames in the `rowGeometries`, `colGeometries`, or `annotGeometries` fields in the SFE object. For `rowGeometries` and `colGeometries`, such columns associated with the `sf` data frames rather than `rowData` or `colData` are allowed because one can specify how these columns associate with the geometries (see [`st_agr`](https://r-spatial.github.io/sf/reference/st_agr.html) and [documentation of `st_sf`](https://r-spatial.github.io/sf/reference/sf.html#details-1)). When an attribute of an `annotGeometry` is plotted along side gene expression or `colData` or `colGeometry` attribute, the `annotGeometry` attribute is plotted with a different color palette to distinguish from the column associated values. 

Here, from the `annotGeometries`, the myofiber polygons are plotted, colored by cross section area as observed in this tissue section. The `aes_use` argument is set to `color` rather than `fill` (default for polygons) to only plot the Visium spot outlines to make the myofiber polygons more visible. The `fill` argument is set to `NA` to make the Visium spots look hollow, and the `size` argument controls the thickness of the outlines. The `annot_aes` argument specifies which column in the `annotGeometry` to use to specify the values of an aesthstic, just like `aes` in `ggplot2` (`aes_string` to be precise, since `tidyeval` is not used here). The `annot_fixed` argument (not used here) can set the fixed size, alpha, color, and etc. for the `annotGeometry`. 
```{r}
plotSpatialFeature(sfe_tissue, features = "nCounts", 
                   colGeometryName = "spotPoly",
                   annotGeometryName = "myofiber_simplified", 
                   annot_aes = list(fill = "area"), 
                   aes_use = "color", size = 0.5, fill = NA)
```

The larger myofibers seem to have fewer total counts, possibly because the larger size of these myofibers dilute the transcripts. If this is the case, then data normalization would be relevant to correct for this. 

With `SpatialFeatureExperiment`, we can find the number of myofibers and nuclei that intersect each Visium spot. The predicate can be [anything implemented in `sf`](https://r-spatial.github.io/sf/reference/geos_binary_pred.html), so for example, the number of nuclei fully covered by each Visium spot can also be found. The default predicate is `st_intersects`.
```{r}
colData(sfe_tissue)$n_myofibers <- 
  annotNPred(sfe_tissue, colGeometryName = "spotPoly",
             annotGeometryName = "myofiber_simplified")
colData(sfe_tissue)$n_nuclei <- 
  annotNPred(sfe_tissue, colGeometryName = "spotPoly",
             annotGeometryName = "nuclei")
```

We can also find the intersection geometries between each myofiber and Visium spot, and compute their areas.
```{r}
myofiber_in_spot <- annotOp(sfe_tissue, colGeometryName = "spotPoly",
                            annotGeometryName = "myofiber_simplified")
colData(sfe_tissue)$prop_myofiber <- 
  st_area(myofiber_in_spot) / st_area(spotPoly(sfe_tissue))
```

Moreover, some spots are at the margin of the tissue and don't fully cover tissue. Here we can find the proportion of area in each spot occupied by tissue.
```{r}
tissue_in_spot <- annotOp(sfe_tissue, "spotPoly", "tissueBoundary")
colData(sfe_tissue)$prop_tissue <- 
  st_area(tissue_in_spot) / st_area(spotPoly(sfe_tissue))
```

```{r, fig.width=8, fig.height=4}
plotSpatialFeature(sfe_tissue, 
                   features = c("n_myofibers", "n_nuclei", "prop_myofiber"),
                   colGeometryName = "spotPoly")
```

The injury site infiltrated with immune cells have more nuclei; this is apparent from the H&E image, but is quantified here.

There is no one to one mapping between Visium spots and myofibers and nuclei. However, we may want to relate attributes of myofibers and nuclei to gene expression detected at the Visium spots. One way to do so is to summarize the attributes of all myofibers or nuclei that intersect (or choose another better predicate implemented in `sf`) each spot, such as to calculate the mean, median, or sum. This can be done with the `annotSummary` function in `SpatialFeatureExperiment`. The default predicate is `st_intersects`, and the default summary function is `mean`.
```{r}
colData(sfe_tissue)$mean_myofiber_area <- 
  annotSummary(sfe_tissue, "spotPoly", "myofiber_simplified", 
               annotColNames = "area")[,1] # it always returns a data frame
```

```{r}
# The gray spots don't intersect any myofiber
plotSpatialFeature(sfe_tissue, "mean_myofiber_area", "spotPoly")
```

Now we can see how the mean area of myofibers intersecting each Visium spot relates to other aspects of the spots such as total counts and gene expression.
```{r}
plotColData(sfe_tissue, x = "mean_myofiber_area", y = "nCounts", colour_by = "n_myofibers")
```

The NAs are for spots not intersecting any myofibers, e.g. those in the inflammatory region. There seem to be two clusters: spots with smaller mean myofiber area and larger total counts, and spots with larger mean myofiber area and smaller total counts. Indeed, spots with smaller mean myofiber area tend to have a larger number of myofibers; that the myofibers are smaller is the reason why there are more of them intersecting each spot.

```{r}
plotColData(sfe_tissue, x = "nCounts", y = "nGenes", colour_by = "mean_myofiber_area")
```

```{r}
plotColData(sfe_tissue, x = "nCounts", y = "nGenes", colour_by = "n_myofibers")
```

```{r}
plotColData(sfe_tissue, x = "nCounts", y = "nGenes", colour_by = "n_nuclei")
```

Mean myofiber area, number of myofibers per spot, and number of nuclei per spot seem to be related to the two branches in the nGenes vs. nCounts plot. The upper branch includes the inflamed injury site with lots of immune cells and devoid of myofibers and the adjacent region with larger myofibers.

How does total UMI count relate to the number of nuclei per spot?
```{r}
plotColData(sfe_tissue, x = "nCounts", y = "n_nuclei", 
            colour_by = "n_myofibers")
```

Also coloring by proportion of area of each spot in tissue, highlighting spots at the margin.
```{r}
plotColData(sfe_tissue, x = "nCounts", y = "n_nuclei", 
            colour_by = "prop_tissue")
```

There might not be a clear relationship. There are some spots with both low total counts and small number of nuclei; those are at the margin of the tissue and don't fully cover tissue. There are also some spots with relatively low total counts and large number of nuclei.

How do the number and proportion area of myofibers per spot relate to the number of nuclei per spot?

```{r}
# Use geom_jitter to address overplotting due to integer number of myofibers
colData(sfe_tissue) %>% 
  as.data.frame() %>% 
  ggplot(aes(n_myofibers, n_nuclei, color = prop_myofiber)) +
  geom_jitter(alpha = 0.5, width = 0.2) +
  scale_color_viridis_c() +
  # For a consistent look
  cowplot::theme_cowplot(10) +
  # Set Q to avoid non-integer labels on x axis
  scale_x_continuous(breaks = breaks_pretty(Q = c(1,2,4,5)))
```

Spots interseting larger number of myofibers and fully covering myofibers tend to have fewer nuclei, which is expected as nuclei are at the margins of mature myofibers. However, in later time points (data not included in `SFEData` yet), some small myofibers have nuclei in the center -- those are nascent myofibers where the nuclei have not yet migrated to the periphery.

### Proportion of mitochondrial counts
How does the number of myofibers relate to total counts and proportion of mytochondrial counts?
```{r}
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = "n_myofibers")
```

```{r}
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = "prop_myofiber")
```

How total UMI counts relate to proportion of mitochondrial counts here is very different from what we usually see in scRNA-seq data, i.e. a cluster of cells with low total counts and high proportion of mitochondrial counts. Here we see two clusters, one with lower total counts and lower proportion of mitochondrial counts, and another higher in both. The two clusters seem to be associated with spots being in myofibers, as spots in the upper cluster tend to intersect with a larger number of myofibers. However, some spots in the lower cluster are also entirely within myofibers, but they tend to have a smaller number of myofibers. This might be due to different types of myofibers. The tibialis anterior is a fast twitch muscle with predominantly type II myofibers. Type IIx myofibers are more anaerobic, have larger diameters, and have fewer mitochondria. Type IIa myofibers are more aerobic, have smaller diameters, and have more mitochondria.

How does myofiber area relate to proportion of mitochondrial counts?

```{r}
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = "mean_myofiber_area")
```

Visium spots intersecting with larger myofibers are mostly in the lower cluster, with lower proportion of mitochondrial counts. This seems consistent with that larger and more anaerobic myofibers tend to have fewer mitochondria, but we'll check the myofiber type marker genes to verify.

### Myofiber types
Marker genes: Myh7 (Type I), Myh2 (Type IIa), Myh4 (Type IIb), Myh1 (Type IIx), from [this protocol](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5526362/)
```{r}
markers <- c(I = "Myh7", IIa = "Myh2", IIb = "Myh4", IIx = "Myh1")
```

First look at Type I myofibers. Again, this is a fast twitch muscle, so we don't expect many slow twitch Type I myofibers. Row names in `sfe_tissue` are Ensembl IDs, to avoid ambiguity as sometimes multiple Ensembl IDs have the same gene symbol and some genes have aliases in symbol. However, gene symbols are shorter and more human readable than Ensembl IDs, and are nice to show on plots.  In the `plotSpatialFeature` function and other functions in `Voyager`, even when the actual row names are Ensembl IDs, the `features` argument can take gene symbols if there is a column called "symbols" in `rowData(sfe)`, where the function converts the gene symbols to Ensembl IDs. By default, gene symbols are shown on the plot, but the `show_symbol` argument can be set to `FALSE` to show Ensembl IDs instead. If one gene symbol matches multiple Ensembl IDs in the dataset, then a warning will be given.

The `exprs_values` argument specifies the assay to use, which is by default "logcounts", i.e. the log normalized data. Again, this default may or may not be best practice given that total UMI counts may have biological relevance in spatial data. Therefore we are plotting both the raw counts and the log normalized counts here.
```{r}
# Function specific for this vignette, with some hard coded values
plot_counts_logcounts <- function(sfe, feature) {
  p1 <- plotSpatialFeature(sfe, feature, "spotPoly",
                   annotGeometryName = "myofiber_simplified", 
                   annot_aes = list(fill = "area"), aes_use = "color",
                   fill = NA, size = 0.5, show_symbol = TRUE, 
                   exprs_values = "counts") +
    ggtitle("Raw counts")
  p2 <- plotSpatialFeature(sfe, feature, "spotPoly",
                   annotGeometryName = "myofiber_simplified", 
                   annot_aes = list(fill = "area"), aes_use = "color",
                   fill = NA, size = 0.5, show_symbol = TRUE, 
                   exprs_values = "logcounts") +
    ggtitle("Log normalized counts")
  p1 + p2 +
    plot_annotation(title = feature)
}
```

```{r}
plot_counts_logcounts(sfe_tissue, markers["I"])
```

There are indeed few Type I myofibers, and they tend to be smaller.
```{r}
gene_id <- rownames(sfe_tissue)[rowData(sfe_tissue)$symbol == markers["I"]]
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = gene_id)
```

The Type I myofibers also tend to have higher proportion of mitochondrial counts.

```{r}
plot_counts_logcounts(sfe_tissue, markers["IIa"])
```

Type IIa myofibers also tend to be clustered together on left side of the tissue.

```{r}
gene_id <- rownames(sfe_tissue)[rowData(sfe_tissue)$symbol == markers["IIa"]]
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "logcounts")
```

Spots with Type IIa myofibers tend to have higher proportion of mitochondrial counts, mostly in the upper cluster in this plot. However, some of these spots are in the lower cluster. As Visium spots can intersect with multiple myofibers, these spots might have both Type IIa and some more anaerobic myofibers.

```{r}
plotColData(sfe_tissue, x = "mean_myofiber_area", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "logcounts")
```

Plotting proportion of mitochondrial counts vs. mean myofiber area, we also see two clusters, one with higher proportion of mitochondrial counts and smaller area, and another with lower proportion of mitochondrial counts and on average slightly larger area. Type IIa myofibers tend to have small area and larger proportion of mitochondrial counts.

```{r}
plot_counts_logcounts(sfe_tissue, markers["IIb"])
```

While the raw counts suggest that Type IIb myofibers tend to aggregate at the top region of this section and away from Type IIa myofibers, data normalization made expression of Myh4 seem ubiquitous even in regions without myofibers.

```{r}
gene_id <- rownames(sfe_tissue)[rowData(sfe_tissue)$symbol == markers["IIb"]]
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "counts")
```

In raw counts, spots with high Myh4 expression, indicating Type IIb, also tend to have somewhat high mitochondrial count proportion (still in the upper cluster), but not as high as Type IIa.

```{r}
plotColData(sfe_tissue, x = "mean_myofiber_area", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "counts")
```

Type IIb myofibers tend to be larger than type IIa myofibers.

```{r}
plot_counts_logcounts(sfe_tissue, markers["IIx"])
```

```{r}
gene_id <- rownames(sfe_tissue)[rowData(sfe_tissue)$symbol == markers["IIx"]]
plotColData(sfe_tissue, x = "nCounts", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "logcounts")
```

If the markers are correct, then Type IIx myofibers seem to colocalize with Type IIa in this dataset, or as in [scRNA-seq data](https://skeletalmusclejournal.biomedcentral.com/articles/10.1186/s13395-021-00269-2), not as clear cut as in protein expression, myofibers often coexpress Myh1 and Myh2 transcripts, but Type IIa myofibers have greater proportion of Myh2 and Type IIx have greater proportion of Myh1 and there maybe cell hybrids.

```{r}
plotColData(sfe_tissue, x = "mean_myofiber_area", y = "prop_mito", 
            colour_by = gene_id, by_exprs_values = "logcounts")
```

## rowData
Spatial dependence analyses are performed on features, which can be gene expression, `colData`, `colGeometry` attributes, or `annotGeometry` attributes. For gene expression, the results are stored in `rowData`, which is metadata for the genes, inherited from `SummarizedExperiment`. For `colData`, `colGeometry`, and `annotGeometry`, the results are stored in an attribute called `featureData` of `colData` or the `colGeometry` or `annotGeometry` of interest. This section demonstrates some more utilities of `rowData`, which Seurat doesn't have. 

Here mean, variance, and CV2 of genes are computed and stored in `rowData`, so they will be subsetted when rows of the SFE object are subsetted. However, in these cases, the values are no longer valid when columns of the SFE object are subsetted. Nevertheless, it's still helpful to store gene attributes that are independent from the cells/spots such as gene symbol, biotype, and genomic coordinates.

```{r}
rowData(sfe_tissue)$means <- rowMeans(counts(sfe_tissue))
rowData(sfe_tissue)$vars <- rowVars(counts(sfe_tissue))
rowData(sfe_tissue)$cv2 <- rowData(sfe_tissue)$vars/rowData(sfe_tissue)$means^2
```

To show overdispersion, compared to Poisson (mean = var, red line), and density of points in the plot is shown with the contours
```{r}
plotRowData(sfe_tissue, x = "means", y = "vars") +
  scale_x_log10() + scale_y_log10() +
  geom_density2d() +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  coord_equal()
```

To show overdispersion, with CV2 (red line is what's expected from Poisson distribution)
```{r}
plotRowData(sfe_tissue, x = "means", y = "cv2") +
  scale_x_log10() + scale_y_log10() +
  geom_density2d() +
  geom_abline(intercept = 0, slope = -1, color = "red") +
  coord_equal()
```

# Spatial neighborhood graphs
A spatial neighborhood graph is required to compute spatial dependency metrics such as Moran's I and Geary's C. The `SpatialFeatureExperiment` package wraps methods in `spdep` to find spatial neighborhood graphs, which are stored within the SFE object (see `spdep` documentation for [`gabrielneigh`](https://r-spatial.github.io/spdep/reference/graphneigh.html), [`knearneigh`](https://r-spatial.github.io/spdep/reference/knearneigh.html), [`poly2nb`](https://r-spatial.github.io/spdep/reference/poly2nb.html), and [`tri2nb`](https://r-spatial.github.io/spdep/reference/tri2nb.html)). The `Voyager` package then uses these graphs for spatial dependency analyses, again based on `spdep` in this first version, but methods from other geospatial packages, some of which also use the spatial neighborhood graphs, may be added later as needed.

For Visium, where the spots are in a hexagonal grid, the spatial neighborhood graph is straightforward. However, for spatial technologies with single cell resolution (e.g. MERFISH) and in this dataset, the myofibers and nuclei, many different methods can be used to find the spatial neighborhood graph. Here for myofibers, the method "poly2nb" identifies myofiber polygons that are physically touch each other. `zero.policy = TRUE` will allow singletons or nodes without neighbors in the graph; in the inflamed region, there are more singletons. We have not yet benchmarked which spatial neighborhood method is the "best" in which situation; the particular method used here is for demonstration purpose and may or may not be best practice. 

```{r}
colGraph(sfe_tissue, "visium") <- findVisiumGraph(sfe_tissue)
annotGraph(sfe_tissue, "myofiber_poly2nb") <- 
  findSpatialNeighbors(sfe_tissue, type = "myofiber_simplified", MARGIN = 3,
                       method = "poly2nb", zero.policy = TRUE)
```

The `plotColGraph` function plots the graph in space associated with a `colGeometry`, along with the geometry of interest.
```{r}
plotColGraph(sfe_tissue, colGraphName = "visium", colGeometryName = "spotPoly")
```

Similarly, the `plotAnnotGraph` function plots the graph associated with an `annotGeometry`, along with the geometry of interest. 
```{r}
plotAnnotGraph(sfe_tissue, annotGraphName = "myofiber_poly2nb", 
               annotGeometryName = "myofiber_simplified")
```

There is no `plotRowGraph` yet since we haven't worked with a dataset where spatial graphs related to genes are relevant, although the SFE object supports row graphs.

# Exploratory _spatial_ data analysis
All spatial autocorrelation metrics in this package can be computed directly on a vector or a matrix rather than an SFE object. The user interface emulates those of dimension reductions in the `scater` package (e.g. `calculateUMAP` that takes in a matrix or SCE object and returns a matrix, and `runUMAP` that takes in an SCE object and adds the results to the `reducedDims` field of the SCE object). So `calculate*` functions take in a matrix or an SFE object and directly return the results (format of the results depends on the structure of the results), while `run*` functions take in an SFE object and add the results to the object.

## Univariate
In this first version, `Voyager` only supports univariate global spatial autocorrelation implemented in `spdep` for ESDA: Moran's I and Geary's C, permutation testing for Moran's I and Geary's C, Moran plot, and correlograms. In addition, beyond `spdep`, `Voyager` can cluster Moran plots and correlograms. Plotting functions taking in SFE objects are implemented to plot the results with `ggplot2` and with more customization options than `spdep` plotting functions.

To demonstrate spatial autocorrelation in gene expression, top highly variable genes (HVGs) are used. The HVGs are found with the `scran` method.
```{r}
dec <- modelGeneVar(sfe_tissue)
hvgs <- getTopHVGs(dec, n = 50)
```

### Moran's I
There are several ways to quantify spatial autocorrelation, the most common of which is Moran's I:

$$
I = \frac{n}{\sum_{i=1}^n \sum_{j=1}^n w_{ij}} \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i - \bar{x})^2}
$$

Where $n$ is the number of spots or locations, $i$ and $j$ are different locations, or spots in the Visium context, $x$ is a variable with values at each location, and $w_{ij}$ is a spatial weight, which can be inversely proportional to distance between spots or an indicator of whether two spots are neighbors, subject to various definitions of neighborhood and whether to normalize the number of neighbors. The `spdep` package uses the neighborhood. 

Moran's I takes values between -1 and 1. For positive spatial autocorrelation, i.e. nearby spots tend to be more similar, Moran's I will be positive. For negative spatial autocorrelation, i.e. nearby spots tend to be more dissimilar, Moran's I will be negative. When the variable is distributed in space randomly like salt and pepper, then Moran's I will be around 0. Positive Moran's I indicates global structure, while negative Moran's I indicates local structure.

Upon visual inspection, total UMI counts per spot seem to have spatial autocorrelation. A spatial neighborhood graph is required to compute Moran's I, and is specified with the `listw` argument. Also, if the metrics are computed for a large number of features, parallel computing is supported, with `BiocParallel`, with the `BPPARAM` argument.

For matrices, the rows are the features, as in the gene count matrix.
```{r}
# Directly use vector or matrix, and multiple features can be specified at once
calculateMoransI(t(colData(sfe_tissue)[,c("nCounts", "nGenes")]), 
                 listw = colGraph(sfe_tissue, "visium"))
```

I is Moran's I, and K is sample kurtosis.

To add the results to the SFE object, specifically for colData:
```{r}
sfe_tissue <- colDataMoransI(sfe_tissue, features = c("nCounts", "nGenes"),
                             colGraphName = "visium")
head(colFeatureData(sfe_tissue), 10)
```

For `colData`, the results are added to `colFeatureData(sfe)`, and features for which Moran's I is not calculated have NA. The column names of `featureData` distinguishes between different samples (there's only one sample in this dataset), and are parsed by plotting functions. 

To add the results to the SFE object, specifically for geometries: Here "area" is the area of the cross section of each myofiber as seen in this tissue section, "eccentricity" is the eccentricity of the ellipse fitted to each myofiber, convexity is the ratio between the actual area of each myofiber and that of its convex hull, and "sine_theta" is the sine of the angle of the fitted ellipse from a reference indicating orientation (sine because 0 degrees and 180 degrees are the same orientation though the values are very different).
```{r}
# Remember zero.policy = TRUE since there're singletons
sfe_tissue <- annotGeometryMoransI(sfe_tissue, 
                                   features = c("area", "eccentricity", 
                                                "convexity", "sine_theta"), 
                                   annotGeometryName = "myofiber_simplified",
                                   annotGraphName = "myofiber_poly2nb", 
                                   zero.policy = TRUE)
head(attr(annotGeometry(sfe_tissue, "myofiber_simplified"), "featureData"))
```

For a non-geometry column in a `colGeometry`, `colGeometryMoransI` is like `annotGeometryMoransI` here, but none of the `colGeometries` in this dataset has extra columns.

For gene expression, the `logcounts` assay is used by default (use the `exprs_values` argument to change the assay), though this may or may not be best practice.
```{r}
sfe_tissue <- runMoransI(sfe_tissue, features = hvgs, colGraphName = "visium", 
                         BPPARAM = MulticoreParam(2))
rowData(sfe_tissue)[head(hvgs),]
```

### Geary's C
Another spatial autocorrelation metric is Geary's C, defined as:

$$
C = \frac{(n-1)}{2\sum_{i=1}^n \sum_{j=1}^n w_{ij}} \frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}(x_i - x_j)^2}{{\sum_{i=1}^n (x_i - \bar{x})^2}}
$$

Geary's C well below 1 indicates positive spatial autocorrelation, and above 1 indicates negative spatial autocorrelation.

Simply substitute "MoransI" in the names of the functions in the previous section with "GearysC" to compute Geary's C for features of interest and add the results to the SFE object. For example, for `colData`
```{r}
sfe_tissue <- colDataGearysC(sfe_tissue, features = c("nCounts", "nGenes"),
                             colGraphName = "visium")
head(colFeatureData(sfe_tissue), 10)
```

There's only one column for K since it's the same for Moran's I and Geary's C. Here both Moran's I and Geary's C suggest positive spatial autocorrelation for `nCounts` and `nGenes`.

### Permutation testing
Is the spatial autocorrelation statistically significant? The `moran.test` function in `spdep` can give an analytic p-value but the p-value would not be accurate if the data is not normally distributed. As gene expression data is generally not normally distributed and data normalization doesn't necessarily make the data that close to a normal distribution, permutation testing is used in this package to test the significance of Moran's I and Geary's C, wrapping [`moran.mc` in `spdep`](https://r-spatial.github.io/spdep/reference/moran.mc.html). Just like Moran's I, there's `calculateMoranMC` and `calculateGearyMC` functions to directly return the results, and `colDataMoranMC`, `colGeometryMoranMC`, `annotGeometryMoranMC`, and `runMoranMC` to add the results to the SFE object. MC stands for Monte Carlo. The `nsim` argument specifies the number of simulations. 

For matrices, the results are a named list, each element of which is for each feature.
```{r}
calculateMoranMC(t(colData(sfe_tissue)[,c("nCounts", "nGenes")]), 
                 listw = colGraph(sfe_tissue, "visium"), nsim = 100)
```

Or add it to the SFE object
```{r}
sfe_tissue <- colDataMoranMC(sfe_tissue, features = c("nCounts", "nGenes"), 
                             colGraphName = "visium", nsim = 100)
head(colFeatureData(sfe_tissue), 10)
```

Note that while the test is performed for multiple features, the p-values here are not corrected for multiple hypothesis testing.

The results can be plotted:
```{r}
plotMoranMC(sfe_tissue, c("nCounts", "nGenes"))
```

By default, the colorblind friendly palette from `dittoSeq` is used for categorical variables. The density is of Moran's I from the simulations where the values are permuted and disconnected from spatial locations, and the vertical line is the actual Moran's I value. The simulation indicates that the spatial autocorrelation is significant. 

When there're multiple samples, the plot will by default be facetted by sample. But it can also be facetted by feature; in this case, when there're multiple samples, samples will be colored instead of features so spatial autocorrelation for the same features can be compared across samples.
```{r}
plotMoranMC(sfe_tissue, c("nCounts", "nGenes"), facet_by = "feature")
```

Each function for Moran MC has a Geary's C equivalent (e.g. `runGearyMC`). 
```{r}
sfe_tissue <- colDataGearyMC(sfe_tissue, features = c("nCounts", "nGenes"), 
                             colGraphName = "visium", nsim = 100)
```

```{r}
plotMoranMC(sfe_tissue, c("nCounts", "nGenes"), name = "GearyMC")
```

Also see some myofiber morphological metrics
```{r}
sfe_tissue <- annotGeometryMoranMC(sfe_tissue, 
                                   features = c("area", "eccentricity", 
                                                "convexity", "sine_theta"), 
                                   annotGeometryName = "myofiber_simplified",
                                   annotGraphName = "myofiber_poly2nb", 
                                   zero.policy = TRUE, nsim = 100)
```

Specify `annotGeometryName` to make the `plotMoranMC` function look for results in the `annotGeometry` of interest.
```{r}
plotMoranMC(sfe_tissue, 
            features = c("area", "eccentricity", "convexity", "sine_theta"),
            annotGeometryName = "myofiber_simplified")
```

Here all 4 morphological metrics have positive spatial autocorrelation, but myofiber area is more strongly autocorrelated. 

This can also be done to gene expression, again, by default, using the "logcounts" assay.
```{r}
sfe_tissue <- runMoranMC(sfe_tissue, hvgs[1:5], colGraphName = "visium", nsim = 100)
```

Although the row names of `sfe_tissue` are actually Ensembl IDs, the human readable gene symbols are shown in the plots by default.
```{r}
plotMoranMC(sfe_tissue, features = hvgs[1:5])
```

The vertical lines for Car3 and Myh2 overlap but they're not the same value (see results of `runMoransI` above). To show Ensembl IDs instead (note that the colors are not linked to the genes and are assigned to genes in alphabetical order of the symbol or ID):

```{r}
plotMoranMC(sfe_tissue, features = hvgs[1:5], show_symbol = FALSE)
```

These genes have positive spatial autocorrelation that is stronger than total counts.

### Correlogram
What's the length scale of the spatial autocorrelation? In a correlogram, spatial autocorrelation of higher orders of neighbors (e.g. second order neighbors are neighbors of neighbors) is calculated to see how it decays over the orders. In Visium, with the regular hexagonal grid, order of neighbors is a proxy for distance. For more irregular patterns such as single cells, different methods to find the spatial neighbors may give different results. Functions to compute correlograms wrap [`sp.correlogram` in `spdep`](https://r-spatial.github.io/spdep/reference/sp.correlogram.html), and have the same pattern of `calculate*` and `run*` as the Moran's I and permutation test functions, except for the `order` argument specifying the maximum order of neighbors.

For `colData`, Moran's I correlogram:
```{r}
sfe_tissue <- colDataCorrelogram(sfe_tissue, c("nCounts", "nGenes"),
                                 colGraphName = "visium", order = 10)
```

The results can be plotted with `plotCorrelogram`
```{r}
plotCorrelogram(sfe_tissue, c("nCounts", "nGenes"))
```

The error bars are twice the standard deviation of the Moran's I value. The standard deviation and p-values (null hypothesis is that Moran's I is 0) come from `moran.test` (for Geary's C correlogram, `geary.test`); these should be taken with a grain of salt for data that is not normally distributed. The p-values have been corrected for multiple hypothesis testing across all orders and features. As usual, . means p < 0.1, \* means p < 0.05, \*\* means p < 0.01, and \*\*\* means p < 0.001. 

Geary's C correlogram can be computed by specifying `method = "C"`. 
```{r}
sfe_tissue <- colDataCorrelogram(sfe_tissue, c("nCounts", "nGenes"), 
                                 colGraphName = "visium", method = "C",
                                 order = 10)
```

```{r}
plotCorrelogram(sfe_tissue, c("nCounts", "nGenes"), method = "C")
```

For attributes of `annotGeometry`:
```{r}
sfe_tissue <- annotGeometryCorrelogram(sfe_tissue, 
                                       features = c("area", "eccentricity",
                                                    "convexity", "sine_theta"),
                                       annotGeometryName = "myofiber_simplified",
                                       annotGraphName = "myofiber_poly2nb",
                                       zero.policy = TRUE, order = 10)
```

```{r}
plotCorrelogram(sfe_tissue, c("area", "eccentricity", "convexity", "sine_theta"),
                annotGeometryName = "myofiber_simplified")
```

For myofiber area and convexity, Moran's I goes up in second order neighbors, because in one region in this tissue section, there are many large myofibers and what seem like small myofibers sandwiched between the large ones.

For gene expression
```{r}
sfe_tissue <- runCorrelogram(sfe_tissue, hvgs[1:15], colGraphName = "visium", order = 10,
                             BPPARAM = MulticoreParam(2))
```

```{r}
plotCorrelogram(sfe_tissue, hvgs[1:15])
```

With more genes, the colors become hard to tell apart. In case the correlograms of different genes have different patterns, the correlograms can be clustered and colored with the cluster rather than gene. In the example here, the genes plotted all have similar correlogram patterns, though some seem to decay past the 8th order more quickly than others. Just to demonstrate the clustering:
```{r}
set.seed(29)
corr_clusters <- clusterCorrelograms(sfe_tissue, hvgs[1:15], BLUSPARAM = KmeansParam(3))
head(corr_clusters)
```

The `color_by` argument can be used to color the correlograms by anything other than feature or sample. The `color_by` argument can be a column name in `rowData`, or a vector the same length as the `features` argument (as in this example).
```{r}
plotCorrelogram(sfe_tissue, features = hvgs[1:15], color_by = corr_clusters$cluster) +
  labs(color = "cluster")
```

### Moran scatter plot
In the Moran scatter plot, the x axis is the value itself and the y axis is the average value of the neighbors. The slope of the fitted line is Moran's I. Sometimes clusters appear in this plot, showing different kinds of neighborhoods for this value. Just like Moran's I, permutation testing, and correlogram functions, the functions for Moran scatter plot also follow the `calculate*` and `run*` patterns and have the same user interface. However, the plot can only be made for one feature at a time.

For colData:
```{r}
sfe_tissue <- colDataMoranPlot(sfe_tissue, features = "nCounts", 
                               colGraphName = "visium")
```

```{r}
moranPlot(sfe_tissue, "nCounts", colGraphName = "visium")
```

This plot is a `ggplot2` remake of the function to plot Moran scatter plots in `spdep`, and with contours to indicate point density to address overplotting. "Inflential" comes from [`influence.measures`](https://rdrr.io/r/stats/influence.measures.html) when the line is fitted. The contours can also be shown as filled and only the influential points are plotted individually.
```{r}
moranPlot(sfe_tissue, "nCounts", colGraphName = "visium", filled = TRUE)
```

The influential points can be shown in space

```{r}
colData(sfe_tissue)$nCounts_moranPlot_inf <- 
  colFeatureData(sfe_tissue)["nCounts", "MoranPlot_Vis5A"][[1]]$is_inf
```

```{r}
plotSpatialFeature(sfe_tissue, "nCounts_moranPlot_inf", 
                   colGeometryName = "spotPoly")
```

For `annotGeometry`:
```{r}
sfe_tissue <- annotGeometryMoranPlot(sfe_tissue, features = "area",
                                     annotGeometryName = "myofiber_simplified",
                                     annotGraphName = "myofiber_poly2nb",
                                     zero.policy = TRUE)
```

```{r}
moranPlot(sfe_tissue, "area", annotGeometryName = "myofiber_simplified", 
          graphName = "myofiber_poly2nb")
```

Singletons have no neighbors and are circled in this plot. There appears to be clusters in this plot, of small myofibers next to other small myofibers, larger ones next to larger ones, and small ones next to larger ones. To identify clusters on the Moran plot:

```{r}
set.seed(29)
clusts <- clusterMoranPlot(sfe_tissue, "area", 
                           annotGeometryName = "myofiber_simplified",
                           BLUSPARAM = KmeansParam(7))
```

```{r}
moranPlot(sfe_tissue, "area", graphName = "myofiber_poly2nb", 
          color_by = clusts$area, annotGeometryName = "myofiber_simplified") +
  labs(color = "cluster")
```

Again, the clusters can be plotted in space
```{r}
# There's an empty geometry
ag <- annotGeometry(sfe_tissue, "myofiber_simplified")
empty_ind <- st_is_empty(ag)
annotGeometry(sfe_tissue, "myofiber_simplified") <- ag[!empty_ind,]
annotGeometry(sfe_tissue, "myofiber_simplified")$area_moranPlot_cluster <- clusts$area
```

```{r}
data("ditto_colors")
ggplot(annotGeometry(sfe_tissue, "myofiber_simplified")) +
  geom_sf(aes(fill = area_moranPlot_cluster), color = NA) +
  scale_fill_manual(values = ditto_colors)
```

Clusters in the Moran plot delineate different regions in the tissue. Note that the clusters are paired, because, for example, when a larger myofiber is a neighbor of a smaller myofiber, then that smaller myofiber is also a neighbor of that larger myofiber -- the spatial neighborhood graph is undirected. 

For gene expression, to use one gene to demonstrate:
```{r}
sfe_tissue <- runMoranPlot(sfe_tissue, "Myh1", colGraphName = "visium")
```

```{r}
moranPlot(sfe_tissue, "Myh1", graphName = "visium")
```

There are no singletons here. Some Visium spots have neighbors that don't express Myh1 but spots that don't express Myh1 usually have at least some neighbors that do. There are 2 main clusters for spots whose neighbors do express Myh1. 

```{r}
set.seed(29)
clusts <- clusterMoranPlot(sfe_tissue, "Myh1", BLUSPARAM = KmeansParam(2))
```

```{r}
moranPlot(sfe_tissue, "Myh1", graphName = "visium", color_by = clusts$Myh1)
```

Again, plot the clusters in space
```{r}
colData(sfe_tissue)$Myh1_moranPlot_clust <- clusts$Myh1
plotSpatialFeature(sfe_tissue, "Myh1_moranPlot_clust", colGeometryName = "spotPoly")
```


# Limitations and future directions
At present, only univariate global spatial autocorrelation metrics are supported. These metrics can't tell whether spatial autocorrelation differs in different directions (i.e. anisotropy), nor can they tell what causes the spatial autocorrelation. Furthermore, it would be impractical and inefficient to check these metrics for each of thousands of genes, so multivariate ESDA would be helpful. Local univariate spatial metrics (each location has its own value rather than one value for the whole dataset), anisotropy, spatial modeling, and multivariate analyses from packages such as [`adespatial`](https://cran.r-project.org/web/packages/adespatial/index.html), [`spatialreg`](https://cran.r-project.org/web/packages/spatialreg/index.html), [`GWmodel`](https://cran.r-project.org/web/packages/GWmodel/index.html), and [`gstat`](https://cran.r-project.org/web/packages/gstat/index.html) will be added in later versions. 

For plotting, at present, the plotting functions don't plot the H&E image in the background. This may be added in a future version if we find it more helpful to plot the image. Furthermore, while `geom_sf` plots the origin at the lower left corner, the origin is at the top left corner in images, so the plots are flipped compared to the original H&E image (the H&E image in the beginning of the vignette was flipped to match the plots). As `coord_flip` doesn't work with `geom_sf`, flipping the y axis would involve either flipping the sign of the y coordinates and re-create the geometries or creating a custom coordinate reference system (CRS).

Finally, while Simple Features and some geospatial package support 3D data, this package and the plotting functions only support 2D data, as most geospatial resources cater to 2D data. Moreover, for 3D spatial transcriptomics data, the z dimension often has a much lower resolution than x and y, whether the z dimension comes from different z-planes in confocal imaging or from different tissue sections (and especially the latter case). The different resolutions may mean that the z dimension should be treated differently from x and y. 

```{r}
sessionInfo()
```

